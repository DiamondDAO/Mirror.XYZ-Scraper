"{\"content\":{\"body\":\"## Summary\\n\\n- On \\\"signup\\\", we will generate a **signing key**, using a well audited open source crypto library such as the natively implemented *SubtleCrypto*. We will use the Ethereum private key *that owns the publication* to **sign this signing key** and we will store and publish that as an attestation linking the ENS domain to any Entry published by that signing key**.**\\n    - The client can store the signing key in IndexedDB, perhaps encrypted with a password, and the client can use this key to sign data any that we want to store. We will publish the signature that connects the Ethereum address to the signing key, thereby proving that this signing key was authorized by the owner of the publication.\\n    - Note: This means that the client browser always has access to an encrypted signing key via IndexedDB when they're on the domain where they first logged in. If encrypted, the user has to \\\"log in\\\" with a password to decrypt that key. This is similar to how Metamask uses a password for their \\\"KeyRing\\\" scheme. In contrast to MetaMask, in our scheme, the signing key can never hold funds, because it's not an Ethereum address.\\n\\n- When the user wants to use a different browser that does not have a signing key on it, or for some other reason loses their signing key, we will generate a new key, sign it with the Ethereum ownership key, and store that. A user can therefore have multiple signing keys.\\n- Keys can be revoked via \\\"log out\\\" â€” i.e. destroying the signing key in storage, or (in a later version) by signing a message that explicitly revokes the key and storing that on Arweave (in the case of a compromise). Clients will need to respect this revocation.\\n\\nThe UX for the signing mechanic is similar to something Cryptokitties does, and our language could read something like \\\"I authorize the publication of articles on [diff.mirror.xyz](http://diff.mirror.xyz) from this device, using the public address {x}\\\".\\n\\n![Metamask Signing Example](https://images.mirror-media.xyz/publication-images/d533bfff-6a13-4d71-bbe5-0cb784e0b158.jpeg)\\n\\n## Rationale\\n\\n- In order to sign an entry for `publication`, we must prove ownership of the publication to which it is submitted.\\n- Signing using a separate \\\"signing key\\\", rather than the Ethereum private key itself gives the client **more flexibility to store these keys without risking funds** on Ethereum.\\n- Having the signing key be a well-supported standard, as opposed to Ethereum keys themselves, allows more robust client-server interactions.\\n\\n## Alternatives\\n\\n- Have every interaction signed by the Ethereum owner address\\n    - This creates a cumbersome UX.\\n- Store an Ethereum address as the signing key\\n    - Doesn't really confer any benefit, and it could be confusing for a user if they know.\\n    - WebCrypto doesn't work with Ethereum addresses*, and we want to use WebCrypto if we're storing keys locally. *Specifically: WebCrypto does contain a CryptoKey ECDSA type, but it does not support the secp256k1 curve used in Ethereum; instead it uses the NIST secp256r1 curve.\\n\\n## Potential Downsides\\n\\n- To be discussed synchronously.\\n\\n## Engineering Implementation\\n\\nHere I'll compile scripts for generating keys, storing keys, signing keys, signing entries, etc.\\n\\n**Note about ECDSA signatures specifically**: It looks like some people using Firefox and Safari are having problems storing ECDSA keys in IndexedDB via a popular storage libraries, so we might want to walk through our full options: \\n\\n- [https://github.com/localForage/localForage/issues/844](https://github.com/localForage/localForage/issues/844)\\n- [https://github.com/fission-suite/keystore-idb/issues/1](https://github.com/fission-suite/keystore-idb/issues/1)\\n\\n### Key Generation\\n\\nCreate a new keypair using ECDSA, and make it non-extractable (i.e. it can only sign messages).\\n\\n```jsx\\nwindow.crypto.subtle.generateKey(\\n    {\\n        name: \\\"ECDSA\\\",\\n        namedCurve: \\\"P-256\\\", //can be \\\"P-256\\\", \\\"P-384\\\", or \\\"P-521\\\"\\n    },\\n    false, //whether the key is extractable (i.e. can be used in exportKey)\\n    [\\\"sign\\\", \\\"verify\\\"] //can be any combination of \\\"sign\\\" and \\\"verify\\\"\\n)\\n.then(function(key){\\n    //returns a keypair object\\n    console.log(key);\\n    console.log(key.publicKey);\\n    console.log(key.privateKey);\\n\\t\\t// This would be the place to store the key in IndexedDB.\\n})\\n.catch(function(err){\\n    console.error(err);\\n});\\n```\\n\\n### Storing the Keys\\n\\nThe actual data for the private key shouldn't be extractable. We can then store the key in IndexedDB. We can also consider encrypting it with a password before we store it.\\n\\n**Note**: IndexDB has same-origin policy for accessing data, so the signing key will only be accessible by the same domain where it was created!\\n\\nMore from [developer.mozilla.org](http://developer.mozilla.org) that tells us we should use IndexedDB:\\n\\n> CryptoKey objects can be stored using the structured clone algorithm, meaning that you can store and retrieve them using standard web storage APIs. **The specification expects that most developers will use the IndexedDB API to store CryptoKey objects.**\\n\\nSo CryptoKeys are really meant to be stored here in IndexedDB.\\n\\nLet's use a small library for doing this:\\n\\n```jsx\\nnpm install idb\\n```\\n\\nLet's create a DB and store the private key there.\\n\\n```jsx\\nimport { openDB, deleteDB, wrap, unwrap } from 'idb';\\n\\nconst dbName = \\\"MirrorXYZ\\\";\\nconst version = 1;\\n\\nconst tableName = \\\"signingKeys\\\";\\n\\nconst db = await openDB(dbName, version, {\\n\\t// First the first call, or upgrades, we define the schema.\\n  upgrade(db) {\\n    // Create a store of objects\\n    const store = db.createObjectStore(tableName, {\\n      // The 'id' property of the object will be the key.\\n      keyPath: 'id',\\n      // If it isn't explicitly set, create a value by auto incrementing.\\n      autoIncrement: true,\\n    });\\n    // Create an index on the 'publicKey' property of the objects.\\n    store.createIndex('publicKey', 'publicKey');\\n  },\\n});\\n\\n// Store the key we generated to the signingKeys table, along with the date.\\nawait db.add(tableName, {\\n\\t...key, // publicKey, privateKey\\n  date: new Date(),\\n});\\n\\n// Get all the signingKeys in date order:\\nconsole.log(await db.getAllFromIndex(tableName, date));\\n```\\n\\n### Signing the Signing Key with Ethereum Key\\n\\nThis verifies that the Ethereum address that owns the ENS Label attests to this signing key. There are lots of examples and libraries that explain how to do this! So this is just one example, using Eth.js:\\n\\n```jsx\\n\\nfunction connect () {\\n  if (typeof ethereum !== 'undefined') {\\n    ethereum.enable()\\n    .catch(console.error)\\n  }\\n}\\n\\nconst msg = ethUtil.bufferToHex(new Buffer(text, 'utf8'));\\nconst var from = web3.eth.accounts[0];\\n\\nif (!from) return connect();\\n\\nconst params = [from, msg]\\n\\n// Using Eth.js\\nconst eth = new Eth(web3.currentProvider)\\n\\neth.personal_sign(msg, from)\\n  .then((signed) => {\\n\\t\\t// Now we have the signed message, we should send this to the\\n\\t\\t// server. I think we could also store this in IndexedDB.\\n    console.log('Signed!  Result is: ', signed);\\n\\n\\t\\t// We can  alsoverify that this address can recover the original message.\\n    return eth.personal_ecRecover(msg, signed)\\n  })\\n  .then((recovered) => {\\n\\t\\t// recovered here will be the sender's address, if it recovered correctly.\\n    if (recovered === from) {\\n      console.log('Ethjs recovered the message signer!')\\n    } else {\\n      console.log('Ethjs failed to recover the message signer!')\\n    }\\n  });\\n```\\n\\n### Signing an Entry with the Signing Key\\n\\nThis verifies that a signing key has committed to the entry. There are lots of examples of how to do this here: [https://github.com/diafygi/webcrypto-examples](https://github.com/diafygi/webcrypto-examples)\\n\\n```jsx\\nwindow.crypto.subtle.sign(\\n    {\\n        name: \\\"ECDSA\\\",\\n        hash: {name: \\\"SHA-256\\\"}, //can be \\\"SHA-1\\\", \\\"SHA-256\\\", \\\"SHA-384\\\", or \\\"SHA-512\\\"\\n    },\\n    privateKey, // from what we stored in IndexedDB.\\n    data //ArrayBuffer of data you want to sign\\n)\\n.then(function(signature){\\n    // returns an ArrayBuffer containing the signature\\n    console.log(new Uint8Array(signature));\\n})\\n.catch(function(err){\\n    console.error(err);\\n});\\n```\\n\\n### Password Protection (NOTE: This might not be needed)\\n\\nEncrypt the key with a password. This would protect a user in the case of an attacker actually having their computer. Could use a variety of strategies here.\\n\\n```jsx\\n// The same library used by MetaMask; a very simple one using\\n// the browser's native crypto library.\\nconst encryptor = require('browser-passworder');\\n\\n// After generating the signing key, create an object that contains it.\\nconst keyData = { ... };\\n\\n// Encrypt that data with a password.\\nconst encryptedKeyData = encryptor.encrypt(password, keyData);\\n```\\n\\nDecrypt the key with a password:\\n\\n```jsx\\n// Whenever we need to access it, decrypt it with the password.\\nconst decryptedKeyData = await encryptor.decrypt(password, encryptedKeyData);\\n```\",\"timestamp\":1609912129,\"title\":\"RFC: Signing Data\",\"publication\":\"eng\"},\"digest\":\"C0EBTmhSZ5JBLo-HvAOK6XAAwxLmDAptTy2p4iCfLD4\",\"authorship\":{\"contributor\":\"0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"-mO7_8fHa8SACriVB65_6lma_BCEAbNa7wkYM0g7KL8\\\",\\\"y\\\":\\\"y4jL_Oux8SXHN2hhdfast1RTWZK5qiixtRcoUAf8IUg\\\"}\",\"signature\":\"fApSH00pTQLuxoNc-gm11ZozDC5XASxkMsOm18tFZOYd3p-vjAoM1fVEjzLmQ_uajlSudNe5_dhGuhPNC-bR7A\",\"signingKeySignature\":\"0x84f8b19908779ae6b66a05236c8e17ef22b039aad452f14a8be488501ef7ec2c5c1037cca144a3b679143850ff2c684156314495e77a5020707f8c815a9fe7db1b\",\"signingKeyMessage\":\"I authorize the publication of articles on eng.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"-mO7_8fHa8SACriVB65_6lma_BCEAbNa7wkYM0g7KL8\\\",\\\"y\\\":\\\"y4jL_Oux8SXHN2hhdfast1RTWZK5qiixtRcoUAf8IUg\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"version\":\"12-21-2020\",\"originalDigest\":\"1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc\"}"