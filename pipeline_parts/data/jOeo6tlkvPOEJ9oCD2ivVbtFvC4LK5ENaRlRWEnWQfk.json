"{\"content\":{\"body\":\"Last night I spent 6 hours pulling my hair out trying to figure out why after compiling my contracts with hardhat, the generated factory in typechain/factories contained no bytecode or deploy export. This post is meant to explain how I solved this issue and help other developers from losing their minds. If you are stumbling upon this post after hours of searching the internet in terms of a fix, hopefully this helps.\\n\\nThis would happen seemingly at random. I would code the contract, compile and everything be as expected. A few minutes later after working on a separate contract, I would compile again via hardhat (*npx hardhat compile*) and the factory for the other contract would contain no bytecode or ability to deploy it!\\n\\nIt turns out, this all had to do with naming collisions and the way typechain and hardhat typechain generates types from solidity contracts. Letâ€™s say I have a contract which we will creatively title *ContractOne*.\\n\\n```\\ncontract ContractOne {\\n  //beautiful contract with lots of functions and stuff\\n} \\n```\\n\\nNow I code a separate contract which we will creatively title *ContractTwo*. *ContractTwo* uses some basic functionality of *ContractOne*, but not everything and does not inherit it. To make my life easier I write a basic interface for the functionality I want from *ContractOne.*  My ContractTwo.sol file looks something like this:\\n\\n```\\ninterface ContractOne {\\n  //a few function signatures\\n}\\n\\ncontract ContractTwo {\\n  //beautiful contract with lots of functions and stuff\\n}\\n```\\n\\nCan you spot the problem? It turns out, when compiling *ContractTwo*, typechain will generate types for *ContractOne* and *ContractTwo*, but since both the interface and the contract share the same name, depending on the order of your edits, you could end up with either type and all our written tests, deployments, etc. will fail.\\n\\nThe fix is quite simple and a best practice seen in a lot of contracts. It turns out using this best practice can help us avoid this extremely bothersome naming collision issue. We simply append and *I* to our interface name.\\n\\n```\\ninterface IContractOne {\\n  //a few function signatures\\n}\\n\\ncontract ContractTwo {\\n  //beautiful contracts with lots of functions and stuff\\n}\\n```\\n\\nNow when we run *npx hardhat compile*, typechain will generate types for both the interface AND the contract. Exactly what we want and the original expected behavior! \",\"timestamp\":1636929311,\"title\":\"Naming Collisions With Solidity,Hardhat, and Typechain\"},\"digest\":\"8Re2aoB8_wnkWCP3XFQnU_fpctBnMUVu2It7FnRQvJ4\",\"authorship\":{\"contributor\":\"0x6fe6a50f1017D485a2750f1a69273d82b50f54C6\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Geqd9OdHfHtDzsa0q506K4DXyxBxxunz6BZc0uGELC4\\\",\\\"y\\\":\\\"uhuwYqOyiyPRy0G-9u8cg4jCndHrOJD28xLY5z2zKIc\\\"}\",\"signature\":\"HfHyqMxgHazaBEicaQjDNpCo8kktsXNnuS3-2PSRmMnPT_4wjVf01WzsVeHxtFCajvfGhnMfGdYcSowV3Gvohw\",\"signingKeySignature\":\"0xda8cd83b868df36fd50ef4b375475dd3822370860b0abf881070d2ffa241c196047923f576f76de84bdc7e1adbf6d386cd4a76ae7bcaafe11999a098b44ad0121c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Geqd9OdHfHtDzsa0q506K4DXyxBxxunz6BZc0uGELC4\\\",\\\"y\\\":\\\"uhuwYqOyiyPRy0G-9u8cg4jCndHrOJD28xLY5z2zKIc\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"pv-QOnzl50A_BuWcKNbyDBMYT3KeusIYsRCZbUemVSg\"}"