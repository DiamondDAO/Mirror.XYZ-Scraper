"{\"content\":{\"body\":\"# A technical guide to on-chain governance\\n\\n*Disclaimer: this post and accompanying code is meant for educational purposes only. None of this is audited, and you should seek out audits before using contracts in production.*\\n\\nThere has been much ado about DAOs lately--they are being used to [govern financial protocols](https://vote.makerdao.com/), [form modern day guilds](https://twitter.com/developer_dao), and [crowdfund the sale of historical documents](https://twitter.com/ConstitutionDAO).\\n\\nBut how do they work on-chain? This post will walk through an example of setting up governance using a variant of the popular governance contracts created by Compound Finance. The task? Deploying the U.S. federal government as smart contracts on Ethereum.\\n\\nAll the code discussed in this post can be found in a GitHub repo [here](https://github.com/alexkroeger/the-federal-govt-as-solidity/tree/main). Hat tip to [OpenZeppelin](https://openzeppelin.com/) for an excellent and extensive [library of contracts](https://github.com/OpenZeppelin/openzeppelin-contracts) that I use heavily in this tutorial.\\n\\n## The contracts\\n\\n### CongressToken\\n\\n[link to file](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/contracts/CongressToken.sol)\\n\\nThe first step in on-chain governance is for determining who will be doing the governing! For the federal government, that will be Congress.\\n\\nDAO voting power is typically determined by one’s balance of an [ERC20 token](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/). To create our governance token, which I’ll be calling `CongressToken`, we’ll use OpenZeppelin’s standard ERC20 implementation as well as an extension they’ve made called [ERC20Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Votes.sol).\\n\\n`ERC20Votes` will give us the ability to keep track of voting power and exposes an interface to delegate the voting power of your tokens to yourself or someone else.\\n\\n![CongressToken](https://images.mirror-media.xyz/publication-images/1SNva85Q5nwnVFE4p-wOg.png?height=587&width=822)\\n\\nTwo items to note here. First, in the constructor, I mint 3 tokens (technically there should be 535, one for each member of Congress, but I’m too lazy to simulate more than 3 members) and transfer them to the deployer address.\\n\\n` _mint(msg.sender, 3);`\\n\\nSince there is no publicly available `mint()` function, this will be the total supply of CONGRESS forever. I leave it up to the deployer to distribute these tokens, which is not what you want to do in prod. It would be more appropriate to grant the tokens to a separate contract that will distribute tokens according to some rule.\\n\\nSecond item to note is that I set `decimals()` to 0. Token balances are always stored as an integer on-chain, and the ERC20 standard dictates that you specify the number of decimal places used to convert these integers into the desired fractional units. 18 decimals is most common, as that is used by ether itself. Here, I don’t desire any ability to fractionalize votes (it’ll be one senator, one vote), so I set decimals to 0.\\n\\n### FederalGovernment\\n\\n[link to file](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/contracts/FederalGovernment.sol)\\n\\nNext we need to create the logic for governance--how do proposals get created and voted on?\\n\\nFor this we use the OpenZeppelin [Governor](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/governance/Governor.sol) contract. It’s based on the popular Compound governance contracts, which are also used by Uniswap. Additionally, OpenZeppelin has made an extension called [GovernorCompatabilityBravo](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/governance/compatibility/GovernorCompatibilityBravo.sol), which can make the interface of the governance contract compatible with Compound’s [GovernorBravo](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol).\\n\\n![](https://images.mirror-media.xyz/publication-images/aWUmTfOC9vsMxlDgKlEhu.png?height=1061&width=823)\\n\\nThere are two constructor arguments--the first (`_token`) is an `ERCVotes`-compatible ERC20 that will serve as the governance token. For my setup this will be the address of `CongressToken`. The second (`_timelock`) is address of a timelock contract, which we’ll get to shortly.\\n\\nI set a few constants in the contract. `GovernorVotesQuorumFraction` controls what percent of the total supply of the governance token needs to vote in order for a proposal to pass. I (somewhat arbitrarily) have 4%.\\n\\n` GovernorVotesQuorumFraction(4)`\\n\\nThe `votingDelay` is the amount of time between when a proposal is created and when voting begins, specified in terms of number of blocks. This gives governance token holders time to review the proposal and delegate their voting power if they choose to do so. I set this at a low value (2 blocks), but this should probably be a day or two in production systems.\\n\\n![](https://images.mirror-media.xyz/publication-images/BAn-7s-FEySLa6YJJOgGE.png?height=174&width=760)\\n\\nThe `votingPeriod` is the amount of time allocated for voting in terms of number of blocks. Addresses with delegated voting power would need to submit an on-chain vote transaction during that amount of time. I again set this to a low value (100 blocks), but this should be probably 3-5 days in a production system for sensitive items.\\n\\n![](https://images.mirror-media.xyz/publication-images/mBOqOs32kL2Q1KcGssvNV.png?height=120&width=787)\\n\\nFinally, I set the `proposalThreshold`. This ensures that not just anyone can submit a proposal--you need to have a certain amount of delegated voting power. Here, I choose 1, meaning any member of congress (delegated CONGRESS voting power of 1) can submit a proposal.\\n\\n![](https://images.mirror-media.xyz/publication-images/uKfwStkvXnevIdjVsgGPA.png?height=128&width=827)\\n\\n### FederalGovernmentTimelock\\n\\n[link to file](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/contracts/FederalGovernmentTimelock.sol)\\n\\nMany DeFi protocol governance systems include a timelock contract. This contract is the one that has the ability to update critical systems, and ensures that no changes can be made without some delay that allows affected users to withdraw funds, change parameters, etc. before a change is made.\\n\\n![](https://images.mirror-media.xyz/publication-images/ovBSkJxLKS4cjOlGaZhsI.png?height=305&width=850)\\n\\nFor this contract I simply use OpenZeppelin’s [TimelockController](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/governance/TimelockController.sol), which has 3 constructor arguments. The first, `_minDelay`, specifies the amount of time (in seconds this time) that must pass before a change is put into effect. The second and third are arrays of addresses having to do with who can affect changes. `_proposers` can queue a change and `_executors` can enact the change.\\n\\nWe’ll get into how to set those values when we get into the deployment.\\n\\n### USDollar\\n\\n[link to file](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/contracts/USDollar.sol)\\n\\nEvery governance system needs something to govern!\\n\\nIn this setup, the federal government manages an ERC20 contract representing the US Dollar.\\n\\n![](https://images.mirror-media.xyz/publication-images/ieL9Op1o0x_ysNsNKY09N.png?height=850&width=861)\\n\\nI again use OpenZeppelin’s standard ERC20 implementation, but I don’t use the `ERC20Votes` extension, because USD won’t be a governance token. I make use of OpenZeppelin’s [Ownable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol) contract.\\n\\n`Ownable` allows you to restrict certain functions to be used by an admin only. The default owner is the contract deployer. In the constructor, I add an argument to specify the owner to override the default behavior. I’ll make the timelock contract the owner during deployment.\\n\\nI add two public functions here, `mint` and `burn`, that have the modifier `onlyOwner`. This will give the federal government the ability to mint and burn USD by proposal.\\n\\nGenerally, governance should have the ability to call certain admin functions (like `mint` and `burn` in this case).\\n\\n## Deployment\\n\\nIn the accompanying repo, I include a script called [deploy_util](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/scripts/deploy_util.ts) that sets up the governance system.\\n\\nThe first step is to deploy the governance token:\\n\\n![deploying CongressToken.](https://images.mirror-media.xyz/publication-images/14yEiRSbXkwHfpX9XGd2-.png?height=288&width=737)\\n\\nThis is straightforward--I print out the deployed address along with decimals and total supply.\\n\\nNext step is to deploy the timelock contract, as it will be an input argument for the governance contract.\\n\\n![deploying the timelock contract](https://images.mirror-media.xyz/publication-images/sYG2u8yPNIChj3QqexzJX.png?height=589&width=805)\\n\\nNote that I leave `_proposers` empty here. The governance contract will be the only proposer, but we do not yet know its address. For `_executors`, I include only the zero address (0x000…) which means any address can execute. This isn’t insecure, since only transactions that are proposed can be executed, and only governance can propose.\\n\\nNext I deploy the governor contract, passing in the addresses for the governance token and the timelock.\\n\\n![deploying the governor contract](https://images.mirror-media.xyz/publication-images/86xnhl45zylkT4RQFgTKk.png?height=923&width=856)\\n\\nAt this point the deployer address is an admin on the timelock. I grant the `FederalGovernment` contract the role of proposer, and then renounce the deployer’s admin privilege on the timelock so that governance is in control.\\n\\nFinally, I deploy the `USDollar` contract, passing in the timelock contract as the owner. With that, we’re ready for governance!\\n\\n![](https://images.mirror-media.xyz/publication-images/FzB-jjiyneNfC4OVQLpSj.png?height=243&width=762)\\n\\n## Creating and executing a proposal\\n\\nNow we can see what the governance system can do.\\n\\nThe repo contains another script called [proposal_scenario](https://github.com/alexkroeger/the-federal-govt-as-solidity/blob/main/scripts/proposal_scenario.ts) that walks through the creation of a proposal in a local hardhat environment.\\n\\nFirst, some housekeeping. I need to distribute the CONGRESS tokens to some senators. I grab three spare addresses to have 3 senators (`redSenator`, `blueSenator`, and `swingSenator`--think Joe Manchin). In order to vote later, the token balances must be delegated to a voter. In this case, all the senators delegate to themselves.\\n\\n![](https://images.mirror-media.xyz/publication-images/g3tirtphUfaoC8CNZBrSq.png?height=297&width=818)\\n\\nNow we’re ready to create a proposal.\\n\\n### Creating a proposal\\n\\n`redSenator` wants to propose that $2M is minted, and $1M goes to them and $1M goes to `swingSenator`.\\n\\nThe `FederalGovernment` contract interface has a `propose` function, whereby you can pass calldata to be executed by the timelock.\\n\\n![](https://images.mirror-media.xyz/publication-images/JD2vTxk59XLzpEoDRAzOI.png?height=943&width=897)\\n\\nI create the calldata for the 2 calls to mint on the USDollar contract, and add them to the proposal. The proposal also needs the address to call for each calldata (the USDollar contract for both in this case), the amount of ETH to be sent with the call (0 in this case), and a description.\\n\\nOnce we create the proposal, the governance contract recognizes it as “pending.”\\n\\n### Voting\\n\\nWe can’t quite vote on the proposal yet. You might remember that I set `reviewPeriod` value on the governance contract that requires `n` blocks pass before voting begins, giving folks a chance to delegate if they choose to do so.\\n\\nSince this is a local environment, we can speed through it.\\n\\nNow the senators can vote. Given that they’ll receive $1M each, `redSenator` and `swingSenator` are strongly in favor. `blueSenator`, who will receive nothing, opposes.\\n\\n![](https://images.mirror-media.xyz/publication-images/oseVusKxGA7zGwTw4PjtW.png?height=541&width=780)\\n\\nIf we call the governance contract, we can see the votes recorded.\\n\\n### Queuing the proposal\\n\\nBefore we can queue up the proposal with the timelock, the voting period must finish. You may recall that I set this to 100 blocks in the governance contract.\\n\\nOnce again, we speed through. Since the yeas have it, the proposal is in the “succeeded” state.\\n\\nThe next step is to queue the proposal with the timelock. The governance contract allows anyone to do this once the voting process is done, so I have `swingSenator` do the honors.\\n\\n![](https://images.mirror-media.xyz/publication-images/cPBthkdCK6tMDdNIg8tG2.png?height=487&width=774)\\n\\n### Executing the proposal\\n\\nThe final step is to go live with the changes. We have another delay, this time enforced by the timelock contract.\\n\\nAfter the time has passed, anyone can execute the proposal. I have the original contract deployer do so.\\n\\n![](https://images.mirror-media.xyz/publication-images/CNxfRgXpvEAKkOjjt6XLD.png?height=809&width=813)\\n\\nThe USD is successfully minted, governance in action!\\n\\n## Concluding thoughts\\n\\nI hope you found this tutorial helpful!\\n\\nTo recap, we:\\n\\n* re-created a simplified version of the federal government via on-chain governance, with a governance token (CONGRESS), a governor contract based on Compound’s popular contract, a timelock contract, and a managed ERC20 (USD)\\n* walked through creating, voting on, and executing an on-chain proposal in this setup.\\n\\nHere are links for your reference:\\n\\n* [the repository](https://github.com/alexkroeger/the-federal-govt-as-solidity)\\n* [OpenZeppelin documentation](https://docs.openzeppelin.com/contracts/4.x/)\\n* Ropsten deployments of the contracts:\\n  * [CongressToken](https://ropsten.etherscan.io/address/0x2eeff881aa0c77c289502daa024f152186966a6e)\\n  * [FederalGovernmentTimelock](https://ropsten.etherscan.io/address/0xe14a123e562b59fd8d7d910f772222ba575bb302)\\n  * [FederalGovernment](https://ropsten.etherscan.io/address/0x89bbec3be60b9673aef71861093f463f3db6ab1e)\\n  * [USDollar](https://ropsten.etherscan.io/address/0x859fe758307e9af3c2ed2190c0a0ff2ef4618156)\",\"timestamp\":1638304978,\"title\":\"The US government as a smart contract\"},\"digest\":\"jov_QvpAR9wLOZtjuT2pZ4UMOtKvqpRrsQKxJKchmeg\",\"authorship\":{\"contributor\":\"0x7B542178633f16940a131F8F6d670ffdbBe6b2Ab\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XzcLQfYQvleskKqT_aga9AZa_6IIFK9pGGRWPZWoDCs\\\",\\\"y\\\":\\\"AQ_aCUGRefLAo_7t1lMXg0ckaAROAQuGu7LJSWDvDbE\\\"}\",\"signature\":\"fmIB5uQcZRa6E2F4uCSFyYtebiBG0XNOuVRFRWcaLG-ho2nqs0X7ViV4RbUFh-ZPhJMegL93Ngxyz2Immz8yAw\",\"signingKeySignature\":\"0xdbbcd1daf2823ffde07ecab97d4cde97c71eabd0bad9a9d02cd0f51e0467765549e2149193ceacaf6871cf925e68d58d7bdd4acf3c8d88159a1f1ea9053a066101\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XzcLQfYQvleskKqT_aga9AZa_6IIFK9pGGRWPZWoDCs\\\",\\\"y\\\":\\\"AQ_aCUGRefLAo_7t1lMXg0ckaAROAQuGu7LJSWDvDbE\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"R3k7r5HzgguLuDPY2h2HnUi9nG4MyOJ7YjtwBBFxdrE\"}"