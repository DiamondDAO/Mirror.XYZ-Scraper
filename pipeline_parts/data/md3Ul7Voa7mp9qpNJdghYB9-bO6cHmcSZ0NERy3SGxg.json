"{\"content\":{\"body\":\"![](https://images.mirror-media.xyz/publication-images/d8c51ded-9ace-4788-a4c4-3dce0166a29e.jpg?height=640&width=1280)\\n\\nYou can now comment on my Mirror entries! Here’s how I implemented it in a decentralized way.\\n\\n\\n---\\n\\nFor a while now I’ve been maintaining a [custom Mirror client](https://github.com/m1guelpf/mirror-next). This allows me to use a custom domain (`m1guelpf.blog` instead of `miguel.mirror.xyz`), provide an [RSS feed](https://m1guelpf.blog/feed.xml) and retain some control over the design.\\n\\nSo, when I came across [The Convo Space](https://theconvo.space/), a “conversation protocol” built on top of [IPFS](https://ipfs.io/) & [Libp2p](https://libp2p.io/), I decided to try my hand at building a decentralized commenting system for the client.\\n\\n## Follow the Conversation\\n\\nTo get started, we need a way of getting the comments for the current entry. TheConvo works with threads and, fortunately, we can make up our own thread IDs. Since Mirror digests are supposed to be unique, we can use those as our thread ID, linking the comments to the entry regardless of the URL it’s displayed at.\\n\\nWith our thread ID figured out, we can use Vercel’s SWR library to fetch comments on page load.\\n\\n```js\\nconst { data: comments, mutate } = useSWR(\\n    `https://theconvo.space/api/comments?apikey=CONVO&threadId=${entry.digest}`,\\n    { revalidateOnFocus: false }\\n)\\n```\\n\\nThis gets us an array of comments we can loop over, including the comment’s contents, timestamp & address/ENS of the author. Since my design also included an avatar field, I tweaked the fetcher function to look at the avatar field of the commenters’ ENS domains, defaulting to a gradient avatar if they hadn’t set one or didn’t have an ENS domain.\\n\\n```js\\nconst DEFAULT_AVATAR = 'https://cdn.tryshowtime.com/profile_placeholder.jpg'\\n\\nconst getAvatarFromENS = ensName => {\\n    if (! ensName) return DEFAULT_AVATAR\\n\\n    return serverWeb3\\n        .getResolver(ensName)\\n        .then(resolver => resolver?.getText('avatar') || DEFAULT_AVATAR)\\n}\\n\\nconst commentFetcher = url =>\\n\\tfetch(url)\\n\\t\\t.then(res => res.json())\\n\\t\\t.then(comments => Promise.all(comments.map(async comment => ({\\n            ...comment,\\n            authorAvatar: getAvatarFromENS(comment.authorENS),\\n        }))))\\n\\nconst { data: comments, mutate } = useSWR(\\n    `https://theconvo.space/api/comments?apikey=CONVO&threadId=${digest}`,\\n    commentFetcher,\\n    { revalidateOnFocus: false }\\n)\\n```\\n\\n## Inviting the Conversation\\n\\nWith a system to read comments in place, we now need a way to post them. TheConvo’s process for this is pretty straightforward: [authenticate the user using a personal signature](/post/server-authentication-for-web3) and send an API request to post the comment.\\n\\n### Please Sign Here\\n\\nTo authenticate the users, we need to craft a special signature composed of the user’s wallet address and the current timestamp.\\n\\n```js\\nconst timestamp = Date.now()\\nconst signerAddress = await web3.getSigner().getAddress()\\nconst signature = await web3.getSigner().signMessage(\\n    `I allow this site to access my data on The Convo Space using the account ${signerAddress}. Timestamp:${timestamp}`\\n)\\n\\nconst token = await axios.post(\\n    'https://theconvo.space/api/auth?apikey=CONVO',\\n    { signerAddress, signature, timestamp }\\n).then(res => res.data?.message)\\n```\\n\\nThis token will be valid for 1 day, so I wanted to avoid prompting the user for a signature more than once a day. I thought about storing the token on `localStorage` along with an expiry date but ended up going with a cookie, as you can set those to expire automatically. Instead of calling the Convo API directly, I created an API route to handle login.\\n\\n```js\\nimport axios from 'axios'\\nimport { serialize } from 'cookie'\\n\\nconst ONE_DAY = 60 * 60 * 24 * 1000\\n\\nfunction createCookie(name, data, options = {}) {\\n\\treturn serialize(name, data, {\\n\\t\\tmaxAge: ONE_DAY,\\n\\t\\texpires: new Date(Date.now() + ONE_DAY * 1000),\\n\\t\\tsecure: process.env.NODE_ENV === 'production',\\n\\t\\tpath: '/',\\n\\t\\thttpOnly: true,\\n\\t\\tsameSite: 'lax',\\n\\t\\t...options,\\n\\t})\\n}\\n\\nexport default async ({ method, body: { signerAddress, signature, timestamp } }, res) => {\\n\\tif (method != 'POST') return res.status(405).send('Not Found')\\n\\n\\tconst token = await axios.post(\\n        'https://theconvo.space/api/auth?apikey=CONVO',\\n        { signerAddress, signature, timestamp }\\n    ).then(res => res.data?.message)\\n\\n\\tres.setHeader('Set-Cookie', [\\n        createCookie('convo_token', token),\\n        createCookie('convo_authed', true, { httpOnly: false })\\n    ])\\n\\n\\tres.status(200).end()\\n}\\n```\\n\\nNotice how I’m setting two cookies. The first one, `convo_token`, contains the actual token but is not accessible from JS. A second one, `convo_authed`, allows us to check if the token exists from the frontend, without exposing it. Here’s our updated code for the front end.\\n\\n```js\\nconst authenticateConvo = async web3 => {\\n\\tconst timestamp = Date.now()\\n\\tconst signerAddress = await web3.getSigner().getAddress()\\n\\tconst signature = await web3.getSigner().signMessage(\\n\\t\\t`I allow this site to access my data on The Convo Space using the account ${signerAddress}. Timestamp:${timestamp}`\\n\\t)\\n\\n\\tawait axios.post('/api/comments/login', {\\n\\t\\tsignerAddress, signature, timestamp\\n\\t})\\n}\\n\\nif (!document.cookie.includes('convo_authed')) authenticateConvo(web3)\\n```\\n\\n### POSTing the Comment\\n\\nFinally, posting the comment is as simple as making a POST request to the `/api/comments` endpoint. Since the frontend doesn’t have access to the Convo token, I created another API route for this.\\n\\n```js\\nimport axios from 'axios'\\n\\nexport default async ({ method, headers: { referer }, body: { signerAddress, comment, digest }, cookies: { convo_token } }, res) => {\\n\\tif (method != 'POST') return res.status(405).send('Not Found')\\n\\tif (!comment || !digest || !signerAddress) return res.status(400).send('Invalid Params')\\n\\tif (!convo_token) return res.status(401).send('Unauthorized')\\n\\n\\ttry {\\n\\t\\tawait axios.post(\\n            'https://theconvo.space/api/validateAuth?apikey=CONVO',\\n            { token: convo_token, signerAddress }\\n        )\\n\\t} catch {\\n\\t\\treturn res.status(401).send('Unauthorized')\\n\\t}\\n\\n\\tawait axios.post(\\n        'https://theconvo.space/api/comments?apikey=CONVO',\\n        { token: convo_token, signerAddress, comment, threadId: digest, url: referer }\\n    ).then(resp => res.json(resp.data))\\n}\\n```\\n\\nBack on the front end, we can use SWR’s mutate function to instantly display the comment at the end of our list (while we retry the request to fetch the new data).\\n\\n```js\\nconst result = await axios.post('/api/comments/post', {\\n\\tsignerAddress: await web3.getSigner().getAddress(), comment, digest\\n}).then(res => res.data)\\n\\nsetComment('')\\nmutate(comments => {\\n\\tcomments.push({\\n\\t\\t...result,\\n\\t    authorAvatar: 'https://cdn.tryshowtime.com/profile_placeholder.jpg'\\n\\t})\\n}, true)\\n```\\n\\n## That’s all, folks!\\n\\nHope you enjoyed the post! The Mirror client I mentioned at the start [is open-source](https://github.com/m1guelpf/mirror-next), and you can look at the commit that added the comment system [here](https://github.com/m1guelpf/mirror-next/commit/3c8f700eb89b6faba0713c14901a686673de18fc).\\n\\nYou can [follow me on Twitter](https://twitter.com/m1guelpf) to keep up with what I’m building, or leave a comment below to try the whole thing out!\",\"timestamp\":1629931835,\"title\":\"Decentralized Comments for Mirror\",\"publication\":\"miguel\"},\"digest\":\"FNel9cQNL35LewV3DgsvTAHa_0fFlokr-UBj9mS3-w0\",\"authorship\":{\"contributor\":\"0xE340b00B6B622C136fFA5CFf130eC8edCdDCb39D\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"JViahk9w_5eZhfUw8hSNZUyMFWGq11uUaT81uRoDYfI\\\",\\\"y\\\":\\\"kvhziGWnBwu96SeNq6YIEIUL_Vh5GAMprPH6dMLh1Bw\\\"}\",\"signature\":\"wd_-4ztAJfk2dWVX0RpEmA-ggknhBQA3_p6XVOTmHphhDJD_I77VNM5S1cucMvLEm3vDq7btZCqpRkQ-KE5HQw\",\"signingKeySignature\":\"0x8d7f91345fa15be04f64f7705d65475e2ff003daa9d0574ff73c7334927a42c0202d1e9631aa478cca8e9ee5168f558ec02bc72dc9d3b69c716df6ba5be10e371c\",\"signingKeyMessage\":\"I authorize the publication of articles on miguel.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"JViahk9w_5eZhfUw8hSNZUyMFWGq11uUaT81uRoDYfI\\\",\\\"y\\\":\\\"kvhziGWnBwu96SeNq6YIEIUL_Vh5GAMprPH6dMLh1Bw\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"o0yDNCC9Y1QXd0l6DeUsVTrAN6bnopAeY7A4Y1bMrwg\"}"