"{\"content\":{\"body\":\"## 故事背景\\n\\n0、前置说明\\n\\nif(DAO) 试图用非技术语言和少量数学及密码学知识，向一般读者解释：\\n\\n（1）zk-SNARK 是什么。\\n\\n（2）通过 zk-SNARK 的协议一步步进化过程弄清零知识的底层原理。\\n\\n（3）通过 Proving Key 、Verifying Key 是什么；Proof 包含的内容有哪些；为什么通过 Proving Key 可以得到 Proof ；为什么通过 Verifying Key 可以验证 Proof 等问题，阐述 zk-SNARK 是如何具体落地应用的 。\\n\\n关于zk-SNARK的学术论文包含严谨的数学公式和论证过程；关于zk-SNARK的应用程序代码也有一些成熟的 lib 可供使用。但这些应该是数学家、密码学家和程序员感兴趣的内容，而不是一般读者。所以本文更侧重于如何将zk-SNARK的理论和实践 “联系” 起来。\\n\\n文中如有错误之处还请指正。下面进入正文：\\n\\n1、什么是零知识证明\\n\\n零知识可以简单理解为：我有一个秘密，在不向我朋友阿文透露秘密的情况下，让阿文相信我知道这个秘密。我们将证明的过程/方法称做 “ 零知识证明 ”。\\n\\n2、零知识证明和 zk-SNARK\\n\\n零知识证明包含很多种证明方法，其中的一个证明方法叫做：zk-SNARK （除此之外还有 zk-STARK、BulletProof、zkCNN 等等）。\\n\\n3、zk-SNARK\\n\\nzk-SNARK = zero knowledge Succinct Non-interactive ARgument of Knowledge（非交互式简洁零知识论证）\\n\\n（1）zero knowledge：零知识，即在证明的过程中不透露任何内情。\\n\\n（2）Succinct：简洁的，主要是指验证过程不涉及大量数据传输以及验证算法简单。\\n\\n（3）Non-interactive：无交互，即 Prover 和 Verifier 之间不需要进行交互即可验证命题的真伪。\\n\\n（4）ARgument of Knowledge：知识论证，证明是严谨的，而论证是基于概率的，因而使用论证二字。\\n\\n4、zk-SNARK中的几个基础概念。\\n\\n（1）零知识 = 我的秘密。\\n\\n（2）Prover = 证明者，即上面例子中的“我”。\\n\\n（3）Verifier = 验证者，即上面例子中的“阿文”。\\n\\n（4）Proof = 我拿着这个证明（Proof）给阿文，阿文就可以验证我是否知道秘密。\\n\\n（5）Proving Key = 我通过 Proving Key 才能生成 Proof。\\n\\n（6）Verifying Key = 阿文通过 Verifying Key 可以验证我的 Proof 是否为真。\\n\\n## 协议背景\\n\\n协议中的零知识（即不能让他人知道的知识）：多项式 P(x) = x^3−3x^2+2x。\\n\\n协议中有2个角色：证明者和验证者。证明者自称知道 P(x)，验证者不知道 P(x)。\\n\\n证明的方式：证明者通过 Proving Key 生成 Proof 并发送给验证者，验证者通过 Verifying Key 验证 Proof 的正确性。整个过程中，验证者在不知道 P(x)的情况下验证了证明者是否知道 P(x)。\\n\\n## 协议一（ zk-SNARK 最原始版本）\\n\\n1、证明者\\n\\n首先将 P(x) = x^3−3x^2+2x 因式分解为 P(x) =(x−0)(x−1)(x−2)。\\n\\n2、证明者\\n\\n随机选择因式中的一部分 t(x) = (x−1)(x−2)，并 Public 出去。\\n\\n3、证明者\\n\\n证明者根据 P(x) = t(x) \\\\* h(x) 计算出 h(x) = P(x) /t(x) = (x-0) = x。\\n\\n注：在最终版 zk-SNARK 中对上面3步进行了较大改变，为了看起来和最终版本相对应，所以在此将证明者的动作拆分为1、2、3步。\\n\\n4、验证者\\n\\n随机取值 s，然后代入多项式计算 t(s) ，并将 s 发送给证明者。\\n\\n5、证明者\\n\\n根据验证者发来的 s ，计算P(s) 和 h(s)，并将计算结果发送给验证者。\\n\\n6、验证者\\n\\n使用第4步计算出的 t(s) 和第5步证明者发来的 P(s) 和 h(s)，验证 t(s) = P(s) / h(s) 是否成立。\\n\\n在这个最原始版本的协议中，我们回顾一下是如何实现证明的：证明者想向验证者证明他知道多项式 P(x)，但又不想暴露知识 P(x)。于是证明者通过 Proving Key = s 计算得到 Proof = P(s) 和 h(s)， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性。验证的整个过程中，验证者并不知道 P(x) 是什么，却通过 Verifying Key 验证出证明者“可能”知道 P(x)。当验证者随机取值 s0 …… s1 足够多的时候，验证者就可以大概率确认证明者知道 P(x)。\\n\\nProving Key 是什么？Verifying Key 是什么？Proof 包含的内容有哪些？为什么通过 Proving Key 可以得到 Proof ？为什么通过 Verifying Key 可以验证 Proof ？读到这里， if(DAO) 相信各位老板已经对传说中的 zk-SNARK 有一点感觉了。\\n\\n## 协议二（ 解决证明者用构造方式作弊的问题）\\n\\n在协议一的证明者第5步有一个明显的问题：验证者把 s 直接发给了证明者，证明者可以通过 s 计算出 t(s)的结果，比如 t(s)=5。进而证明者可以随意构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4，将结果发送给验证者进行作弊。\\n\\n为了解决这个问题，在协议二版本的 zk-SNARK 中，验证者不能把s直接发送给证明者，而是把经过隐藏之后的 s 发送给证明者。\\n\\n那么如何隐藏 s 呢，这需要用到一些密码学知识：同态加密。\\n\\n同态加密的具体做法是：验证者生成一个只有他自己知道的G，并将随机数 s 构造成 E(s) = G^s (mod N)的形式，以达到隐藏s的目的。即验证者不希望证明者通过 s 计算P(s)和 h(s)，而是让证明者通过 E(s) 计算 E(P(s)) 和 E(h(s)) 。这里有点绕，下面会解释具体的计算过程。\\n\\n1、2、3、证明者\\n\\n同上。\\n\\n4、验证者\\n\\n随机产生 s（不能直接发送给证明者），然后构造\\n\\nE(s^3) = (G^(s^3))\\n\\nE(s^2) = (G^(s^2))\\n\\nE(s) = (G^s)\\n\\n目的（1）：隐藏s，不让证明者通过s计算t(s)，所以就不能构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4。\\n\\n目的（2）：隐藏了多项式的系数，因为知道了多项式的系数就等于知道了多项式，从而泄露了知识。\\n\\n最后将构造的 E(s^3)、E(s^2) 、E(s) 发给证明者。\\n\\n5、证明者\\n\\n通过E(s^3) 、E(s^2) 、E(s)计算E(P(s)) ，计算过程如下：\\n\\nE(P(s)) = G ^ P(s) = G ^ (s^3−3s^2+2s) = G ^ ( P(s) ) = 图1最右侧\\n\\n![图1](https://images.mirror-media.xyz/publication-images/t0olzObG_C3qxM4N8yMi2.png?height=110&width=1476)\\n\\n证明者把验证者发过来的 E(s^3) 、E(s^2) 、E(s) 代入最左边的方程即可求解出E(P(s)) 。同样的方法计算E(h(s))。\\n\\n最后把 E(P(s)) 和 E(h(s)) 发送给验证者。\\n\\n6、验证者\\n\\n最后验证：E(P(s)) 是否= E(h(s)) ^ t(s)\\n\\n这是因为协议一中验证者验证 “ P(s)是否 = h(s) \\\\* t(s) ”  等价于 “ G ^ P(s) 是否 = (G ^ h(s)) ^ t(s) ”，即E(P(s)) 是否= E(h(s)) ^ t(s) 。\\n\\n在这个改进版的协议二，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 计算得到 Proof = E(P(s)) 和 E(h(s)) ， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n## 协议三（ 用 KEA 解决证明者必须用验证者发来的参数计算 E(P(x)) 的问题）\\n\\n在协议二的证明者第6步存在一个证明者的问题：\\n\\n验证者要验证的G ^ P(s) = (G ^ h(s)) ^ t(s) 等价于 G ^ P(S) = (G ^ t(s)) ^ h(s)，证明者可以通过 E(s^3) = (G^(s^3))、E(s^2) = (G^(s^2))、E(s) =(G^s) 计算出来G^t(s) = E(t(s))。\\n\\n这是因为t(s)是公开的，E(t(s)) = 图1最左侧 = 图1最右侧，而E(s^3)、E(s^2) 、E(s)证明者又是知道的。这时证明者可以根据E(t(s))，指定一个h(s)，并构造E(P(s)) ，从而满足E(P(s)) = E(t(s)) ^ h(s) 。\\n\\n所以产生了问题：证明者给验证者的 E(P(x)) 不是用验证者提供的题干： (G^(s^3))， (G^(s^2))，(G^s)计算出来的，即证明者不知道 P(x) 却通过 h(s) 构造了一个满足 E(P(s)) = E(t(s)) ^ h(s)约束的假 E(P(s))，从而骗过了验证者。\\n\\n解决思路：验证者再发送一个新的参数，该参数验证 E(P(x)) 必须用 (G^(s^3))， (G^(s^2))，(G^s) 计算出来。这个方法叫 KEA：Knowledge-of-Exponent Assumption 指数知识假设。\\n\\n4、验证者\\n\\n随机产生 s 并同态加密，然后随机产生 α（阿尔法不方便打字，请允许我用 a 代替偷懒）\\n\\n然后构造 (G^(s^3))， (G^(s^2))，(G^s) ，构造 (G^((a \\\\* s^3))， (G^(a \\\\* s^2))，(G^(a \\\\* s))\\n\\n最后将 G^P(s)，G^P(a \\\\* s) 和 G^h(s) 发给证明者。\\n\\n5、证明者\\n\\n通过 \\\\[ (G^(s^3))， (G^(s^2))，(G^s) \\\\]，\\\\[ (G^((a \\\\* s^3))，(G^(a \\\\* s^2))，(G^(a \\\\* s)) \\\\]计算得出 G^P(s)，G^P(a \\\\* s)，连同证明者第3步已知的 G^h(s) 一并发给验证者。\\n\\n6、验证者\\n\\n（1）最后验证：G^P(s) 是否= (G^h(s)) ^ t(s) （验证零知识：多项式 p(x) 有根 t(x)）；\\n\\n（2）还需要验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) （用来校验证明者是否使用了指定的多项式）。\\n\\n这是因为随机数 a 是验证者产生的，证明者并不知道。验证者拿到证明者计算出来的 G^P(s)和 G^(P(a \\\\* s))，通过a进行验证即可。证明者如果通过构造 G^t(s)，指定一个h(s)，从而形成 (G^h(s)) ^ t(s) = (G^t(s)) ^ h(s) 的形式，然后计算出 G^P(s)，是无法满足 G^P(s) 的a次幂刚好等于G^(P(a \\\\* s)) 的。\\n\\n经过上面的分析，协议三的4、5、6步形如图2：\\n\\n![图2](https://images.mirror-media.xyz/publication-images/142Ixtm7zd5HbfLCEGuDG.png?height=882&width=1364)\\n\\n在这个改进版的协议三，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 和 \\\\[ E(a \\\\* s^3)\\\\*、E( a \\\\* s^2) \\\\*、E(a \\\\* s) \\\\] ，计算得到 Proof = \\\\[ g^p = G^P(s) ，g^p’ = G^P(a\\\\*s) \\\\] ， 并发送给验证者。\\n\\n（0）验证者的 Verifying Key = \\\\[  t(s) ，a \\\\]\\n\\n（1）验证者通过 t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n（2）验证者通过 a 验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) ，即证明者提供的 g^P 是用验证者提供的 (G^(s^3))， (G^(s^2))，(G^s)计算出来的。\\n\\n> 未完待续\",\"timestamp\":1639641687,\"title\":\"浅谈零知识证明之zk-SNARK\"},\"digest\":\"6q7C7rAbOWRTe7WneeHKWdijjTsJGTjGcDbmjNANnQo\",\"authorship\":{\"contributor\":\"0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"signature\":\"qQ4somLiae5sp2jpbDFCeetrGlZAJ21cdxluIfI1qxlf8EZhFF8q3bVaWYPBKrJX1OOmDxO7F__WpL7vR95lTA\",\"signingKeySignature\":\"0x37986d551641971cdf6ada5c4365b09fa1f1c9565275e4a2e69a6dfcc1435d3a3e15e6f1cbc1bd770fba430d41423a94c25d58507bcf912632c134b280faffdc1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"X3qSOjObTknXQ_iGhDBFYETibD0TVW0twz5QDIthjGI\"}"