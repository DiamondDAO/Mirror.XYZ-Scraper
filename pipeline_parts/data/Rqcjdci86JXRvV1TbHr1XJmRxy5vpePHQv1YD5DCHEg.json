"{\"content\":{\"body\":\"Very quickly my interest in the crypto space has started to grow over the past month. My philosophy about learning something quickly is to find a simple idea, a good source of information about the topic, and to just jump right in. As a primarily backend engineer in my day job, smart contracts and building up infrastructure in the crypto space has been my biggest interest. While researching my first steps into the world of Web3 development I stumbled upon Buildspace on [twitter](https://twitter.com/_buildspace).\\n\\n[Buildspace](https://buildspace.so/) is pretty cool, especially for those just starting out and looking to jump right in. They have 7 “projects,” which are different tutorials covering different aspects of Web3 development. They also have a really helpful and active community on discord! If you are looking to talk with other like minded individuals! I chose their *NFT browser game project*, due to it having a pretty decently sized Solidity component.\\n\\n# What I’ll Be Going Over\\n\\nI’ll be focusing on several parts of this project that I felt were pretty pivotal to starting in Web3 development. I’ll be sure to have headers for each part, so feel free to skip to whatever interests you the most!\\n\\n* A brief dive into NFTs (EIP-721)?\\n* Important technologies and services\\n* Building a blockchain driven web app\\n\\n# A Brief Dive Into NFTs (EIP-721)\\n\\nIn its most basic form, an NFT is a unique asset that cannot be replaced by another. The name “non-fungible” by definition means that these tokens cannot be replaced by another identical token, making them wholly unique. This is extremely useful when it comes to digital goods and assets, as they can be tied to ownership …. (finish this later when more focused)\\n\\n**TODO FINISH THIS SECTION**\\n\\n# Technologies and Services\\n\\nSeveral technologies went into the development of this project. I’m going to mainly be focusing on Web3 specific technologies. If you are interested in learning more about the details on what React is, you can find some great starter info on their [documentation site](https://reactjs.org/docs/getting-started.html).\\n\\n### Solidity (Smart Contracts)\\n\\nIf you are interested in smart contract development, I would have to say Solidity should be one of your top priorities to learn. Solidity is an object-oriented programming language, taking influences from the likes of C++ and JavaScript. Solidity is meant to target the Ethereum Virtual Machine (EVM), this topic is beyond the scope of this post, but the Ethereum Org wrote [amazing documentation](https://ethereum.org/en/developers/docs/evm/) going over the basics on how the EVM works.\\n\\n### Hardhat (Smart Contract Development Assist)\\n\\nHardhat is an amazing tool that helps with Ethereum smart contract development and testing. I wish I had found it sooner! The reason hardhat is so great, is its ability to allow you to deploy and run smart contracts locally on your own machine, in your own “private” block chain. This, plus the ability to print out console.log() statements from a contract in your terminal make it extremely easy to debug and test contracts on the fly.\\n\\nAlong with testing, hardhat also allows you to compile contracts and deploy them to the Ethereum networks (Rinkeby, Mainnet, etc). I will be going deeper into these parts later on.\\n\\n### Alchemy (DAPP Deployment and Blockchain Middleman)\\n\\nAlchemy works as a type of middleman between your dapp and the blockchain. They’re useful as you don’t have to worry about hosting your own node and all the responsibilities that come with that. It’s as easy as compiling your smart contract and deploying it to alchemy using hardhat. Although a small project like this does not use the service to its fullest potential, it is great for when you start deploying dapps many people will use! Alchemy also has a suite of detailed metrics showing data ranging from how many requests are being made to your app to the average response time, which could be useful when building and fine tuning a great product.\\n\\n# Building a Blockchain Driven Web App\\n\\n### The Login Flow\\n\\nIn all my time of working as a web developer, I’ve never seen a login flow as elegant and easy to set up as this. It’s amazing how having a universal source of truth such as the blockchain simplifies so many things. It also opens up a huge treasure trove of possibilities of creating customizable experiences tailored for each user that can be maintained across any platform that uses the blockchain for authentication. Imagine, being able to store configurations for each user on chain and then picking up that data elsewhere, bringing these specific experiences into a different platform.\\n\\nFor this project I simply added a login flow using the Metamask wallet, of course you can have your app support multiple wallets. With Metamask, it simply injects an `ethereum` object in window. This object can be used to validate if Metamask is installed (checking if the `ethereum` object exists at all), request user info, and sign messages/transactions (this happens whenever Metamask asks you to approve a transaction).\\n\\nOn the main site load, I use an `useEffect` to initialize the loading spinner and check if the user is logged in.\\n\\n```\\nuseEffect(() => {\\n   setIsLoading(true);\\n   checkIfWalletIsConnected();\\n }, []);\\n```\\n\\nThe check wallet function is quite simple. It checks if the `ethereum` object exists at all (checking if Metamask is installed), requests authorized accounts from Metamask, and sets the user if they’re currently logged in. Depending on if Metamask exists or if the user is logged in or not, these could be used to trigger more states on your app.\\n\\n```\\nconst checkIfWalletIsConnected = async () => {\\n   try {\\n     const { ethereum } = window;\\n \\n     if (!ethereum) {\\n       console.log('Make sure you have MetaMask!');\\n       setIsLoading(false);\\n       return;\\n     } else {\\n       console.log('We have the ethereum object', ethereum);\\n \\n       const accounts = await ethereum.request({ method: 'eth_accounts' });\\n \\n       if (accounts.length !== 0) {\\n         const account = accounts[0];\\n         console.log('Found an authorized account:', account);\\n         setCurrentAccount(account);\\n       } else {\\n         console.log('No authorized account found');\\n       }\\n     }\\n   } catch (error) {\\n     console.log(error);\\n   }\\n \\n   setIsLoading(false);\\n };\\n```\\n\\nWhen the user is not logged in, I decided to display a button on the site that can trigger a `connectWalletAction` triggering Metamask to ask for authentication from the user and fetch the user data.\\n\\n```\\n<button\\n  className=\\\"cta-button connect-wallet-button\\\"\\n  onClick={connectWalletAction}\\n >\\n   Connect Wallet To Get Started\\n </button>\\n```\\n\\nThe `connectWalletAction` method simply checks if `ethereum` object exists, and then makes a request to Metamask using `eth_requestAccounts`.\\n\\n```\\nconst connectWalletAction = async () => {\\n   try {\\n     const { ethereum } = window;\\n \\n     if (!ethereum) {\\n       alert('Get MetaMask!');\\n       return;\\n     }\\n \\n     const accounts = await ethereum.request({\\n       method: 'eth_requestAccounts',\\n     });\\n \\n     console.log('Connected', accounts[0]);\\n     setCurrentAccount(accounts[0]);\\n   } catch (error) {\\n     console.log(error);\\n   }\\n };\\n```\\n\\n### Fetching Data from the Blockchain\\n\\n**Solidity and Hardhat**\\n\\nIn the smart contract, each NFT character is built from a struct that lays out important information such as the monster’s ID, name, image URL, HP, etc; along with the type of data each variable is. Monsters held by a user that is interfacing with the smart contract and default monster’s a new user can choose to mint from are all composed from this struct. You can adapt this struct to meet whatever goal your NFT is trying to achieve.\\n\\n```\\nstruct CharacterAttributes {\\n   uint characterIndex;\\n   string name;\\n   string imageURI;       \\n   uint hp;\\n   uint maxHp;\\n   uint attackDamage;\\n }\\n```\\n\\nMonsters that have been minted and are owned by users are stored in two maps that are *global state variables* saved on the blockchain. The first mapping allows us to easily take a calling user’s public address and fetch the ID for the minted monster they own. The second mapping takes the monster’s ID and provides the monster object that contains the information referenced in the struct above.\\n\\n```\\nmapping(uint256 => CharacterAttributes) public nftHolderAttributes;\\nmapping(address => uint256) public nftHolders;\\n```\\n\\nFor the default characters that a new user can select from to mint, like the `nftHolderAttributes` and `nftHolders`, the list of select-able NFTs are saved on a global state variable on the smart contract also, but as a list of `CharacterAttributes`.\\n\\n```\\nCharacterAttributes[] defaultCharacters;\\n```\\n\\nThis list is populated when the contract is first deployed to the blockchain in the constructor. In Solidity, the constructor only runs the first time the contract is deployed, this is useful to set states or in this case populate a list of monsters users will be able to choose from. Also a side note, as you can see below the constructor has a syntax `ERC721(\\\"Heroes\\\", \\\"HERO\\\")`, this is from the `​​ERC721` interface the whole smart contract extends. This allows us to set the name of the token as well as its symbol, in this case Heroes token $HERO. One last note, you should pay attention to the last action in the constructor `_tokenIds.increment()`. This is the ID that is set to a monster when a user mints it, there is an important reason that we increment the id from 0 to 1 before any monster is minted, and that will become more clear later on in the next section.\\n\\n```\\nconstructor(\\n   string[] memory characterNames,\\n   string[] memory characterImageURIs,\\n   uint[] memory characterHp,\\n   uint[] memory characterAttackDmg,\\n   string memory bossName,\\n   string memory bossImageURI,\\n   uint bossHp,\\n   uint bossAttackDamage\\n )\\n   ERC721(\\\"Heroes\\\", \\\"HERO\\\")\\n {\\n   // Initialize the boss. Save it to our global \\\"bigBoss\\\" state variable.\\n   bigBoss = BigBoss({\\n     name: bossName,\\n     imageURI: bossImageURI,\\n     hp: bossHp,\\n     maxHp: bossHp,\\n     attackDamage: bossAttackDamage\\n   });\\n \\n   console.log(\\\"Done initializing boss %s w/ HP %s, img %s\\\", bigBoss.name, bigBoss.hp, bigBoss.imageURI);\\n \\n   for(uint i = 0; i < characterNames.length; i += 1) {\\n     defaultCharacters.push(CharacterAttributes({\\n       characterIndex: i,\\n       name: characterNames[i],\\n       imageURI: characterImageURIs[i],\\n       hp: characterHp[i],\\n       maxHp: characterHp[i],\\n       attackDamage: characterAttackDmg[i]\\n     }));\\n \\n     CharacterAttributes memory c = defaultCharacters[i];\\n    \\n     // Hardhat's use of console.log() allows up to 4 parameters in any order of following types: uint, string, bool, address\\n     console.log(\\\"Done initializing %s w/ HP %s, img %s\\\", c.name, c.hp, c.imageURI);\\n   }\\n \\n   // Token ID is incremented on first build since 0 can be treated is a default value in Solidity\\n   // This can cause issues deciphering the difference between a NONE value (0) or ID 0 of a character.\\n   _tokenIds.increment();\\n }\\n```\\n\\nFor the final touches, I needed to write some utility functions within the contract for applications to be able to easily fetch this data. The first is a utility function to fetch all default monsters for when a user needs to select their first monster to mint. This method is a simple `view` function that simply fetches and returns the `defaultCharacters` list from the contract. A view function is a function that is appended with the `view` symbol. This declares that the function is simply fetching data from the blockchain and not performing any actions or changing the data. It’s important to remember that view functions cost **NO** gas to run.\\n\\n```\\nfunction getAllDefaultCharacters() public view returns (CharacterAttributes[] memory) {\\n   return defaultCharacters;\\n}\\n```\\n\\nThe second utility function is to check if a user already has an NFT. Similar to `getAllDefaultCharacters`, this too is a view function. It uses the global variable `userNftTokenId` to see if the requesting user has a monster ID tied to their address and then returns the monster from `nftHolderAttributes` if it exists. Remember during the constructor section with the `_tokenId`. Solidity sets non-existing values to 0, if we had set a monster’s ID to 0 we would not have been able to decipher from a user not having an NFT with us or having the first monster ever minted.\\n\\n```\\nfunction checkIfUserHasNFT() public view returns (CharacterAttributes memory) {\\n   uint256 userNftTokenId = nftHolders[msg.sender];\\n \\n   if (userNftTokenId > 0) {\\n     return nftHolderAttributes[userNftTokenId];\\n   } else {\\n     CharacterAttributes memory emptyStruct;\\n     return emptyStruct;\\n   }\\n }\\n```\\n\\n**React**\\n\\nAfter a user logs in using Metamask, the `currentAccount` state is updated with the user data triggering another `useEffect` that is observing that state. The effect calls the contract using its utility function we wrote above to check if a user has a monster NFT.\\n\\n```\\nuseEffect(() => {\\n   const fetchNFTMetadata = async () => {\\n     console.log('Checking for Character NFT on address:', currentAccount);\\n      const provider = new ethers.providers.Web3Provider(window.ethereum);\\n     const signer = provider.getSigner();\\n     const gameContract = new ethers.Contract(\\n       CONTRACT_ADDRESS,\\n       myEpicGame.abi,\\n       signer\\n     );\\n      const characterNFT = await gameContract.checkIfUserHasNFT();\\n     if (characterNFT.name) {\\n       console.log('User has character NFT');\\n       setCharacterNFT(transformCharacterData(characterNFT));\\n     }\\n    \\n     setIsLoading(false);\\n   };\\n    if (currentAccount) {\\n     console.log('CurrentAccount:', currentAccount);\\n     fetchNFTMetadata();\\n   }\\n }, [currentAccount]);\\n```\\n\\nYou may be asking, how does our `gameContract` know what functions exits on the contract? Using `ethers` a helpful JavaScript dependency, we can build a contract object by passing in the `CONTRACT_ADDRESS`, `myEpicGame.json` (a JSON file of our smart contract’s variables and functions compiled by Hardhat), and a signer (the provider that requests a user to sign a blockchain request, in this instance Metamask).\\n\\nAfter this check, React uses the `characterNFT` state to decide if the minting component or battle component should be rendered.\\n\\n```\\n} else if (currentAccount && !characterNFT) {\\n  return <SelectCharacter setCharacterNFT={setCharacterNFT} />;\\n} else if (currentAccount && characterNFT) {\\n  return <Arena characterNFT={characterNFT} setCharacterNFT={setCharacterNFT} />;\\n}\\n```\\n\\nAfter the `gameContract` is initialized in the `SelectCharacter` component, an effect is triggered to fetch all default characters from the contract. Along with this we set up a listener that will receive events from the blockchain when a character is minted. When a character does get minted from the user it will trigger `onCharacterMint` triggering a state change to and React to render the `Arena` component. It’s important that when components are disposed of, the event listeners are closed (`gameContract.off('CharacterNFTMinted', onCharacterMint)`).\\n\\n```\\nuseEffect(() => {\\n   const getCharacters = async () => {\\n     try {\\n       console.log('Getting contract characters to mint');\\n        const charactersTxn = await gameContract.getAllDefaultCharacters();\\n       console.log('charactersTxn:', charactersTxn);\\n        const characters = charactersTxn.map((characterData) =>\\n         transformCharacterData(characterData)\\n       );\\n        setCharacters(characters);\\n     } catch (error) {\\n       console.error('Something went wrong fetching characters:', error);\\n     }\\n   };\\n \\n   const onCharacterMint = async (sender, tokenId, characterIndex) => {\\n     console.log(\\n       `CharacterNFTMinted - sender: ${sender} tokenId: ${tokenId.toNumber()} characterIndex: ${characterIndex.toNumber()}`\\n     );\\n \\n     if (gameContract) {\\n       const characterNFT = await gameContract.checkIfUserHasNFT();\\n       console.log('CharacterNFT: ', characterNFT);\\n       setCharacterNFT(transformCharacterData(characterNFT));\\n     }\\n   };\\n    if (gameContract) {\\n     getCharacters();\\n     gameContract.on('CharacterNFTMinted', onCharacterMint);\\n   }\\n    return () => {\\n     if (gameContract) {\\n       gameContract.off('CharacterNFTMinted', onCharacterMint);\\n     }\\n   };\\n }, [gameContract, setCharacterNFT]);\\n```\\n\\n### Minting to the Blockchain\\n\\n**Solidity**\\n\\nThe minting function is pretty simple. First it fetches the current ID that the new monster will be identified by. Then we use `_safeMint(address, to)`, a function from the `ERC721` interface that will mint the monster’s ID and send it to the given address; it's important that the ID given to mint is wholly unique and has never been used. After minting, the unique monster is generated with the default values from a monster from the `defaultCharacters` list and assigned to the user in the smart contract. Finally an event `CharacterNFTMinted` is broadcasted to let anyone listening know what has occurred. This is what the React event listener used above!\\n\\n```\\nfunction mintCharacterNFT(uint _characterIndex) external {\\n   uint256 newItemId = _tokenIds.current();\\n \\n   // The magical function! Assigns the tokenId to the caller's wallet address.\\n   _safeMint(msg.sender, newItemId);\\n \\n   nftHolderAttributes[newItemId] = CharacterAttributes({\\n     characterIndex: _characterIndex,\\n     name: defaultCharacters[_characterIndex].name,\\n     imageURI: defaultCharacters[_characterIndex].imageURI,\\n     hp: defaultCharacters[_characterIndex].hp,\\n     maxHp: defaultCharacters[_characterIndex].maxHp,\\n     attackDamage: defaultCharacters[_characterIndex].attackDamage\\n   });\\n \\n   console.log(\\\"Minted NFT w/ tokenId %s and characterIndex %s\\\", newItemId, _characterIndex);\\n  \\n   nftHolders[msg.sender] = newItemId;\\n \\n   _tokenIds.increment();\\n \\n   emit CharacterNFTMinted(msg.sender, newItemId, _characterIndex);\\n }\\n```\\n\\nThe `CharacterNFTMinted` was defined with the contract’s other global variables.\\n\\n```\\nevent CharacterNFTMinted(address sender, uint256 tokenId, uint256 characterIndex);\\n```\\n\\n**React**\\n\\nI tied a function to each button on the `SelectCharacter` component, each one with the ID that represents each default character. It simply uses the function above to initiate a minting transaction that the user signs and initiates.\\n\\n```\\nconst mintCharacterNFTAction = (characterId) => async () => {\\n   try {\\n     if (gameContract) {\\n       setMintingCharacter(true);\\n       console.log('Minting character in progress...');\\n       const mintTxn = await gameContract.mintCharacterNFT(characterId);\\n       await mintTxn.wait();\\n       console.log(mintTxn);\\n       setMintingCharacter(false);\\n     }\\n   } catch (error) {\\n     console.warn('MintCharacterAction Error:', error);\\n     setMintingCharacter(false);\\n   }\\n };\\n```\\n\\n### Building Basic Gameplay Mechanics\\n\\nOnce the user has minted a character, it is time to move them to the battle arena to fight the boss!\\n\\n**Solidity**\\n\\nOnly two functions are needed for this arena, as it is an extremely simple game. The first function is another view function that retrieves the boss from the contracts memory on the blockchain and returns it the requester.\\n\\n```\\nfunction getBigBoss() public view returns (BigBoss memory) {\\n   return bigBoss;\\n}\\n```\\n\\nThe second function is a bit more complicated, but not too bad. After fetching the user’s monster, there is a new syntax we haven’t seen yet called `require` that checks if the transaction is valid. You may be asking, why not just use a conditional `if`? `Requires` are useful because if the requirements are not meant, it will roll the whole transaction back, making it as if nothing ever happened and reverting all changes that may have occurred beforehand. *The only thing a user doesn’t get back is the gas fees spent on miners in the process*. If all requirements are met, the user will attack the boss reducing their HP and the boss will do the same. After all is said and done, an event is broadcasted to clients that an attack has occurred, similar to the `CharacterNFTMinted` event.\\n\\n```\\nfunction attackBoss() public {\\n   uint256 nftTokenIdOfPlayer = nftHolders[msg.sender];\\n   CharacterAttributes storage player = nftHolderAttributes[nftTokenIdOfPlayer];\\n  \\n   console.log(\\\"\\\\nPlayer w/ character %s about to attack. Has %s HP and %s AD\\\", player.name, player.hp, player.attackDamage);\\n   console.log(\\\"Boss %s has %s HP and %s AD\\\", bigBoss.name, bigBoss.hp, bigBoss.attackDamage);\\n \\n   require (\\n     player.hp > 0,\\n     \\\"Error: character must have HP to attack boss.\\\"\\n   );\\n \\n   require (\\n     bigBoss.hp > 0,\\n     \\\"Error: boss must have HP to attack boss.\\\"\\n   );\\n \\n   if (bigBoss.hp < player.attackDamage) {\\n     bigBoss.hp = 0;\\n   } else {\\n     bigBoss.hp = bigBoss.hp - player.attackDamage;\\n   }\\n \\n   if (player.hp < bigBoss.attackDamage) {\\n     player.hp = 0;\\n   } else {\\n     player.hp = player.hp - bigBoss.attackDamage;\\n   }\\n  \\n   console.log(\\\"Player attacked boss. New boss hp: %s\\\", bigBoss.hp);\\n   console.log(\\\"Boss attacked player. New player hp: %s\\\\n\\\", player.hp);\\n \\n   emit AttackComplete(bigBoss.hp, player.hp);\\n }\\n```\\n\\n**React**\\n\\nIn the `Arena` component, we populate the render with the `boss` fetched from the contract state and `characterNFT` to display the health of both characters. We also setup the event listener and its respective function for later on when an attack is initiated and completed.\\n\\n```\\nuseEffect(() => {\\n   const fetchBoss = async () => {\\n       const bossTxn = await gameContract.getBigBoss();\\n       console.log('Boss:', bossTxn);\\n       setBoss(transformCharacterData(bossTxn));\\n   };\\n \\n   /*\\n   * Setup logic when this event is fired off\\n   */\\n   const onAttackComplete = (newBossHp, newPlayerHp) => {\\n       const bossHp = newBossHp.toNumber();\\n       const playerHp = newPlayerHp.toNumber();\\n \\n       console.log(`AttackComplete: Boss Hp: ${bossHp} Player Hp: ${playerHp}`);\\n \\n       /*\\n       * Update both player and boss Hp\\n       */\\n       setBoss((prevState) => {\\n           return { ...prevState, hp: bossHp };\\n       });\\n \\n       setCharacterNFT((prevState) => {\\n           return { ...prevState, hp: playerHp };\\n       });\\n   };\\n \\n   if (gameContract) {\\n       fetchBoss();\\n       gameContract.on('AttackComplete', onAttackComplete);\\n   }\\n \\n   /*\\n   * Make sure to clean up this event when this component is removed\\n   */\\n   return () => {\\n       if (gameContract) {\\n           gameContract.off('AttackComplete', onAttackComplete);\\n       }\\n   }\\n }, [gameContract, setCharacterNFT]);\\n```\\n\\nFinally the grand finale! The boss function that will be tied to the attack button. Like all the other functions seen before, this will simply use the smart contracts `attackBoss` function and then pop up a toast when the attack transaction is all said and done.\\n\\n```\\nconst runAttackAction = async () => {\\n   try {\\n     if (gameContract) {\\n       setAttackState('attacking');\\n       console.log('Attacking boss...');\\n       const txn = await gameContract.attackBoss();\\n       await txn.wait();\\n       console.log(txn);\\n       setAttackState('hit');\\n            \\n       setShowToast(true);\\n       setTimeout(() => {\\n         setShowToast(false);\\n       }, 5000);\\n     }\\n   } catch (error) {\\n     console.error('Error attacking boss:', error);\\n     setAttackState('');\\n   }\\n };\\n```\\n\\n## Conclusion\\n\\nIn conclusion, would I say this Buildspace tutorial was useful? Most definitely! I do feel that at times it was a bit easy, being given code snippets without having to put a single thought into it. But the great thing about this blog post is that it forced me to digest what happened a little bit more and hopefully it will help you a bit also.\\n\\n### Thoughts on Web3, Will I Continue, What’s Next?\\n\\nI am extremely bullish and excited for what Web3 has to offer, although I am quite disappointed that I did not realize the potential sooner. I might work on another Buildspace project, but my excitement is building quickly, so I will probably start to forge my own path very soon.\\n\\nI am looking for other programmers to work along with or budding communities or DOAs that are looking for engineers. I plan to keep working on small projects that will enhance the Web3 experience and update that progress here. I also have a large project in the works, but I will reveal more about that as time goes on!\\n\\n## Useful Content\\n\\n* [Buildspace.so](https://buildspace.so/)\\n* This projects code can be found in this: [GitHub Repo](https://github.com/brandonfeist/buildspace-nft-game)\\n* My NFT Game hosted on Heroku, it should be noted that it is hosted on a free Heroku service and the images on a free CDN so loading can be pretty slow at first. If you want to use the app, please set your Metamask wallet to the **Rinkeby Network**: [NFT Game](https://buildspace-nft-game-skylark.herokuapp.com/)\\n* If you this content was useful and you want to stay up to date, be sure to follow me on twitter at: [@heyskylark](https://twitter.com/heyskylark)\",\"timestamp\":1639782969,\"title\":\"My First Project: A Buildspace NFT Game\"},\"digest\":\"1pb-Zjg2fIijBFLLb6L5k_u-wUYxFsYyAv9mYLQvdks\",\"authorship\":{\"contributor\":\"0xbf871a24CD733F840A091a03ECa6a514157C4cDC\",\"signingKey\":\"{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"5NHzHDh-rPTJ7-NNE_byo2RBk7Rlv7Cioi6Zs1QuXBc\\\",\\\"y\\\":\\\"pgaEmelZluHyt4psXZO6eCqDsyec5s7uZBLRG_XcSNg\\\"}\",\"signature\":\"F1Fk5z9vE4q9Q7HKZLNGY1X2SswdIjOpL-i-xLH6XJaAIQ4uiAPElNsUnUxpaGuqyPaB2AKWPU5eMYPRGqEA-A\",\"signingKeySignature\":\"0x0f61370cf938191cde8bebfd6870f19a722f3bf533092eae2cbf3292d67a38cc0691eb232be32da63d88eaa09747ee5e2c1c469059edd87fb6396eab1329c3df1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"5NHzHDh-rPTJ7-NNE_byo2RBk7Rlv7Cioi6Zs1QuXBc\\\",\\\"y\\\":\\\"pgaEmelZluHyt4psXZO6eCqDsyec5s7uZBLRG_XcSNg\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"Dg5f0NuZa-UBjQcqPw7rFeGUOKxJ8Gfssjtyb0V8P5U\"}"