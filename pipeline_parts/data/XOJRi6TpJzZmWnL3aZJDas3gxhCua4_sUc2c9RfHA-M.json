"{\"content\":{\"body\":\"Solidity test\\n\\n```sol\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n// OpenZeppelin library for performing math operations without overflows.\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n// OpenZeppelin security library for preventing reentrancy attacks.\\nimport {\\n    ReentrancyGuard\\n} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n// For interacting with Zora's Market contract.\\nimport {IMarket} from \\\"./interfaces/IMarket.sol\\\";\\n// For checking `supportsInterface`.\\nimport {IERC165} from \\\"@openzeppelin/contracts/introspection/IERC165.sol\\\";\\n// For interacting with NFT tokens.\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ncontract IMediaModified {\\n    mapping(uint256 => address) public tokenCreators;\\n    address public marketContract;\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ncontract ReserveAuctionV2 is ReentrancyGuard {\\n    // Use OpenZeppelin's SafeMath library to prevent overflows.\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    // The minimum amount of time left in an auction after a new bid is created; 15 min.\\n    uint16 public constant TIME_BUFFER = 900;\\n    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\\n    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\\n    // Interface constant for ERC721, to check values in constructor.\\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n    // Allows external read `getVersion()` to return a version for the auction.\\n    uint256 private constant RESERVE_AUCTION_VERSION = 1;\\n\\n    // ============ Immutable Storage ============\\n\\n    // The address of the ERC721 contract for tokens auctioned via this contract.\\n    address public immutable nftContract;\\n    // The address of the WETH contract, so that ETH can be transferred via\\n    // WETH if native ETH transfers fail.\\n    address public immutable wethAddress;\\n    // The address that initially is able to recover assets.\\n    address public immutable adminRecoveryAddress;\\n\\n    // ============ Mutable Storage ============\\n\\n    /**\\n     * To start, there will be an admin account that can recover funds\\n     * if anything goes wrong. Later, this public flag will be irrevocably\\n     * set to false, removing any admin privileges forever.\\n     *\\n     * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\\n     */\\n    bool private _adminRecoveryEnabled;\\n    /**\\n     * The account `adminRecoveryAddress` can also pause the contracts\\n     * while _adminRecoveryEnabled is enabled. This prevents people from using\\n     * the contract if there is a known problem with it.\\n     */\\n    bool private _paused;\\n\\n    // A mapping of all of the auctions currently running.\\n    mapping(uint256 => Auction) public auctions;\\n\\n    // ============ Structs ============\\n\\n    struct Auction {\\n        // The value of the current highest bid.\\n        uint256 amount;\\n        // The amount of time that the auction should run for,\\n        // after the first bid was made.\\n        uint256 duration;\\n        // The time of the first bid.\\n        uint256 firstBidTime;\\n        // The minimum price of the first bid.\\n        uint256 reservePrice;\\n        uint8 curatorFeePercent;\\n        // The address of the auction's curator. The curator\\n        // can cancel the auction if it hasn't had a bid yet.\\n        address curator;\\n        // The address of the current highest bid.\\n        address payable bidder;\\n        // The address that should receive funds once the NFT is sold.\\n        address payable fundsRecipient;\\n    }\\n\\n    // ============ Events ============\\n\\n    event AuctionCreated(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address fundsRecipient\\n    );\\n\\n    event AuctionBid(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address sender,\\n        uint256 value\\n    );\\n\\n    event AuctionCanceled(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator\\n    );\\n\\n    event AuctionEnded(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator,\\n        address winner,\\n        uint256 amount,\\n        address nftCreator,\\n        address payable fundsRecipient\\n    );\\n\\n    event CuratorFeePercentTransfer(\\n        uint256 indexed tokenId,\\n        address curator,\\n        uint256 amount\\n    );\\n\\n    // Emitted in the case that the contract is paused.\\n    event Paused(address account);\\n    // Emitted when the contract is unpaused.\\n    event Unpaused(address account);\\n\\n    // ============ Modifiers ============\\n\\n    // Reverts if the sender is not admin, or admin\\n    // functionality has been turned off.\\n    modifier onlyAdminRecovery() {\\n        require(\\n            // The sender must be the admin address, and\\n            // adminRecovery must be set to true.\\n            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\\n            \\\"Caller does not have admin privileges\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the sender is not the auction's curator.\\n    modifier onlyCurator(uint256 tokenId) {\\n        require(\\n            auctions[tokenId].curator == msg.sender,\\n            \\\"Can only be called by auction curator\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the contract is paused.\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction does not exist.\\n    modifier auctionExists(uint256 tokenId) {\\n        // The auction exists if the curator is not null.\\n        require(!auctionCuratorIsNull(tokenId), \\\"Auction doesn't exist\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction exists.\\n    modifier auctionNonExistant(uint256 tokenId) {\\n        // The auction does not exist if the curator is null.\\n        require(auctionCuratorIsNull(tokenId), \\\"Auction already exists\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction is expired.\\n    modifier auctionNotExpired(uint256 tokenId) {\\n        require(\\n            // Auction is not expired if there's never been a bid, or if the\\n            // current time is less than the time at which the auction ends.\\n            auctions[tokenId].firstBidTime == 0 ||\\n                block.timestamp < auctionEnds(tokenId),\\n            \\\"Auction expired\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the auction is not complete.\\n    // Auction is complete if there was a bid, and the time has run out.\\n    modifier auctionComplete(uint256 tokenId) {\\n        require(\\n            // Auction is complete if there has been a bid, and the current time\\n            // is greater than the auction's end time.\\n            auctions[tokenId].firstBidTime > 0 &&\\n                block.timestamp >= auctionEnds(tokenId),\\n            \\\"Auction hasn't completed\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(\\n        address nftContract_,\\n        address wethAddress_,\\n        address adminRecoveryAddress_\\n    ) public {\\n        require(\\n            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\\n            \\\"Contract at nftContract_ address does not support NFT interface\\\"\\n        );\\n        // Initialize immutable memory.\\n        nftContract = nftContract_;\\n        wethAddress = wethAddress_;\\n        adminRecoveryAddress = adminRecoveryAddress_;\\n        // Initialize mutable memory.\\n        _paused = false;\\n        _adminRecoveryEnabled = true;\\n    }\\n\\n    // ============ Create Auction ============\\n\\n    function createAuction(\\n        uint256 tokenId,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address payable fundsRecipient\\n    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\\n        // Check basic input requirements are reasonable.\\n        require(curator != address(0));\\n        require(fundsRecipient != address(0));\\n        // Initialize the auction details, including null values.\\n        auctions[tokenId] = Auction({\\n            duration: duration,\\n            reservePrice: reservePrice,\\n            curatorFeePercent: curatorFeePercent,\\n            curator: curator,\\n            fundsRecipient: fundsRecipient,\\n            amount: 0,\\n            firstBidTime: 0,\\n            bidder: address(0)\\n        });\\n        // Transfer the NFT into this auction contract, from whoever owns it.\\n        IERC721(nftContract).transferFrom(\\n            IERC721(nftContract).ownerOf(tokenId),\\n            address(this),\\n            tokenId\\n        );\\n        // Emit an event describing the new auction.\\n        emit AuctionCreated(\\n            tokenId,\\n            nftContract,\\n            duration,\\n            reservePrice,\\n            curatorFeePercent,\\n            curator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    // ============ Create Bid ============\\n\\n    function createBid(uint256 tokenId, uint256 amount)\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        auctionExists(tokenId)\\n        auctionNotExpired(tokenId)\\n    {\\n        // Check basic input requirements.\\n        require(amount == msg.value, \\\"Amount doesn't equal msg.value\\\");\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        // Check if the current bid amount is 0.\\n        if (auctions[tokenId].amount == 0) {\\n            // If so, it is the first bid.\\n            auctions[tokenId].firstBidTime = block.timestamp;\\n            // We only need to check if the bid matches reserve bid for the first bid,\\n            // since future checks will need to be higher than any previous bid.\\n            require(\\n                amount >= auctions[tokenId].reservePrice,\\n                \\\"Must bid reservePrice or more\\\"\\n            );\\n        } else {\\n            // Check that the new bid is sufficiently higher than the previous bid, by\\n            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\\n            require(\\n                amount >=\\n                    auctions[tokenId].amount.add(\\n                        // Add 10% of the current bid to the current bid.\\n                        auctions[tokenId]\\n                            .amount\\n                            .mul(MIN_BID_INCREMENT_PERCENT)\\n                            .div(100)\\n                    ),\\n                \\\"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\\\"\\n            );\\n\\n            // Refund the previous bidder.\\n            transferETHOrWETH(\\n                auctions[tokenId].bidder,\\n                auctions[tokenId].amount\\n            );\\n        }\\n        // Confirm that this is a valid bid, according to Zora market.\\n        require(\\n            IMarket(IMediaModified(nftContract).marketContract()).isValidBid(\\n                tokenId,\\n                amount\\n            ),\\n            \\\"Bid would cause invalid split from Zora market\\\"\\n        );\\n        // Update the current auction.\\n        auctions[tokenId].amount = amount;\\n        auctions[tokenId].bidder = msg.sender;\\n        // Compare the auction's end time with the current time plus the 15 minute extension,\\n        // to see whether we're near the auctions end and should extend the auction.\\n        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\\n            // We add onto the duration whenever time increment is required, so\\n            // that the auctionEnds at the current time plus the buffer.\\n            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\\n                auctionEnds(tokenId)\\n            );\\n        }\\n        // Emit the event that a bid has been made.\\n        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\\n    }\\n\\n    // ============ End Auction ============\\n\\n    function endAuction(uint256 tokenId)\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        auctionComplete(tokenId)\\n    {\\n        // Record relevant data from the auction.\\n        address winner = auctions[tokenId].bidder;\\n        uint256 amount = auctions[tokenId].amount;\\n        address curator = auctions[tokenId].curator;\\n        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\\n        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\\n        // Remove all auction data for this token.\\n        delete auctions[tokenId];\\n        // We don't use safeTransferFrom, to prevent reverts at this point,\\n        // which would break the auction.\\n        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\\n        // First handle the curator's fee.\\n        if (curatorFeePercent > 0) {\\n            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\\n            transferETHOrWETH(curator, curatorAmount);\\n            amount = amount.sub(curatorAmount);\\n            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\\n        }\\n        // Get the address of the original creator, so that we can split shares\\n        // if appropriate.\\n        address payable nftCreator =\\n            payable(\\n                address(IMediaModified(nftContract).tokenCreators(tokenId))\\n            );\\n        // If the creator and the recipient of the funds are the same,\\n        // and this should be common, we just do one transaction.\\n        if (nftCreator == fundsRecipient) {\\n            transferETHOrWETH(nftCreator, amount);\\n        } else {\\n            // Collect share data from Zora.\\n            IMarket.BidShares memory bidShares =\\n                IMarket(IMediaModified(nftContract).marketContract())\\n                    .bidSharesForToken(tokenId);\\n            uint256 creatorAmount =\\n                IMarket(IMediaModified(nftContract).marketContract())\\n                    .splitShare(bidShares.creator, amount);\\n            // Send the creator's share to the creator.\\n            transferETHOrWETH(nftCreator, creatorAmount);\\n            // Send the remainder of the amount to the funds recipient.\\n            transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount));\\n        }\\n        // Emit an event describing the end of the auction.\\n        emit AuctionEnded(\\n            tokenId,\\n            nftContract,\\n            curator,\\n            winner,\\n            amount,\\n            nftCreator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    // ============ Cancel Auction ============\\n\\n    function cancelAuction(uint256 tokenId)\\n        external\\n        nonReentrant\\n        auctionExists(tokenId)\\n        onlyCurator(tokenId)\\n    {\\n        // Check that there hasn't already been a bid for this NFT.\\n        require(\\n            uint256(auctions[tokenId].firstBidTime) == 0,\\n            \\\"Auction already started\\\"\\n        );\\n        // Pull the creator address before removing the auction.\\n        address curator = auctions[tokenId].curator;\\n        // Remove all data about the auction.\\n        delete auctions[tokenId];\\n        // Transfer the NFT back to the curator.\\n        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\\n        // Emit an event describing that the auction has been canceled.\\n        emit AuctionCanceled(tokenId, nftContract, curator);\\n    }\\n\\n    // ============ Admin Functions ============\\n\\n    // Irrevocably turns off admin recovery.\\n    function turnOffAdminRecovery() external onlyAdminRecovery {\\n        _adminRecoveryEnabled = false;\\n    }\\n\\n    function pauseContract() external onlyAdminRecovery {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function unpauseContract() external onlyAdminRecovery {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    // Allows the admin to transfer any NFT from this contract\\n    // to the recovery address.\\n    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\\n        IERC721(nftContract).transferFrom(\\n            // From the auction contract.\\n            address(this),\\n            // To the recovery account.\\n            adminRecoveryAddress,\\n            // For the specified token.\\n            tokenId\\n        );\\n    }\\n\\n    // Allows the admin to transfer any ETH from this contract to the recovery address.\\n    function recoverETH(uint256 amount)\\n        external\\n        onlyAdminRecovery\\n        returns (bool success)\\n    {\\n        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\\n        success = attemptETHTransfer(adminRecoveryAddress, amount);\\n    }\\n\\n    // ============ Miscellaneous Public and External ============\\n\\n    // Returns true if the contract is paused.\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    // Returns true if admin recovery is enabled.\\n    function adminRecoveryEnabled() public view returns (bool) {\\n        return _adminRecoveryEnabled;\\n    }\\n\\n    // Returns the version of the deployed contract.\\n    function getVersion() external pure returns (uint256 version) {\\n        version = RESERVE_AUCTION_VERSION;\\n    }\\n\\n    // ============ Private Functions ============\\n\\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\\n    function transferETHOrWETH(address to, uint256 value) private {\\n        // Try to transfer ETH to the given recipient.\\n        if (!attemptETHTransfer(to, value)) {\\n            // If the transfer fails, wrap and send as WETH, so that\\n            // the auction is not impeded and the recipient still\\n            // can claim ETH via the WETH contract (similar to escrow).\\n            IWETH(wethAddress).deposit{value: value}();\\n            IWETH(wethAddress).transfer(to, value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\\n    // it fails. For example, a contract can block ETH transfer, or might use\\n    // an excessive amount of gas, thereby griefing a new bidder.\\n    // We should limit the gas used in transfers, and handle failure cases.\\n    function attemptETHTransfer(address to, uint256 value)\\n        private\\n        returns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = to.call{value: value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n\\n    // Returns true if the auction's curator is set to the null address.\\n    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\\n        // The auction does not exist if the curator is the null address,\\n        // since the NFT would not have been transferred in `createAuction`.\\n        return auctions[tokenId].curator == address(0);\\n    }\\n\\n    // Returns the timestamp at which an auction will finish.\\n    function auctionEnds(uint256 tokenId) private view returns (uint256) {\\n        // Derived by adding the auction's duration to the time of the first bid.\\n        // NOTE: duration can be extended conditionally after each new bid is added.\\n        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\\n    }\\n}\\n```\",\"timestamp\":1617910972,\"title\":\"Formatting Design\",\"publication\":\"jktest\"},\"digest\":\"Ds-IaBRGVKf07KWxQv7a-ooT1JhuLLx4megjJPxpZBA\",\"authorship\":{\"contributor\":\"0x841fF85B6873d7bfB712C8f7A347C774355b6EC3\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"ziXwJy5ZXzLqiWlG-l6G2pZKDpoW132iWIuwJRCGQbg\\\",\\\"y\\\":\\\"AS8e_Mn_DzNPVTDGi6gLsUuZGD8y58kbxQvyjox_Fjw\\\"}\",\"signature\":\"K7VJDYowEkPvJ6VigkAla5w6L562cfWnbQYcVumqrhxoWSDpql4eJNsgRtmmGQekQQsj0stWnnZTVLPAyvbNQg\",\"signingKeySignature\":\"0x253fd236dcd4cc41b6142719f71245d795402842e42231edd5ecf1292f0d7dbe7cae14ff5767adca551efd41269a051a5ccd56c1098b8e7a834cc642551327c61b\",\"signingKeyMessage\":\"I authorize the publication of articles on jktest2.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"ziXwJy5ZXzLqiWlG-l6G2pZKDpoW132iWIuwJRCGQbg\\\",\\\"y\\\":\\\"AS8e_Mn_DzNPVTDGi6gLsUuZGD8y58kbxQvyjox_Fjw\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"B32AHYVIlCf20jjOc7ebm3dv1W7KIBjdw9JB93z3gKY\"}"