"{\"content\":{\"body\":\"## 导读\\n\\nif(DAO) 试图用非技术语言和少量数学及密码学知识，向一般读者解释：\\n\\n（1）zk-SNARK 是什么。\\n\\n（2）zk-SNARK 有什么用。\\n\\n（3）通过 zk-SNARK 的协议一步步进化过程弄清零知识的底层原理。\\n\\n（4）通过 Proving Key 、Verifying Key 是什么；Proof 包含的内容有哪些；为什么通过 Proving Key 可以得到 Proof ；为什么通过 Verifying Key 可以验证 Proof 等问题，理解 zk-SNARK 是如何具体落地应用的 。\\n\\n关于zk-SNARK的学术论文包含严谨的数学公式和论证过程；关于zk-SNARK的应用程序代码也有一些成熟的 lib 可供使用。但这些应该是数学家、密码学家和程序员感兴趣的内容，而不是一般读者。所以本文更侧重于如何将zk-SNARK的理论和实践 “联系” 起来。\\n\\n文中如有错误之处还请指正。下面进入正文：\\n\\n## 故事背景\\n\\n1、什么是零知识证明\\n\\n零知识可以简单理解为：我有一个秘密，在不向我朋友阿文透露秘密的情况下，让阿文相信我知道这个秘密。我们将证明的过程/方法称做 “ 零知识证明 ”。\\n\\n2、零知识证明和 zk-SNARK\\n\\n零知识证明包含很多种证明方法，其中的一个证明方法叫做：zk-SNARK （除此之外还有 zk-STARK、BulletProof、zkCNN 等等）。\\n\\n3、zk-SNARK\\n\\nzk-SNARK = zero knowledge Succinct Non-interactive ARgument of Knowledge（非交互式简洁零知识论证）\\n\\n（1）zero knowledge：零知识，即在证明的过程中不透露任何内情。\\n\\n（2）Succinct：简洁的，主要是指验证过程不涉及大量数据传输以及验证算法简单。\\n\\n（3）Non-interactive：无交互，即 Prover 和 Verifier 之间不需要进行交互即可验证命题的真伪。\\n\\n（4）ARgument of Knowledge：知识论证，证明是严谨的，而论证是基于概率的，因而使用论证二字。\\n\\n4、zk-SNARK中的几个基础概念\\n\\n（1）零知识 = 我的秘密。\\n\\n（2）Prover = 证明者，即上面例子中的“我”。\\n\\n（3）Verifier = 验证者，即上面例子中的“阿文”。\\n\\n（4）Proof = 我拿着这个证明（Proof）给阿文，阿文就可以验证我是否知道秘密。\\n\\n（5）Proving Key = 我通过 Proving Key 才能生成 Proof。\\n\\n（6）Verifying Key = 阿文通过 Verifying Key 可以验证我的 Proof 是否为真。\\n\\n5、zk-SNARK 有什么用\\n\\nzk-SNARK 目前在诸多应用场景上均有实现，在此我举2个例子抛砖引玉：\\n\\n* 数据隐私\\n\\n我们正处在从 Web2.0 迈向 Web3.0 的时代，未来人们会对隐私有着更高的要求。\\n\\n在 Web2.0 时代，如果我想向银行贷款，我需要出具各种资产证明（抵质押）或交易流水信息（信用），这些信息本来是属于我的个人数据资产，但却必须要赤裸裸的暴露在银行的审核部门之下。\\n\\n在 Web3.0 时代，如果我想向银行贷款，zk-SNARK 可以提供更好的隐私解决方案：\\n\\n零知识是我的资产情况，它可以转化为满足m个约束条件的n个多项式。\\n\\n我在不暴露多项式的情况下，通过 Proving Key 生成一个 Proof ，该 Proof 向银行证明我具有贷款资质，而不用暴露我的实际资产信息；银行可以通过 Verifying Key 验证我的资产情况是否满足贷款资质，而无需知道我的实际资产情况。\\n\\n* 数据计算和存储\\n\\n绝大部分区块链网络共识的时候，所有节点做同样的计算才能达成共识，通过 zk-SNARK 可以改进为只需一方计算，其它节点进行简单验证即可，节省了大量的计算资源。\\n\\n以 [Mina Protocol](https://minaprotocol.com/) 为例：Mina 网络将 Merkle Path（当前全网账户状态）转换为n个多项式，从而生成（递归的）zk-SNARK 证明，网络上的其他节点验证证明即可认为当前状态是正确的。当前全局账户状态中又包含上一个区块的账户状态（递归），当前正确，上一个就正确。往前以此类推。\\n\\n对于 Mina 而言，一个递归生成的zk-SNARK证明只有 1kB 左右，即便加上当前区块的 Merkle Path（20kB），无论链体再长，其大小也不会超过 22 kB。这与其他区块链动辄几百G的体积相比几乎可以忽略不计。\\n\\n## 协议背景\\n\\n协议中的零知识（即不能让他人知道的知识）：多项式 P(x) = x^3−3x^2+2x。\\n\\n协议中有2个角色：证明者和验证者。证明者自称知道 P(x)，验证者不知道 P(x)。\\n\\n证明的方式：证明者通过 Proving Key 生成 Proof 并发送给验证者，验证者通过 Verifying Key 验证 Proof 的正确性。整个过程中，验证者在不知道 P(x)的情况下验证了证明者是否知道 P(x)。\\n\\n## 协议一（ zk-SNARK 最原始版本 ）\\n\\n1、证明者\\n\\n首先将 P(x) = x^3−3x^2+2x 因式分解为 P(x) =(x−0)(x−1)(x−2)。\\n\\n2、证明者\\n\\n随机选择因式中的一部分 t(x) = (x−1)(x−2)，并 Public 出去。\\n\\n3、证明者\\n\\n证明者根据 P(x) = t(x) \\\\* h(x) 计算出 h(x) = P(x) /t(x) = (x-0) = x。\\n\\n注：在最终版 zk-SNARK 中对上面3步进行了较大改变，为了看起来和最终版本相对应，所以在此将证明者的动作拆分为1、2、3步。\\n\\n4、验证者\\n\\n随机取值 s，然后代入多项式计算 t(s) ，并将 s 发送给证明者。\\n\\n5、证明者\\n\\n根据验证者发来的 s ，计算P(s) 和 h(s)，并将计算结果发送给验证者。\\n\\n6、验证者\\n\\n使用第4步计算出的 t(s) 和第5步证明者发来的 P(s) 和 h(s)，验证 t(s) = P(s) / h(s) 是否成立。\\n\\n在这个最原始版本的协议中，我们回顾一下是如何实现证明的：证明者想向验证者证明他知道多项式 P(x)，但又不想暴露知识 P(x)。于是证明者通过 Proving Key = s 计算得到 Proof = P(s) 和 h(s)， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性。验证的整个过程中，验证者并不知道 P(x) 是什么，却通过 Verifying Key 验证出证明者“可能”知道 P(x)。当验证者随机取值 s0 …… s1 足够多的时候，验证者就可以大概率确认证明者知道 P(x)。\\n\\nProving Key 是什么？Verifying Key 是什么？Proof 包含的内容有哪些？为什么通过 Proving Key 可以得到 Proof ？为什么通过 Verifying Key 可以验证 Proof ？读到这里， if(DAO) 相信各位老板已经对传说中的 zk-SNARK 有一点感觉了。\\n\\n## 协议二（ 解决证明者用构造方式作弊的问题 ）\\n\\n在协议一的证明者第5步有一个明显的问题：验证者把 s 直接发给了证明者，证明者可以通过 s 计算出 t(s)的结果，比如 t(s)=5。进而证明者可以随意构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4，将结果发送给验证者进行作弊。\\n\\n为了解决这个问题，在协议二版本的 zk-SNARK 中，验证者不能把s直接发送给证明者，而是把经过隐藏之后的 s 发送给证明者。\\n\\n那么如何隐藏 s 呢，这需要用到一些密码学知识：同态加密。\\n\\n同态加密的具体做法是：验证者生成一个只有他自己知道的G，并将随机数 s 构造成 E(s) = G^s (mod N)的形式，以达到隐藏s的目的。即验证者不希望证明者通过 s 计算P(s)和 h(s)，而是让证明者通过 E(s) 计算 E(P(s)) 和 E(h(s)) 。这里有点绕，下面会解释具体的计算过程。\\n\\n1、2、3、证明者\\n\\n同上。\\n\\n4、验证者\\n\\n随机产生 s（不能直接发送给证明者），然后构造\\n\\nE(s^3) = (G^(s^3))\\n\\nE(s^2) = (G^(s^2))\\n\\nE(s) = (G^s)\\n\\n目的（1）：隐藏s，不让证明者通过s计算t(s)，所以就不能构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4。\\n\\n目的（2）：隐藏了多项式的系数，因为知道了多项式的系数就等于知道了多项式，从而泄露了知识。\\n\\n最后将构造的 E(s^3)、E(s^2) 、E(s) 发给证明者。\\n\\n5、证明者\\n\\n通过E(s^3) 、E(s^2) 、E(s)计算E(P(s)) ，计算过程如下：\\n\\nE(P(s)) = G ^ P(s) = G ^ (s^3−3s^2+2s) = G ^ ( P(s) ) = 图1最右侧\\n\\n![图1](https://images.mirror-media.xyz/publication-images/t0olzObG_C3qxM4N8yMi2.png?height=110&width=1476)\\n\\n证明者把验证者发过来的 E(s^3) 、E(s^2) 、E(s) 代入最左边的方程即可求解出E(P(s)) 。同样的方法计算E(h(s))。\\n\\n最后把 E(P(s)) 和 E(h(s)) 发送给验证者。\\n\\n6、验证者\\n\\n最后验证：E(P(s)) 是否= E(h(s)) ^ t(s)\\n\\n这是因为协议一中验证者验证 “ P(s)是否 = h(s) \\\\* t(s) ”  等价于 “ G ^ P(s) 是否 = (G ^ h(s)) ^ t(s) ”，即E(P(s)) 是否= E(h(s)) ^ t(s) 。\\n\\n在这个改进版的协议二，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 计算得到 Proof = \\\\[ E(P(s)) 、E(h(s)) \\\\] ， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n## 协议三（ 用 KEA 解决证明者必须用验证者发来的参数计算 E(P(x)) 的问题 ）\\n\\n在协议二的证明者第6步存在一个证明者的问题：\\n\\n验证者要验证的G ^ P(s) = (G ^ h(s)) ^ t(s) 等价于 G ^ P(S) = (G ^ t(s)) ^ h(s)，证明者可以通过 E(s^3) = (G^(s^3))、E(s^2) = (G^(s^2))、E(s) =(G^s) 计算出来G^t(s) = E(t(s))。\\n\\n这是因为t(s)是公开的，E(t(s)) = 图1最左侧 = 图1最右侧，而E(s^3)、E(s^2) 、E(s)证明者又是知道的。这时证明者可以根据E(t(s))，指定一个h(s)，并构造E(P(s)) ，从而满足E(P(s)) = E(t(s)) ^ h(s) 。\\n\\n所以产生了问题：证明者给验证者的 E(P(x)) 不是用验证者提供的题干： (G^(s^3))， (G^(s^2))，(G^s)计算出来的，即证明者不知道 P(x) 却通过 h(s) 构造了一个满足 E(P(s)) = E(t(s)) ^ h(s)约束的假 E(P(s))，从而骗过了验证者。\\n\\n解决思路：验证者再发送一个新的参数，该参数验证 E(P(x)) 必须用 (G^(s^3))， (G^(s^2))，(G^s) 计算出来。这个方法叫 KEA：Knowledge-of-Exponent Assumption 指数知识假设。\\n\\n4、验证者\\n\\n随机产生 s 并同态加密，然后随机产生 α（阿尔法不方便打字，请允许我用 a 代替偷懒）\\n\\n然后构造 (G^(s^3))， (G^(s^2))，(G^s) ，构造 (G^((a \\\\* s^3))， (G^(a \\\\* s^2))，(G^(a \\\\* s))\\n\\n最后将 G^P(s)，G^P(a \\\\* s) 和 G^h(s) 发给证明者。\\n\\n5、证明者\\n\\n通过 \\\\[ (G^(s^3))， (G^(s^2))，(G^s) \\\\]，\\\\[ (G^((a \\\\* s^3))，(G^(a \\\\* s^2))，(G^(a \\\\* s)) \\\\]计算得出 G^P(s)，G^P(a \\\\* s)，连同证明者第3步已知的 G^h(s) 一并发给验证者。\\n\\n6、验证者\\n\\n（1）最后验证：G^P(s) 是否= (G^h(s)) ^ t(s) （验证零知识：多项式 p(x) 有根 t(x)）；\\n\\n（2）还需要验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) （用来校验证明者是否使用了指定的多项式）。\\n\\n这是因为随机数 a 是验证者产生的，证明者并不知道。验证者拿到证明者计算出来的 G^P(s)和 G^(P(a \\\\* s))，通过a进行验证即可。证明者如果通过构造 G^t(s)，指定一个h(s)，从而形成 (G^h(s)) ^ t(s) = (G^t(s)) ^ h(s) 的形式，然后计算出 G^P(s)，是无法满足 G^P(s) 的a次幂刚好等于G^(P(a \\\\* s)) 的。\\n\\n经过上面的分析，协议三的4、5、6步形如图2：\\n\\n![图2](https://images.mirror-media.xyz/publication-images/142Ixtm7zd5HbfLCEGuDG.png?height=882&width=1364)\\n\\n在这个改进版的协议三，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 和 \\\\[ E(a \\\\* s^3)\\\\*、E( a \\\\* s^2) \\\\*、E(a \\\\* s) \\\\] ，计算得到 Proof = \\\\[ g^p = G^P(s) ，g^p’ = G^P(a\\\\*s) ，以及证明者第3步计算出的G^h(x) \\\\] ， 并发送给验证者。\\n\\n（0）验证者的 Verifying Key = \\\\[  t(s) ，a \\\\]。\\n\\n（1）验证者通过 t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n（2）验证者通过 a 验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) ，即证明者提供的 g^P 是用验证者提供的 (G^(s^3))， (G^(s^2))，(G^s)计算出来的。\\n\\n## 协议四（ 证明者为了防止验证者暴力破解出多项式使用无成本的零知识 ）\\n\\n在协议三的第5步存在验证者的问题：\\n\\n验证者有可能从证明者发来的信息中推导出多项式，从而导致零知识泄露。当多项式相对简单的时候，比如：b \\\\* x + c，验证者可以通过暴力破解的方式破解系数，然后验证者再按照证明者计算的内容将多项式计算出来。\\n\\n所以证明者需要随机生成 δ 对返回值进行同态加密，将发送数据隐藏后再发送给验证者。证明者发送给验证者的值也进行同态加密，这个过程通常被称为：无成本的零知识。\\n\\n5、证明者随机生成δ，并构造\\n\\n(G^P(s))^δ、(G^h(s))^δ 和 (G^P(a \\\\* s))^δ 发送给验证者。\\n\\n所以协议三的5、6步改进为图3：\\n\\n![图3](https://images.mirror-media.xyz/publication-images/KgYIIsBrbHvaQ955wqcd-.png?height=808&width=1218)\\n\\n在这个改进版的协议四，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 和 \\\\[ E(a \\\\* s^3)\\\\*、E( a \\\\* s^2) \\\\*、E(a \\\\* s) \\\\] ，计算得到 Proof = \\\\[ g^p = G^P(s) ，g^p’ = G^P(a\\\\*s) \\\\] ， 将 Proof 再进行一次同态加密：Proof = \\\\[ (G^P(s))^δ、(G^P(a \\\\* s))^δ、以及证明者第3步计算出的G^h(x)的加密值：(G^h(s))^δ \\\\]，最后将 Proof 返回给验证者。\\n\\n（0）验证者的 Verifying Key = \\\\[  t(s) ，a \\\\]。\\n\\n（1）验证者通过 t(s)  验证 Proof 的正确性：(G^P(s))^δ 是否= \\\\[ (G^h(s))^δ \\\\]^ t(s)。\\n\\n等价于 G^(P(s) \\\\* δ) 是否=  G^( h(s) \\\\* δ \\\\* t(s) ) 等价于 G^(δ \\\\* p) 是否= G^(δ \\\\* h(s) \\\\*  t(s) )。\\n\\n（2）验证者通过 a 验证 \\\\[ (G^P(s))^δ \\\\]^a 是否= \\\\[ (G^P(a \\\\* s))^δ \\\\] 。\\n\\n## “ 交互式 ” 零知识论证\\n\\n至此，我们一起把协议一升级到了协议四。细心的读者可能已经发现，协议四中仍然需要 “ 验证者先生成一些信息，把信息提供给证明者，证明者根据这些信息计算一些结果，再返回给验证者 ”，这分明就是在 “ 交互 ”，和我们的主题 zk-SNARK “ 非交互式 ” 零知识论证 不符。\\n\\n虽然是 “ 交互式 ” ，但协议执行的过程中还是很完美的实现了我的既定目标：验证者在全程零知识的情况下验证了证明者的论述。那我们为什么还需要 “ 非交互式 ” 呢？\\n\\n这是因为交互式零知识论证有着2个明显的硬伤：\\n\\n1、因为需要交互，所以要求每个证明者和验证者必须同时在线。\\n\\n2、每一个验证者都会随机选出 s 和 a，证明者需要计算n次，效率低下（n个节点）。\\n\\n所以下面我们的主要工作将致力于将 “ 交互式 ” 改进为 “ 非交互式 ” 。\\n\\n## 协议五（ 使用椭圆曲线双线性映射工具解决“交互式”零知识协议四中验证者无法用已知内容验证E(P(s)) 是否= E(h(s)) ^ t(s)的问题 ）\\n\\n从交互式改为非交互式，即验证者和证明者之间不交互，我们面临的第一个严峻的问题是：\\n\\n当 s 和 a 不能由验证者随机产生时，由于不交互，证明者就无法拿到 s 和 a，哪怕是加密后的数据也不行。\\n\\n问题的解决思路：\\n\\n需要找一个第三方或模拟第三方随机生成s和a，而不是验证者随机生成这两个参数，所以会导致验证者不知道t(s)，从而导致无法验证E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n这是因为验证者在第6步验证时已知的内容：\\n\\nE(t(s))，E(a) （交互式第4步s同态加密后=E(t(s))，a同态加密后=E(a) ）\\n\\nE(h(s))，E(P(s)) （交互式第5步证明者通过第4步计算后发给验证者的结果）\\n\\n通过上述已知内容无法验证E(P(s)) 是否= E(h(s)) ^ t(s)\\n\\n这是因为E(h(s)) ^ t(s))不能用E(h(s))和E(t(s))算出来。知道E(h(s)) 、t(s)可以算；或者知道h(s) 、E(t(s))也可以算。\\n\\n> 未完待续\",\"timestamp\":1639648720,\"title\":\"浅谈零知识证明之zk-SNARK\"},\"digest\":\"isXl280KaXBiavob1dPtudg4tAMlaUQrQNW2nKYp1gg\",\"authorship\":{\"contributor\":\"0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"signature\":\"cabtE3bAnOl0gobJuJZd-bESDIhqDzOrzo-DjtvIzJfpoaaxsTL2R8Nrtbh7jJxc6bvK9UGtkXoanrWeFzxNlw\",\"signingKeySignature\":\"0x37986d551641971cdf6ada5c4365b09fa1f1c9565275e4a2e69a6dfcc1435d3a3e15e6f1cbc1bd770fba430d41423a94c25d58507bcf912632c134b280faffdc1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"X3qSOjObTknXQ_iGhDBFYETibD0TVW0twz5QDIthjGI\"}"