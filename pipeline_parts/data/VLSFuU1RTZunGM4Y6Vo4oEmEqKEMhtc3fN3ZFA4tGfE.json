"{\"content\":{\"body\":\"The vigorous development of decentralized applications such as DeFi and GameFi has greatly increased the demand for high-performance blockchains with low transaction costs. However, a key challenge in building a high-performance blockchain is the explosion of storage. The figure below is a chart taken from Etherscan, which illustrates the blockchain data size of an Ethereum full node (archived).\\n\\nFrom the figure, we can see that the scale of node chain data has grown steadily and has now reached \\\\~9TB. Since one of the goals of the decentralized blockchain is to allow computers with common configurations to run nodes, it will be difficult to achieve the mandatory requirement of 9TB+ storage on computers with common configurations.\\n\\nBreak down storage overhead\\nIf we further analyze the storage usage, we can find that the block data only accounts for about 300GB of data (from block height 0 to 13.6M), which is much less than 9TB. So where does the remaining 8.7TB of data come from?\\n\\nIn fact, the archive node executes all blocks and retains all historical data, including:\\n\\nBlock\\n\\nstate\\n\\nTransaction receipt\\n\\nAmong them, state is the main component of this 8.7TB. So sometimes, we refer to storage explosions as \\\"state explosions.\\\" But why is the state so great?\\n\\nWhat is the state of Ethereum?\\n\\nThe Ethereum state is a Merkle Patrica tree (MPT) in which\\n\\nThe leaf node is the mapping of address (0x...) => account, where the account stores the balance, nonce, etc. associated with the address\\n\\nThe internal nodes maintain the tree structure so that the hash root of the entire tree can be quickly calculated\\n\\nSince the archive node will retain all the historical state of all blocks, this means that any update in the MPT will create O(log(N)) internal nodes and will not delete the old internal nodes.\\n\\nGeth's full node\\n\\nIn order to solve the problem of the state explosion of archive nodes, Geth's talented engineers created a new mode called \\\"pruning\\\" mode, which only stores MPT regularly. Here we give a simplified example in which the node only saves the MPT for every 3 blocks. (Note that in order to obtain a state that does not contain any state block, the node must obtain the most recent state before the block and replay the next transaction).\\n\\nBy periodically storing the MPT, the storage size of the state is significantly reduced. According to Etherscan data, the current blockchain data size of Geth full nodes is about 1TB.\\n\\nGeth's fast-synchronized full node\\n\\nOne problem with running a node by replaying all transactions from the genesis block is that replaying all transactions takes a long time. Generally speaking, it takes several weeks to establish such a node to catch up with the latest state of the network from the genesis block. In order to speed up the node startup process, Geth further provides a fast synchronization mode that can download the latest stable block MPT without replaying and maintaining the historical MPT before the block. After downloading the MPT, it will replay the new block like a full node (with periodic state storage).\\n\\nWithout storing the historical MPT (sometimes even the main body of the historical block), the storage size of a Geth node can be further reduced to 447G (as of 2021/12/06). By subtracting 300GB of block data, we infer that the state size is about 150GB.\\n\\nproblem\\nWith the current Ethereum storage size of 447GB and 15 TPS, we expect that a normal configuration computer with a 1TB SSD should be able to run the Ethereum node for a considerable period of time (for example, several years). So does storage explosion or state explosion really exist? Maybe Ethereum will not in the next few years, but what if we can expand the Ethereum Virtual Machine (EVM) to hundreds or thousands of TPS?\\n\\nLet us turn our attention to another EVM-based chain, Binance Smart Chain (BSC). As of December 8, 2021, BSC has:\\n\\nAbout 984 GB of on-chain data, of which blocks account for about 550 GB, and state accounts for about 400 GB.\\n\\n2\\\\.06623 billion transactions, 100 TPS\\n\\nIf we further use the number of transactions to predict the size of the data, we can get:\\n\\nIf TPS is 100, that is \\\\~3,153 M TPY\\n\\nAfter 1 year, total TX \\\\~5,219M, block \\\\~ 1.375 TB, status \\\\~ 1.085TB\\n\\nAfter 3 years, total TX \\\\~11,525M, block \\\\~3.025TB, status \\\\~2.387 TB\\n\\nIf TPS is 150 (observed peak TPS), that is \\\\~4,730 M TPY\\n\\nAfter 1 year, total TX \\\\~6,796M, block \\\\~1.809 TB, status \\\\~1.427 TB\\n\\nAfter 3 years, total TX \\\\~16,256M, block \\\\~4.327 TB, status \\\\~3.414TB\\n\\nIn summary, for BSC, if the current speed is maintained or even higher, it will soon reach the same storage size of the Ethereum archive node, which is almost impossible for ordinary computers to run.\\n\\nStorage explosion problem of blockchain with extremely high TPS\\n\\nIf we make a bolder assumption about a very high TPS blockchain (such as what QuarkChain can do), what will this number become? Let's consider a blockchain with 1000 TPS and analyze its block and state size, it will be:\\n\\nAssuming that the tx size is about 100 bytes, the amount of storage required for a block per year is 1000 (TPS) \\\\* 100 (bytes per tx) \\\\* 365 \\\\* 24 \\\\* 3600 = 2.86 TB\\n\\nAssuming that MPT has 10 billion accounts (more than the world's population!), we expect the state size to be 150G (Ethereum state size)/0.18B (Ethereum unique address) \\\\* 10B = 8.3 TB\\n\\nPutting these numbers together, we can easily come to a conclusion that this is a requirement that most ordinary configuration computers will not be able to withstand!\\n\\noptimization\\nIn order to optimize storage costs, we must relax the restrictions to be compatible with EVM rather than compatible with Ethereum. That is, we must build/run another chain that supports EVM instead of a highly optimized Ethereum client.\\n\\nState storage optimization\\n\\nThe first optimization we propose is to use ordinary KV instead of MPT. When the MPT is large, all the internal nodes in the MPT can be very expensive. And our optimization will remove all internal nodes in MPT. Assuming that the data of each account is about 50 bytes (20 addresses + 2 nonces + 12 accounts + others), we can save the data of 10 billion accounts as follows:\\n\\n\\\\~ 10B \\\\* 50 + 100GB (code) = 600 GB, which is about 1/10 of the MPT version!\\n\\nAlthough using ordinary KV will bring huge benefits, a major problem is that we cannot calculate the post-hash of each block in such a short block interval, which means that we will lose the following benefits of Ethereum:\\n\\nFast synchronization: download the status of any block and quickly synchronize the network by replaying the remaining blocks\\n\\nFork detection (or Byzantine detection): Whether the newly created block from the peer will cause the state to be different from the local execution block.\\n\\nTo enable fast synchronization, we have a periodic snapshot block (snapshot interval = epoch = for example, 14 weeks). A snapshot block contains the additional information of the previous state hash, that is, the post state hash of the previous snapshot block (the state hash after the transaction is executed):\\n\\nA non-snapshot block does not maintain a state hash, but has an incremental hash, which contains the hash of the original database operation (delete, update) of all transactions in the block. This makes fork detection possible!\\n\\nWe use the pre-transaction state hash to replace the post-transaction state hash of the block in Ethereum. The reason is that the node cannot immediately calculate the state hash after the transaction, but by using the state hash before the transaction, the node can use the entire epoch interval to calculate the hash. For example, assuming that the state hash calculation processes 10M state data per second, it will take 600 GB / 10 M \\\\~ 16.67 hours to calculate the entire state of 600 GB (vs. epoch = 14 weeks)\\n\\nThe process of hashing before calculating the state is as follows:\\n\\n1. When a snapshot block is received and finalized, its KV state is snapshotted, and a background thread is created to iterate all KV entries (address => account) and calculate the hash.\\n2. When the next snapshot block is created, the calculated state hash value will be stored in the block. Similarly, the node will create another snapshot of KV and calculate its hash in the background.\\n3. When the next snapshot block is created, the node can now release the KV snapshot of the snapshot block in addition to storing the pre-state hash, which means that all deleted/updated data from the snapshot block will be automatically Garbage collection (for example, compression in levelDB)\\n\\nThe result means that to store state, a node only needs up to two KV snapshots (most likely one with increment and one KV snapshot).\\n\\nBlock storage optimization\\nUsing snapshot blocks, we can further reduce the required block data in the node by storing only the following data:\\n\\nA snapshot of the state before the transaction execution of the latest snapshot block, that is (latest â€” 1) the state after the transaction execution of the snapshot block\\n\\n(Latest-1) The complete block after the snapshot block\\n\\nWe can perform simple mathematical calculations on the storage cost: Assuming that the epoch lasts for 2 weeks, the block re-enlargement is as small as\\n\\n2 \\\\* 14 (days) \\\\* 24 (hours) \\\\* 3600 (seconds) \\\\* 100 \\\\* 1000 (TPS) = 224 GB!\\n\\nMoreover, the numbers here will not grow over time!\\n\\nSummarize\\nWe analyzed the current storage usage of Ethereum:\\n\\nNot only blocks, but state storage consumes a lot of space\\n\\nWhen TPS> 1000, storage space usage is prohibitively high\\n\\nWe propose to optimize the block and state:\\n\\nReduced block size from 2.86 TB per year to 224 GB\\n\\nState size (\\\\~10B account) reduced from 8.3 TB to 600 GB\\n\\nA 2TB general configuration computer should be able to meet the conditions for long-running nodes\\n\\nDisadvantages: the light node cannot verify a piece of data in the state (must be a full node)\",\"timestamp\":1640312117,\"title\":\"Blockchain storage explosion: problems, analysis and optimization\"},\"digest\":\"3BjQ1i-wf62xVvvLefCsDk8LRly3XtygtIC7SkoZJjI\",\"authorship\":{\"contributor\":\"0x19a23AfB21e123c626C2c4C19c34d2037Ac35734\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"EL8a_TEZ37Fsk07fsh582qKimmCRgiHSC0qfyO3DXDk\\\",\\\"y\\\":\\\"kV5Vnbk820BAjVyS-NuP9KvMyEpmlrG143vfWyV5Rhc\\\"}\",\"signature\":\"OA7vnaqW1wHLwcGGjSe3FPsiLjdNdhIa-uxyKHhzuPfl9--gxNWAmc1jI99qaM3OAHCzRBCotBC_vGL6kHl5VQ\",\"signingKeySignature\":\"0xc90ac90f7d589dc9b9ade93bd74549ef3371a1ac8188ca1bff6d8384d12a064207d56af5bb682ca55281254bb0b9f5a34f2241cc4f7afd3544bf6d17a1f0ea021c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"EL8a_TEZ37Fsk07fsh582qKimmCRgiHSC0qfyO3DXDk\\\",\\\"y\\\":\\\"kV5Vnbk820BAjVyS-NuP9KvMyEpmlrG143vfWyV5Rhc\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"3BjQ1i-wf62xVvvLefCsDk8LRly3XtygtIC7SkoZJjI\"}"