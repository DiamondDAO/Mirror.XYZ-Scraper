"{\"content\":{\"body\":\"前言\\n1\\\\.1 为什么需要开发规范\\n编码规范对于程序员而言尤为重要，有以下几个原因：\\n\\n* 一个软件的生命周期中，80%的花费在于维护\\n* 几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护\\n* 编码规范可以改善软件的可读性，可以让程序员尽快而彻底地理解新的代码\\n* 如果你将源码作为产品发布，就需要确任它是否被很好的打包并且清晰无误，一如你已构建的其它任何产品\\n\\n1\\\\.2 开发规范的作用\\n\\n* 减少维护花费\\n* 提高可读性\\n* 加快工作交接\\n* 减少名字增生\\n* 降低缺陷引入的机会\\n\\n2 命名规范\\n2\\\\.1 常量命名规范\\n2\\\\.1.1 类型\\n常量命名规范\\n2\\\\.1.2 说明\\n常量用于保存需要常驻内存中并且经常使用变化不多的数据，定义常量的名称的时候需要遵循望文知意的原则；\\n2\\\\.1.3 规则\\n\\n* 1. 全部为大写字母；\\n* 1. 中间以“_”连接；\\n* 1. 望文知意原则；\\n     2\\\\.1.4 备注\\n     代码中涉及到直接使用某个字符串或者其他基本类型的值时，建议定义成常量，避免多处直接使用同样的值作为参数。\\n     2\\\\.1.5 举例\\n* 如：定义一个常量表示最小屏幕宽度的常量，则可以定义一个int类型的常量，该常量可以命名为：“MIN_SCREEN_WIDTH“；\\n* 其他举例：\\n* 例如：static final int MIN_SCREEN_WIDTH = 4；( √)\\n* 例如：static final int min_screen_width = 4;（×）\\n* 例如：static final int minScreenWidth = 4; （×）\\n* 例如：static final int WIDTH = 4；（×）\\n* 例如：static final int width = 4；（×）\\n* 例如：static final int wd = 4；（×）\\n  2\\\\.2 变量命名规范\\n  2\\\\.2.1 类型\\n  变量命名规范\\n  2\\\\.2.2 说明\\n  变量用于保存系统中的临时数据，变量命名时遵循望文知意，简单明了，驼峰标示等原则。\\n  2\\\\.2.3 规则\\n\\n1. 首字母小写；\\n2. java驼峰命名；\\n3. 望文知意原则；\\n4. 推荐引用类型变量添加前缀“m”；\\n5. 如果是View组件变量，则组件名称为xml文件中定义的ID名称去掉下划线，下划线后一位大写；\\n   2\\\\.2.4 备注\\n   无\\n   2\\\\.2.5 举例\\n\\n* 如：定义一个表示最小屏幕宽度的变量，则可以定义一个int型的临时变量为：mMinScreenWidth；\\n* 例如：static final int mMinScreenWidth = 4； ( √)\\n* 例如：static final int minWidth = 4；（×）\\n* 例如：static final int screenWidth = 4；（×）\\n* 例如：static final int width = 4；（×）\\n* 例如：static final int min = 4； （×）\\n* 例如：static final int msw = 4； （×）\\n  2\\\\.3 方法命名规范\\n  2\\\\.3.1 类型\\n  方法命名规范\\n  2\\\\.3.2 说明\\n  方法名的命名应该遵循简单明了的原则；\\n  2\\\\.3.3 规则\\n\\n1. 首字母小写；\\n2. java驼峰命名；\\n3. 简单明了原则；\\n4. 初始化View方法init\\\\*（每个init做一件事）\\n   2\\\\.3.4 备注\\n\\n* 同时在方法的实现上，尽量不要在一个方法中出现太多实现代码，如一个方法有几百行的实现逻辑，推荐在逻辑复杂时，按功能点拆分出多个方法，便于阅读。\\n* 另外，出现功能一样的实现逻辑，尽量抽取公用方法，避免将实现逻辑复制到多个用到的地方。\\n  2\\\\.3.5 举例\\n* 如：定义一个获取屏幕宽度的方法，依照上述原则，则可以定义为一个静态方法：public static int getScreenWidth();\\n* 例如：public static int getScreenWidth();( √)\\n* 例如：public static int getscreenwidth();（×）\\n* 例如：public static int getScreenwidth();（×）\\n* 例如：public static int getWidth();（×）\\n* 例如：public static int getScreen();（×）\\n* 例如：public static int getSW();（×）\\n  2\\\\.4 类命名规范\\n  2\\\\.4.1 类型\\n  类命名规范\\n  2\\\\.4.2 说明\\n  类名主要表示一个类的作用，需要简明扼要，望文知意，并且首字母大写。\\n  2\\\\.4.3 规则\\n\\n 1. 首字母大写；\\n 2. java驼峰命名；\\n 3. 望文知意原则；\\n 4. 能够说明类的功能和主要作用（注释的作用）；\\n 5. Acitivity类以Acitivity结尾；\\n 6. Fragment类以Fragment结尾；\\n 7. Service类以Service结尾；\\n 8. BroadcastReceiver类以Receiver结尾；\\n 9. ContentProvider类以Provider结尾；\\n10. Application类以Application结尾；\\n11. 自定义View类以Custom\\\\*\\\\*View结尾；\\n12. 自定义Adapter类以Adapter结尾；\\n13. adapter中的ViewHolder以Holder结尾；\\n14. 实体Bean以Entity结尾；\\n    2\\\\.4.4 备注\\n    无\\n    2\\\\.4.5 举例\\n\\n* 如：定义一个获取屏幕信息的工具类，则可以定义为public class ScreenUtils；\\n* 例如：public class ScreenUtils; ( √)\\n* 例如：public class Screenutils; （×）\\n* 例如：public class Screen; （×）\\n* 例如：public class screenutils; （×）\\n* 例如：public class screen; （×）\\n* 例如：public class su；（x）\\n  2\\\\.5 接口命名规范\\n  2\\\\.5.1 类型\\n  接口命名规范\\n  2\\\\.5.2 说明\\n  接口命名需要简单明了，长度不宜过长；\\n  2\\\\.5.3 规则\\n\\n1. 首字母大写（第二个字母也是大写）；\\n2. java驼峰命名；\\n3. 望文知意原则；\\n4. 建议在名称前面追加“I”；\\n   2\\\\.5.4 备注\\n\\n* I\\\\*\\\\*Listener\\n* I\\\\*\\\\*CallBack\\n* I\\\\*\\\\*；\\n  2\\\\.5.5 举例\\n* 如：定义一个activity的方法接口，实现接口中的某些方法：public\\n  interface IFunctionListener；\\n* 例如：public interface IFunctionListener；( √)\\n* 例如：public interface BaseActivity; （×）\\n* 例如：public interface Baseactivityinter; （×）\\n* 例如：public interface BaseInter; （×）\\n* 例如：public interface ActivityInter；（×）\\n  2\\\\.6 包名规范\\n  2\\\\.6.1 类型\\n  包名规范\\n  2\\\\.6.2 说明\\n  用于分类管理类文件；\\n  2\\\\.6.3 规则\\n\\n 1. 所有字母小写；\\n 2. 简单明了，层级很深，没有拼接的包名；\\n 3. 望文知意；\\n 4. 按功能划分包名，如“我的”\\n 5. 工具类可以划分为一个工具类的包名，utils，里面可以添加包名层级；\\n 6. 系统类的可以划分为一个系统类的包，system，里面可以添加包名层级；\\n 7. 组件类的可以划分为一个组件类的包，\\\\*\\\\*\\\\*，里面添加adapter的包名，自定义view包名；\\n 8. Service类的可以划分为一个服务类的包，service，里面可以添加包名层级；\\n 9. 数据库相关类可以划分为一个数据库类，db，里面可以添加数据库相关类，Bean类，数据库服务类等；\\n10. 广播类的可以划分为广播类的包，receiver，可以放一些广播相关的类；\\n11. 网络类相关的可以划分为，network，放一些网络相关的类；\\n12. Fragment类存放在fragment包下；\\n13. Activity类存放在Activity包下；\\n    2\\\\.6.4 备注\\n    无\\n    2\\\\.6.5 举例\\n    无\\n    2\\\\.7 目录名称规范\\n    2\\\\.7.1 类型\\n    目录名称规范\\n    2\\\\.7.2 说明\\n    主要是一些jar包，so文件的配置目录名称；\\n    2\\\\.7.3 规则\\n14. 全部为小写字母；\\n15. 简单明了；\\n16. 望文知意；\\n17. 驼峰表示；\\n    2\\\\.7.4 备注\\n    无\\n    2\\\\.7.5 举例\\n\\n* 后期增加目录的可能性不多，现列举出系统中存在的目录结构：\\n* lib：第三方jar的保存路径；\\n* jniLibs：jni引用的so文件的目录；\\n  2\\\\.8 布局文件名称规范\\n  2\\\\.8.1 类型\\n  布局文件名称规范\\n  2\\\\.8.2 说明\\n  主要包含资源文件的命名问题；\\n  2\\\\.8.3 规则\\n\\n 1. 全部为小写字母；\\n 2. 中间以”_”连接；\\n 3. 望文知意原则；\\n 4. 布局文件的开头问类名；\\n 5. 列表项的xml布局文件名称：��名_item.xml；\\n 6. activity类的xml文件名称：类名_activity.xml；\\n 7. fragment类的xml文件名称：类名_fragment.xml；\\n 8. 自定义View的xml文件的名称：类名_父类名.xml；\\n    2\\\\.8.4 备注\\n    无\\n    2\\\\.8.5 举例\\n    如：如定义H5Activity的xml文件名称，则可以定义为h5.xml；尽量不使用大写字母等。\\n    2\\\\.9 drawable文件名称规范\\n    2\\\\.9.1 类型\\n    drawable文件名称命名规范\\n    2\\\\.9.2 说明\\n    主要包含资源文件的命名问题；\\n    2\\\\.9.3 规则\\n 9. 全部为小写字母；\\n10. 中间以”_”连接；\\n11. 望文知意原则；\\n12. 布局文件的开头问类名；\\n13. 11_22_33_44，44：selector，shape（大概五六个，暂时不定义其他的）； 33：src、bg、color（可扩展，可为空）； 22：状态名称或者为空；11：业务名称\\n    2\\\\.9.4 备注\\n    无\\n    2\\\\.9.5 举例\\n    无\\n    2\\\\.10 资源ID规范\\n    2\\\\.10.1 类型\\n    资源ID命名规范\\n    2\\\\.10.2 说明\\n    各种资源ID的定义问题；\\n    2\\\\.10.3 规则\\n14. 全部为小写字母；\\n15. 中间以”_”连接；\\n16. 望文知意原则；\\n    2\\\\.10.4 备注\\n    可以考虑按照组件的名称的缩写作为前缀，（同一个xml文件中ID名称不能重复）如：组件简写（大写字母缩写）_业务名称\\n    TextView的组件:tv_pay_money\\n    Button的组件：btn_pay_money\\n    EditText的组件：et_user_name\\n    LinerLayout组件：ll_container\\n    2\\\\.10.5 举例\\n    如：比如一个textview组件，可点击用于支付的按钮，则可以把ID定义为： tv_pay_money；\\n    3 注释规范\\n    3\\\\.1 类注释\\n    在类、接口定义之前当对其进行注释，包括类、接口的目的、作用、功能、继承于何种父类，实现的接口、实现的算法、使用方法、示例程序等。\\n    /\\\\*\\\\*\\n\\n* author:作者\\n* time:时间\\n* desc:描述\\n  \\\\*/\\n\\n3\\\\.2 方法注释\\n方法注释的模板：\\n/\\\\*\\\\*\\n\\n* desc:描述\\n* @param 参数名 参数描述\\n* @param 参数名2 参数描述\\n* @return 返回值类型说明\\n* @throws Exception 异常说明\\n  \\\\*/\\n\\n3\\\\.3 类成员变量和常量注释\\n成员变量和常量需要使用如下注释的形式，注释位于变量的上侧；\\n/\\\\*\\\\*\\n\\\\*\\n\\\\*\\\\*/\\n\\n3\\\\.4 内部逻辑注释\\n内部逻辑注释模板：\\n//支付成功\\nif (response.getRet() == 0) {\\nToast.makeText(H5Activity.this, \\\"支付成功\\\", Toast.LENGTH_LONG).show();\\ngoToNext(response);\\n}\\n//支付失败\\nelse if (response.getRet() == -1) {\\nToast.makeText(H5Activity.this, \\\"支付失败\\\", Toast.LENGTH_LONG).show();\\n//刷新当前页面\\nreflush(currentUrl);\\n}\\n\\n4 代码顺序\\n4\\\\.1 代码顺序\\n在一个典型的Activity中代码的顺序如下：\\n/\\\\*\\\\*\\n\\n* author:sh\\n* desc:该class的作用\\n* time:yyyy-MM-dd\\n  **/\\n  public class ClassName {\\n  //（1） 成员变量集合\\n  //（2） 回调方法集合\\n  若该类为activity，则：onCreate、**、onDestory；\\n  若该类为Fragment、则：onCreateView、\\\\*\\\\*、onDestory；\\n  //（3） 其他方法集合\\n  }\\n\\n5 代码风格\\n5\\\\.1 大括号换行\\n左大括号不换行，右大括号换行；\\nclass MyClass {\\nint func() {\\nif (something) {\\n// ...\\n} else if (somethingElse) {\\n// ...\\n} else {\\n// ...\\n}\\n}\\n}\\n\\n5\\\\.2 小括号空格\\nif (condition) {\\nbody();\\n}                         // 推荐\\n\\n5\\\\.3 缩进\\n\\n* 4 个空格作为缩进排版的一个单位，不使用制表符 tab。\\n* 8 个空格作为换行后的缩进，包括函数调用和赋值。\\n* Instrument i =\\n  someLongexpression_r(that, NotFit, on, one, line); // 推荐\\n  5\\\\.4 每一行的长度\\n* 尽量避免一行的长度超过 100 个字符。\\n* 例外：如果注释行包含了超过 100 个字符的命令示例或者 url 文字，为了便于剪切和复制，其长度可以超过 100 个字符。\\n* 例外：import 行可以超过限制，因为很少有人会去阅读它。这也简化了编程工具的写入操作。\\n  5\\\\.5 每次声明一个变量\\n* 推荐一行一个声明，因为这样以利于写注释；\\n* int level; // indentation level\\n* int size; // size of table\\n  5\\\\.6 if-else语句\\n  if-else语句应该具有如下格式：\\n  if (condition) {\\n  statements;\\n  }\\n\\nif (condition) {\\nstatements;\\n} else {\\nstatements;\\n}\\n\\nif (condition) {\\nstatements;\\n} else if (condition) {\\nstatements;\\n} else{\\nstatements;\\n}\\n注意：if语句总是用”{“和”}“括起来，避免使用如下容易引起错误的格式：\\nif (condition)  // 避免\\nstatement;\\n\\n5\\\\.7 for语句\\n一个for语句应该具有如下格式：\\nfor (initialization; condition; update) {\\nstatements;\\n}\\n当在for语句的初始化或更新子句中使用逗号时，避免因使用三个以上变量，而导致复杂度提高。\\n若需要，可以在for循环之前(为初始化子句)或for循环末尾(为更新子句）使用单独的语句。\\n\\n5\\\\.8 while语句\\n一个while语句应该具有如下格式：\\nwhile (condition) {\\nstatements;\\n}\\n\\n5\\\\.9 do-while语句\\ndo {\\nstatements;\\n} while (condition);\\n\\n5\\\\.10 switch语句\\n一个switch语句应该具有如下格式：\\nswitch (condition) {\\ncase ABC:\\nstatements;\\n/\\\\* falls through \\\\*/\\ncase DEF:\\nstatements;\\nbreak;\\n\\n```\\ncase XYZ:\\n    statements;\\n    break;\\n\\ndefault:\\n    statements;\\n    break;\\n```\\n\\n}\\n每当一个case顺着往下执行时（因为没有break语句），通常应在break语句的位置添加注释。\\n\\n6 异常规范\\n6\\\\.1 异常名称\\n定义异常的时候，异常的后缀名称以Exception结尾，及\\\\*\\\\*Exception；\\n6\\\\.2 异常描述\\n尽量英文描述，简单明了；\\n6\\\\.3 异常格式\\n一个try-catch语句应该具有如下格式：\\ntry {\\nstatements;\\n} catch (ExceptionClass e) {\\nstatements;\\n}\\n\\ntry {\\nstatements;\\n} catch (ExceptionClass e) {\\nstatements;\\n} finally {\\nstatements;\\n}\\n\\n7 Kotlin规范\\n7\\\\.1 常量 vs 变量\\n定义常量时使用关键词val， 定义变量时使用关键词var。\\n建议： 把所有的值使用val定义，且只在编译器警告的时候修订为var。\\n\\n7\\\\.2 伴生对象\\n伴生对象应定义在类文件的上面，而关于伴生对象的命名规范要遵守Java标准规范。表示常量 需加 const\\nclass MainFragment: Fragment() {\\ncompanion object {\\nconst val TYPE_VIEW_HEADER = 0\\nconst val TYPE_VIEW_FOOTER = 1 // 推荐\\nval TypeViewHeader = 0  //不推荐\\n}\\n}\\n\\n7\\\\.3 分号（;）\\n在Kotlin中避免使用分号。\\nval horseGiftedByTrojans = true\\nif (horseGiftedByTrojans) {\\nbringHorseIntoWalledCity() //推荐\\nbringHorseIntoWalledCity(); //不推荐\\n}\\n\\n7\\\\.4 字符串\\n推荐使用字符串插值语法糖 ${}\\nval fullName = \\\"${user.firstName} ${user.lastName}\\\" //推荐\\nval fullName = user.firstName + \\\" \\\" + user.lastName //不推荐\\n\\n7\\\\.5 When语句\\nKotlin的When语句和Java中的Switch有稍许区别，如不会fall through。如果不同的case具有相同的处理策略，使用逗号（,）,并且else语句是必须的。\\nwhen (anInput) {\\n1, 2 -> doSomethingForCaseOneOrTwo()\\n3 -> doSomethingForCaseThree()\\nelse -> println(\\\"No case satisfied\\\")\\n}   //推荐\\n\\nwhen (anInput) {\\n1 -> doSomethingForCaseOne()\\n2 -> doSomethingForCaseOneOrTwo()\\n3 -> doSomethingForCaseThree()\\n}  //不推荐\\n\\n8 其他规范\\n8\\\\.1 源文件的函数小于2K\\n一般来说源文件的行数不能大于2K行，过多的话可以考虑拆分功能，拆分函数等；\\n8\\\\.2 使用TODO注释\\n\\n* 对那些临时性的、短期的、够棒但不完美的代码，请使用 TODO 注释。\\n* TODO 注释应该包含全部大写的 TODO，后跟一个冒号：\\n* // TODO: Remove this code after the UrlTable2 has been checked in.\\n* // TODO: Change this to use a flag instead of a constant.\\n  如果 TODO 注释是“将来要做某事”的格式）。\\n  8\\\\.3 使用自定义LOG\\n  在系统中需要打印LOG的时候，尽量使用自定义的LOG，自定义的LOG在开发环境的时候会打印日志，正式环境的时候不会打印日志。\\n  8\\\\.4 使用自定义TAG\\n  在系统打印LOG的时候，使用TAG尽量使用tab，同意的TAG标志。\",\"timestamp\":1636539617,\"title\":\"android开发规范\"},\"digest\":\"Qm8HQ7iC77ioDeeQkQaO_eoz7nBtMDmivonkFCxVL7k\",\"authorship\":{\"contributor\":\"0x5b37F72eBda061975b3De313525Da3a1A2e7D25d\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"T4JA4QMwTdC4ZIvtn-rPOVaHbKJkQdny02GoyKpCAZk\\\",\\\"y\\\":\\\"19eFO08iJ3L65hsW6_y3FLsmipP8MdFE1i4tBdxP12k\\\"}\",\"signature\":\"sJbC95VTpLCyVDnrkUTx4l6j-RNcSwiVu7INtO-dnNbMo04zabQbeX2FO0bnlgWVrCKuNdan7Ru-2YLsOJTmjg\",\"signingKeySignature\":\"0x5ab022e92b7b3484ebaac1bdec693febb26df972f7e7f06dd494646a17e9584e6ff260953eef6253af6596cfdc3009cc1a51fdaf18ef47ec2e8041c723d30a251b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"T4JA4QMwTdC4ZIvtn-rPOVaHbKJkQdny02GoyKpCAZk\\\",\\\"y\\\":\\\"19eFO08iJ3L65hsW6_y3FLsmipP8MdFE1i4tBdxP12k\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"Qm8HQ7iC77ioDeeQkQaO_eoz7nBtMDmivonkFCxVL7k\"}"