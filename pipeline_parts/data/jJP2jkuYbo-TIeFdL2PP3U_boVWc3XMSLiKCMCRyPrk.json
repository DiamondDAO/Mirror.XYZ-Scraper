"{\"content\":{\"body\":\"## [](#overview)Overview\\n\\nI've recently been playing around writing some smart contracts for fun with Solidity and the fastest way to validate the logic you wrote works as what you expect it to do is by unit testing. It was also a fun experiencing testing smart contracts with Chai and Mocha together with TypeScript. It made things quick and easy for me. And cheers to Hardhat for making things much more easier and convenient that it automatically generates all the TypeScript typings of a smart contract via Typechain. In this article we're only going to cover how we set it up using Hardhat and how we can make those assertions.\\n\\nBut why should we unit test our smart contracts? Can't we just deploy it manually using the Hardhat deploy script and from the UI we can point-click and test it from there? Yes, we can but eventually it's going to take us so much time, you can count off how many steps it took to validate that the smart contract that we wrote has been working as what we expect. With unit testing, we can directly make calls to those methods and make the assertions or even console logging if you so desire to in a single test file.\\n\\nHowever, if you're still new to Ethereum Development or Blockchain Development, then be sure to check out [Nader Dabit's article for a complete guide to Full Stack Ethereum Development](https://dev.to/dabit3/the-complete-guide-to-full-stack-ethereum-development-3j13) ðŸ”¥\\n\\nWith all that being said let's get right on to it. ðŸš¢\\n\\n## [](#the-stack)The Stack\\n\\nOutlining the stack that we are using for this tutorial:\\n\\n*   [Solidity](https://soliditylang.org/)\\n*   [Hardhat](https://hardhat.org/)\\n*   [Chai](https://www.chaijs.com/)\\n*   [Mocha](https://mochajs.org/)\\n*   [TypeScript](https://www.typescriptlang.org/)\\n\\n## [](#installation)Installation\\n\\nAs mentioned above we are going to use Hardhat for this. Just in case you don't know what Hardhat is, it provides a development environment for Ethereum based projects. It's very intuitive I like it and the documentation is also great. You can visit the docs from [here](https://hardhat.org/).\\n\\nLet's get started.\\n\\nSetup a new directory called `smart-contract-chai-testing` (Or whichever you prefer to name it)\\\\\\n\\n\\n    # you can omit the $ sign\\n    $ mkdir smart-contract-chai-testing\\n\\n\\n\\nThen navigate into the new directory created\\\\\\n\\n\\n    $ cd smart-contract-chai-testing\\n\\n\\n\\nWe'll initialize a local Git repository to make things easier for us to visually see in the source control on what things were recently added or modified (I prefer it this way but you can omit this step)\\\\\\n\\n\\n    $ git init\\n\\n\\n\\nNext is we'll initialize a Hardhat project with the following command (Assuming that you have Node.js installed already in your machine)\\\\\\n\\n\\n    $ npx hardhat init\\n\\n\\n\\nYou should then see the following output in your terminal\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--z4XdCeqw--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zbe9kwjfoui9eictit9e.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--z4XdCeqw--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zbe9kwjfoui9eictit9e.png)\\n\\nAnd proceed to selecting **\\\"Create an advanced sample project that uses TypeScript\\\"**, it will just scaffold everything for us. When that gets selected, just say yes (Y) to all questions the CLI asks.\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--epYWAZ4o--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/33jcf8kdex57l3owemq7.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--epYWAZ4o--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/33jcf8kdex57l3owemq7.png)\\n\\nNow that's all setup we can open the code in our favorite IDE, the almighty Visual Studio Code.\\\\\\n\\n\\n    $ code .\\n\\n\\n\\nAnd finally stage all the changes and commit with \\\"Init\\\" message\\\\\\n\\n\\n    $ git add . && git commit -m \\\"Init\\\"\\n\\n\\n\\n## [](#running-a-test)Running a Test\\n\\nAs you notice like any other Hardhat initial projects, we got a `Greeter` smart contract. In this scaffolding we also have that and got a test case on TypeScript. So to trigger a test execute the following command in your terminal. A test on `test/index.ts` will get executed.\\\\\\n\\n\\n    $ npx hardhat test \\n\\n\\n\\nWhen that is called it is going to compile your smart contract as quickly as possible and with Hardhat's Typechain it's going to auto-generate all the TypeScript typings for that smart contract `Greeter`. That's very convenient isn't it? When writing smart contracts with Hardhat's Typechain plugin or library, there's literally zero boilerplate.\\n\\nYou can see it for yourself and inspect the directory generated called `typechain` along with the `artifcats` directory that was generated too as the smart contract was compiled.\\n\\n## [](#updating-the-greeter-smart-contract)Updating the Greeter smart contract\\n\\nOk so we'll modify our `Greeter` contract to have some slightly interesting test cases. In this smart contract it should do the following:\\n\\n*   Should have a function `sum` that returns the sum of two numbers provided\\n*   A user can store their lucky number, they are only allowed to store a lucky number when they don't have a lucky number stored yet. Otherwise the execution will revert.\\n*   A user can update their lucky number, only if they remember correctly their previous lucky number. Otherwise the execution will revert.\\n\\nThe requirements are a bit confusing aren't they? But that's exactly why we should be writing tests so we exactly know its behavior on-chain and we can fix up bugs during development before it gets finally deployed to Mainnet.\\n\\nYou can update your `Greeter` smart contract and we'll then create test cases for it.\\\\\\n\\n\\n    //SPDX-License-Identifier: Unlicense\\n    pragma solidity ^0.8.4;\\n\\n    import \\\"hardhat/console.sol\\\";\\n\\n    contract Greeter {\\n        mapping(address => uint256) public ownerToLuckyNumber;\\n\\n        constructor() {\\n            console.log(\\\"Deployed Greeter by '%s'\\\", msg.sender);\\n        }\\n\\n        function sum(uint256 a, uint256 b) public pure returns (uint256) {\\n            return a + b;\\n        }\\n\\n        function getMyLuckyNumber() external view returns (uint256) {\\n            return ownerToLuckyNumber[msg.sender];\\n        }\\n\\n        modifier luckyNumberGuard() {\\n            /// @dev if it's not 0 then owner already has a lucky number\\n            require(\\n                ownerToLuckyNumber[msg.sender] == 0,\\n                \\\"You already have a lucky number.\\\"\\n            );\\n            _;\\n        }\\n\\n        modifier luckyNumberNotZero(uint256 _luckyNumber) {\\n            require(_luckyNumber != 0, \\\"Lucky number should not be 0.\\\");\\n            _;\\n        }\\n\\n        function saveLuckyNumber(uint256 _luckyNumber)\\n            external\\n            luckyNumberGuard\\n            luckyNumberNotZero(_luckyNumber)\\n        {\\n            ownerToLuckyNumber[msg.sender] = _luckyNumber;\\n        }\\n\\n        modifier shouldMatchPreviousLuckyNumber(uint256 _luckyNumber) {\\n            require(\\n                ownerToLuckyNumber[msg.sender] == _luckyNumber,\\n                \\\"Not your previous lucky number.\\\"\\n            );\\n            _;\\n        }\\n\\n        function updateLuckyNumber(uint256 _luckyNumber, uint256 _newLuckyNumber)\\n            external\\n            shouldMatchPreviousLuckyNumber(_luckyNumber)\\n        {\\n            ownerToLuckyNumber[msg.sender] = _newLuckyNumber;\\n        }\\n    }\\n\\n\\n\\nI've written few functions and few modifiers just to make things a bit interesting to test.\\n\\n## [](#writing-our-tests)Writing our tests\\n\\nNow we got our smart contract up to date to the requirements, the fun starts and we'll start testing it. Also I like to group my tests by function names on those function I am going to test it, it makes things easier to navigate in this test suite when things get bigger. Not only that but it helps me navigate easily when after a few months I have to look back at it again.\\n\\nSo basically I have the following structure:\\\\\\n\\n\\n    describe(\\\"Greeting\\\", () => {\\n      describe(\\\"functionName\\\", () => {\\n            it(\\\"should return when given\\\", async () => {\\n                // ...\\n        })\\n      })\\n    })\\n\\n\\n\\nThe first `describe` is the smart contract name and each child `describe`s are all the functions that are in that smart contract. But you can structure your tests in any way shape or form that you think it's much easier to go with.\\n\\n### [](#writing-a-test-for-function-sum)Writing a test for function sum\\n\\nHere's a test case for testing the `sum` function\\\\\\n\\n\\n    import { expect } from \\\"chai\\\";\\n    import { ethers } from \\\"hardhat\\\";\\n    import { Greeter } from \\\"../typechain\\\";\\n\\n    describe(\\\"Greeter\\\", function () {\\n      let contract: Greeter;\\n\\n      beforeEach(async () => {\\n        const Greeter = await ethers.getContractFactory(\\\"Greeter\\\");\\n        contract = await Greeter.deploy();\\n      });\\n\\n      describe(\\\"sum\\\", () => {\\n        it(\\\"should return 5 when given parameters are 2 and 3\\\", async function () {\\n          await contract.deployed();\\n\\n          const sum = await contract.sum(2, 3);\\n\\n          expect(sum).to.be.not.undefined;\\n          expect(sum).to.be.not.null;\\n          expect(sum).to.be.not.NaN;\\n          expect(sum).to.equal(5);\\n        });\\n      });\\n    });\\n\\n\\n\\nFor a quick breakdown, I created a local variable and used `let` to reassign it but have a type of `Greeter` which was generated by Typechain as the smart contract was compiled. And on the `beforeEach` for every test case it's going to execute that and set the value for the `contract` variable. So basically in all test cases we can just directly grab it off from there and not having to copy-paste the contract in each single test cases.\\n\\nNow run the tests by the following command\\\\\\n\\n\\n    $ npx hardhat test\\n\\n\\n\\nYou might want to make the script a bit shorter if you're using `yarn` or `npm` so open up your `package.json` file and add a script for it.\\\\\\n\\n\\n    // package.json\\n    {\\n        // ...  \\n\\n        \\\"scripts\\\": {\\n          \\\"test\\\": \\\"hardhat test\\\"\\n        },\\n\\n        // ...\\n    }\\n\\n\\n\\nAnd now we can run the tests by `yarn test` or `npm test` then we get the following result\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--XteRai-r--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m13w3tprwi45zy8ssyaa.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--XteRai-r--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m13w3tprwi45zy8ssyaa.png)\\n\\n### [](#writing-a-test-for-getmyluckynumber-function)Writing a test for getMyLuckyNumber function\\n\\nBefore we can assert `getMyLuckyNumber` we'll first have to save our lucky number into the smart contract to set the state in `ownerToLuckyNumber` and grab the value from there. For a short breakdown on what's happening on the test below. We have the contract deployed and we called `saveLuckyNumber` and pass down a value of `5` and once that's done we call `getMyLuckyNumber` and store it to a local variable `myLuckyNumber` we then proceed to assert and expect it to be not `undefined` and to be not `null` and finally since `uint256` is considered a `BigNumberish` type we just then convert it to a simple JavaScript friendly number by calling `toNumber` on object type `BigNumberish` which is our `myLuckyNumber` local variable. Then just expect it to equal to `5` because we previously called `saveLuckyNumber` with value of `5`.\\\\\\n\\n\\n    import { expect } from \\\"chai\\\";\\n    import { ethers } from \\\"hardhat\\\";\\n    import { Greeter } from \\\"../typechain\\\";\\n\\n    describe(\\\"Greeter\\\", function () {\\n      let contract: Greeter;\\n\\n      beforeEach(async () => {\\n        const Greeter = await ethers.getContractFactory(\\\"Greeter\\\");\\n        contract = await Greeter.deploy();\\n      });\\n\\n      // ...\\n\\n      describe(\\\"getMyLuckyNumber\\\", () => {\\n        it(\\\"should return 5 when given 5\\\", async () => {\\n          await contract.deployed();\\n\\n          await contract.saveLuckyNumber(5);\\n          const myLuckyNumber = await contract.getMyLuckyNumber();\\n\\n          expect(myLuckyNumber).to.be.not.undefined;\\n          expect(myLuckyNumber).to.be.not.null;\\n          expect(myLuckyNumber.toNumber()).to.equal(5);\\n        });\\n      });\\n\\n      // ...\\n    });\\n\\n\\n\\nNow run that test by `yarn test` or `npm test` then we get the results\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--gbSK4HEq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jvso9q3561w5z1kq4wxe.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--gbSK4HEq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jvso9q3561w5z1kq4wxe.png)\\n\\n### [](#writing-tests-for-saveluckynumber-function)Writing tests for saveLuckyNumber function\\n\\nNow here we can test out and expect reverts when a condition in the modifier does not satisfy.\\\\\\n\\n\\n    import { expect } from \\\"chai\\\";\\n    import { ethers } from \\\"hardhat\\\";\\n    import { Greeter } from \\\"../typechain\\\";\\n\\n    describe(\\\"Greeter\\\", function () {\\n      let contract: Greeter;\\n\\n      beforeEach(async () => {\\n        const Greeter = await ethers.getContractFactory(\\\"Greeter\\\");\\n        contract = await Greeter.deploy();\\n      });\\n\\n      // ...\\n\\n      describe(\\\"saveLuckyNumber\\\", () => {\\n        it(\\\"should revert with message 'Lucky number should not be 0.', when given 0\\\", async () => {\\n          await contract.deployed();\\n\\n          await expect(contract.saveLuckyNumber(0)).to.be.revertedWith(\\n            \\\"Lucky number should not be 0.\\\"\\n          );\\n        });\\n\\n        it(\\\"should revert with message 'You already have a lucky number.', when owner already have saved a lucky number\\\", async () => {\\n          await contract.deployed();\\n\\n          await contract.saveLuckyNumber(6);\\n\\n          await expect(contract.saveLuckyNumber(7)).to.be.revertedWith(\\n            \\\"You already have a lucky number.\\\"\\n          );\\n        });\\n\\n        it(\\\"should retrieve 66 when recently given lucky number is 66\\\", async () => {\\n          await contract.deployed();\\n\\n          await contract.saveLuckyNumber(66);\\n          const storedLuckyNumber = await contract.getMyLuckyNumber();\\n\\n          expect(storedLuckyNumber).to.be.not.undefined;\\n          expect(storedLuckyNumber).to.be.not.null;\\n          expect(storedLuckyNumber).to.be.not.equal(0);\\n          expect(storedLuckyNumber).to.be.equal(66);\\n        });\\n      });\\n\\n      // ...\\n    }); \\n\\n\\n\\nFor the first 2 tests, we intently make it fail by going against the modifiers that we defined. The modifiers are there to protect anything from unexpected behaviors, thus reverts it when it fails to satisfy the modifier.\\n\\nFor a breakdown of each test cases on `saveLuckyNumber`:\\n\\n*   On the first test case, we pass down a value of `0` into `saveLuckyNumber` and on the smart contract on `saveLuckyNumber` we have a modifier attached to the function prototype. It expects a lucky number value anything other than `0`. So when it's `0` it will always fail and will revert. Thus we have our expect assertion that the call will be reverted with the following message `\\\"Lucky number should not be 0.\\\"`.\\n*   On the second test case, on the `saveLuckyNumber` function again we have a modifier defined that they will never be able to set a new lucky number from calling `saveLuckyNumber` because it's going to check into the mapping `ownerToLuckyNumber` to see if they have already a lucky number stored. If they do we'll never allow it to update the state in `ownerToLuckyNumber` of their address. Thus reverting with message `\\\"You already have a lucky number.\\\"`\\n*   On the third test case, we just simply call and pass down a value of `66` to `saveLuckyNumber` and eventually just call `getMyLuckyNumber` and expect it to return `66`\\n\\nNow we'll run the tests again by `yarn test` or `npm test` and we have the following result\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--71z4llCj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4jhrrz29ltoug5ls2ndm.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--71z4llCj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4jhrrz29ltoug5ls2ndm.png)\\n\\n### [](#writing-tests-for-updateluckynumber)Writing tests for updateLuckyNumber\\n\\nFinally for the last function that we will be testing. This function allows the User to update their existing lucky number on-chain only if so they remember their previous lucky number. If they don't remember then they can just check for it by calling `getMyLuckyNumber`\\\\\\n\\n\\n    import { expect } from \\\"chai\\\";\\n    import { ethers } from \\\"hardhat\\\";\\n    import { Greeter } from \\\"../typechain\\\";\\n\\n    describe(\\\"Greeter\\\", function () {\\n      let contract: Greeter;\\n\\n      beforeEach(async () => {\\n        const Greeter = await ethers.getContractFactory(\\\"Greeter\\\");\\n        contract = await Greeter.deploy();\\n      });\\n\\n      // ...\\n\\n      describe(\\\"updateLuckyNumber\\\", () => {\\n        it(\\\"should revert with message '', when the given lucky number does not match with their existing lucky number\\\", async () => {\\n          await contract.deployed();\\n          await contract.saveLuckyNumber(6);\\n\\n          await expect(contract.updateLuckyNumber(8, 99)).to.be.revertedWith(\\n            \\\"Not your previous lucky number.\\\"\\n          );\\n        });\\n\\n        it(\\\"should update their lucky number, when given the exact existing lucky number stored\\\", async () => {\\n          await contract.deployed();\\n          await contract.saveLuckyNumber(2);\\n\\n          await contract.updateLuckyNumber(2, 22);\\n          const newLuckyNumber = await contract.getMyLuckyNumber();\\n\\n          expect(newLuckyNumber).to.be.not.undefined;\\n          expect(newLuckyNumber).to.be.not.null;\\n          expect(newLuckyNumber.toNumber()).to.be.equal(22);\\n        });\\n      });\\n    });\\n\\n\\n\\nTo break it down for you:\\n\\n*   On the first test, we intently make the test fail. Say for a given scenario the User forgets their previous lucky number saved on-chain. So it shouldn't allow them to update their lucky number. So in the test we'll make them save lucky number of `6` and then some time around in the future they want to update it. So we call `updateLuckyNumber` where we pass value of `8` as the first function argument which is their \\\"previous\\\" lucky number because they believe so it was `8` and `99` as the second function argument which is the new lucky number they want to replace. So the smart contract will most likely prevent updating the state or their lucky number stored on-chain. Now we can safely assert that it was reverted with the message `\\\"Not your previous lucky number.\\\"` (For now it's that, error message not too detailed but we're not concerned about good design in the scope of this tutorial)\\n*   On the second test, say User actually remembered their previous lucky number and they want to update it to a new lucky number. Then we assert the new lucky number which has a value of `22`\\n\\nFinally we'll run the tests one more time\\n\\n[![Image description](https://res.cloudinary.com/practicaldev/image/fetch/s--9DyhF0Zv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/phaj9nti1gvurx026h6f.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--9DyhF0Zv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/phaj9nti1gvurx026h6f.png)\\n\\nAnd every thing passed! That gave us the assurance that our smart contract works as what we expect it to do. So that's a wrap!\\n\\n## [](#conclusion)Conclusion\\n\\nWe've covered creating a new project and a setup for Hardhat using the template that they provided which was extremely cool where we don't have to worry as much setting up those configurations ourselves. We've also learned how to make assertions in Chai and to expect certain values and expect a reversion with a revert message. And finally we notice how Typechain is working so well, it does most of the work for us by generating those types automatically every time we compile the smart contract, that was very convenient!\\n\\nThat's it for me, I hope you enjoy reading and hope that you learned something. Thanks for reading up until this point, have a good day and cheers!\\n\\nIf you haven't already joined a DAO, join your first DAO by going here [@developer_dao](https://twitter.com/developer_dao) go and mint your DAO NFT, get a pixel avatar and vibe into the Discord channel. See you there!\\n\\nIf you might have any questions or suggestions feel free to drop comments below I'd be happy!\\n\\nFull source code available in the [repository](https://github.com/carlomigueldy/tut-solidity-chai-testing)\\n\",\"timestamp\":1636676390,\"title\":\"Unit Testing a Solidity Smart Contract using Chai & Mocha with TypeScript\"},\"digest\":\"9wd8ae0qkJ11MiVoOQ1vXZtZ1Yk-9RFmjK3L4of5htY\",\"authorship\":{\"contributor\":\"0x3E8c686F499C877D8f4aFB1215b6f0935796b986\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"signature\":\"EksWMqMw-DhmXLY01ZwE11_zUYd6z-0tEnYQ-9wF0n9DT8wsvy8bD7WB0bw0ZnFP0uhhCRdUTD_pnLJBrGAXLg\",\"signingKeySignature\":\"0xc823d2ab2ee5864fc5495382efb960b4461c3fb598b3be4e5e068c6312ab60ce014c7378c1f02beed8fce37236dc1e3eb8dd28a6f911b33ec4172a1fa8b17f101b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"9wd8ae0qkJ11MiVoOQ1vXZtZ1Yk-9RFmjK3L4of5htY\"}"