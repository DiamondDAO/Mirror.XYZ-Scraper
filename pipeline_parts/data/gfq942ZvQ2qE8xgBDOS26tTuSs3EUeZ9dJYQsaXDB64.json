"{\"content\":{\"body\":\"I came across this topic while reading the phenomenal ‚ÄúMastering Ethereum‚Äù and thought it was worth writing a small post about it.\\n\\nFrom the book:\\n\\n> Solidity offers some even more ‚Äúlow-level‚Äù functions for calling other contracts. \\n These correspond directly to EVM opcodes of the same name and allow us to construct a contract-to-contract call manually.\\n\\nThese 2 functions are `call` and `delegatecall` and the main difference is that the latter doesn‚Äôt change the `msg` context at all.\\n\\nLet‚Äôs see a quick example to illustrate this difference:\\n\\n```\\npragma solidity ^0.8.10;\\n\\ncontract Called {\\n  event callEvent(address sender, address origin, address from);\\n  function callMe() public {\\n    emit callEvent(msg.sender, tx.origin, address(this));\\n  }\\n}\\n\\ncontract Caller {\\n  function makeCalls(address _contractAddress) public {   address(_contractAddress).call(abi.encodeWithSignature(\\\"callMe()\\\"));\\n  address(_contractAddress).delegatecall(abi.encodeWithSignature(\\\"callMe()\\\"));\\n  }\\n}\\n```\\n\\nIn the example above `Caller` interacts with `Called`‚Äôs `callMe` function in 2 different ways: one using `call`, another one using `delegatecall`.\\n\\n`callMe` will emit a `callEvent` every time it‚Äôs called so we can inspect what the context (`msg`, `tx` and `this`) looks like in both scenarios.\\n\\nIn order to test this out, I created a simple script in [Hardhat](https://hardhat.org) to compile both contracts, perform the calls and inspect the events to see how they look:\\n\\n```\\n$> mkdir call_tests && cd call_tests\\n$> npx hardhat\\n```\\n\\n`scripts/makeCall.js` üëáüèΩ\\n\\n```\\n  const hre = require('hardhat');\\n\\n  const main = async () => {\\n    const LibraryFactory = await hre.ethers.getContractFactory('CalledLibrary');\\n    const library = await LibraryFactory.deploy();\\n    const CallerFactory = await hre.ethers.getContractFactory('Caller', {\\n      libraries: {\\n        CalledLibrary: library.address,\\n      },\\n    });\\n    const CalledFactory = await hre.ethers.getContractFactory('Called');\\n\\n    const caller = await CallerFactory.deploy();\\n    const called = await CalledFactory.deploy();\\n\\n    const tx = await caller.makeCalls(called.address);\\n    const res = await tx.wait();\\n\\n    const eventAbi = [\\n      'event callEvent(address sender, address origin, address from)',\\n    ];\\n    const iface = new hre.ethers.utils.Interface(eventAbi);\\n\\n    const signer = await hre.ethers.getSigner();\\n\\n    console.log(`EOA address: ${signer.address}`);\\n    console.log(`Caller contract address: ${caller.address}`);\\n    console.log(`Called contract address: ${called.address}`);\\n\\n    res.events.map(event => console.log(iface.parseLog(event)));\\n  };\\n\\n  main();\\n```\\n\\nThe script above will deploy both `Caller` and `Called` contracts and then it will call `makeCalls` function from `Caller`.\\n\\nAfter waiting for the transaction to be confirmed, it logs the events that were fired and 3 addresses: the account that sent the transaction, and the contracts‚Äô. This will allow us to inspect the context of each call.\\n\\nTo run the script:\\n\\n```\\n$> npx hardhat run scripts/makeCalls.js\\n```\\n\\nwhich will print something like this (I trimmed the output and addresses to make it more readable):\\n\\n```\\nEOA address: 0xf39F...2266\\nCaller contract address: 0xe7f1...512\\nCalled contract address: 0x9fE4...6e0\\n\\nLogDescription {\\n  ...,\\n  args: [\\n    ...,\\n    sender: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',\\n    origin: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\\n    from: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0'\\n  ]\\n}\\nLogDescription {\\n  ...,\\n  args: [\\n    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\\n    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\\n    '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',\\n    sender: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\\n    origin: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\\n    from: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'\\n  ]\\n}\\n```\\n\\nOk, let‚Äôs see what happened.\\n\\nBoth event logs. displayed above were fired from the same contract, `Called`. BUT, as you can see, the context is quite different.\\n\\nThe first one was fired after `Caller` contract executed `Called`‚Äôs `callMe()` function, by using `call` .\\n\\nIn this case:\\n\\n1. `sender` is the `Caller` contract.\\n2. `origin` is the account who sent the transaction to execute `Caller.makeCalls`.\\n3. `from` is the `Called` contract.\\n\\nThis is all what you might be expecting. The origin is always the EOA, `msg.sender` is the address from where a particular function is being called, and `this` (`from`, in the logs) is the contract you‚Äôre referring too.\\n\\nLet‚Äôs see how the other event looks like, then:\\n\\n1. `sender` is the EOA!\\n2. `origin` is also the EOA!\\n3. `from` is the `Caller` contract, instead of `Called` (the contract which is actually emitting the event).\\n\\nWhat happened?\\n\\nWhat happened is that when you call another contract‚Äôs function using `delegatecall` it actually inherits the execution context of the contract who is performing the call, in this case `Caller`.\\n\\nThe context will behave as if you‚Äôve copied and pasted the `callMe()` function into `Caller`‚Äôs contract.\\n\\n## Conclusion\\n\\n* `call` and `delegate` call are flexible but also dangerous ways of interacting with other contracts, we must use them with caution. They‚Äôre both ‚Äúblind‚Äù calls into a function and they can expose your contract to security risks.\\n* the main difference between them is that while `call` just executes the function **in the context of the contract it was defined**, `calldelegate` inherits the execution context, meaning that the function will behave as it was defined in the contract that‚Äôs using `calldelegate`.\",\"timestamp\":1642433882,\"title\":\"Solidity: `call` vs `delegatecall`\"},\"digest\":\"5RObAeE1sPNeEzyGU9gU0olBtVJqnj0MYkJCVtVNGV0\",\"authorship\":{\"contributor\":\"0x9b43748a60954F36A6547C5d653951532Af242e6\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"O4NF78OfZapgeKROJUZzyzyj0txoBEW5zp9ycJZ4vrg\\\",\\\"y\\\":\\\"xUgBpmWJW_8499C_qAG32a10b8RromdkVvITlMj8E5E\\\"}\",\"signature\":\"E4BnO-vo1K2O14fADUKh71zF5CV8nDOCkH0Cy_IyyepX-f4xraprLjHJ9XeblYAdDUm-3zHlKCjspDYb5PpKFw\",\"signingKeySignature\":\"0xa88aa59c9df415259fd78d93d5ab33e1ac8382f4cbbee401e5a1633e9fc782c374e25f235c06027e87b83aeb81423df6a2aab5c840ff8cf3b85d50a85c2f70c91b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"O4NF78OfZapgeKROJUZzyzyj0txoBEW5zp9ycJZ4vrg\\\",\\\"y\\\":\\\"xUgBpmWJW_8499C_qAG32a10b8RromdkVvITlMj8E5E\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"5RObAeE1sPNeEzyGU9gU0olBtVJqnj0MYkJCVtVNGV0\"}"