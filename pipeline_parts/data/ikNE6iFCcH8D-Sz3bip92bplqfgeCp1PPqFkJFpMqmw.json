"{\"content\":{\"body\":\"## [](#introduction)Introduction\\n\\nIn this post we'll cover how you can create a data model using [freezed](https://pub.dev/packages/freezed) package in Flutter and learn about a few techniques that I know and have been using when building projects. We will be using [JSONPlacheolder](https://jsonplaceholder.typicode.com/) to consume a REST API with [dio](https://pub.dev/packages/dio) as our HTTP client and create a data model for the `/users` endpoint to the Flutter application.\\n\\nData modeling is a process of creating a visual representation of information that describes the a business entity of a software project. It is a technique that is being often used in most applications. A data model can also represent relationship between each business entities. Or if you know about relational databases then for a quick comparison, a data model can be an SQL table that represents it.\\n\\nYou can read more in depth about [data modeling here](https://www.ibm.com/cloud/learn/data-modeling)\\n\\n## [](#installation)Installation\\n\\nFirst we will begin with installing a fresh Flutter project, so go over and open up your terminal and execute the following command below.\\\\\\n\\n\\n    flutter create freezed_data_modeling\\n\\n\\n\\nThen open the project in your IDE (Visual Studio Code) and open up the `pubspec.yaml` file and add up the following dependencies that we require,\\n\\n*   dependencies:\\n\\n    *   freezed_annotation\\n\\n*   dev_dependencies:\\n\\n    *   build_runner\\n    *   freezed\\n\\n<!---->\\n\\n    dependencies:\\n      flutter:\\n        sdk: flutter\\n      freezed_annotation:\\n        dio:\\n\\n      # The following adds the Cupertino Icons font to your application.\\n      # Use with the CupertinoIcons class for iOS style icons.\\n      cupertino_icons: ^1.0.2\\n\\n    dev_dependencies:\\n      flutter_test:\\n        sdk: flutter\\n      build_runner:\\n      freezed:\\n\\n\\n\\nAnd finally execute `flutter pub get` when you've added those dependencies.\\n\\nNext you can launch an emulator and run the project in it, but you can do it later.\\n\\n## [](#jsonplaceholder-response)JSONPlaceholder response\\n\\nBefore we start creating our data models, we should know what resources are getting returned to the application. It wouldn't make sense to create data models when the data model you created does not reflect in the backend. Take a look at it carefully and identify which properties are of type `String` , `double` , `int` , and etc.\\\\\\n\\n\\n    // https://jsonplaceholder.typicode.com/users\\n    [\\n      {\\n        \\\"id\\\": 1,\\n        \\\"name\\\": \\\"Leanne Graham\\\",\\n        \\\"username\\\": \\\"Bret\\\",\\n        \\\"email\\\": \\\"Sincere@april.biz\\\",\\n        \\\"address\\\": {\\n          \\\"street\\\": \\\"Kulas Light\\\",\\n          \\\"suite\\\": \\\"Apt. 556\\\",\\n          \\\"city\\\": \\\"Gwenborough\\\",\\n          \\\"zipcode\\\": \\\"92998-3874\\\",\\n          \\\"geo\\\": {\\n            \\\"lat\\\": \\\"-37.3159\\\",\\n            \\\"lng\\\": \\\"81.1496\\\"\\n          }\\n        },\\n        \\\"phone\\\": \\\"1-770-736-8031 x56442\\\",\\n        \\\"website\\\": \\\"hildegard.org\\\",\\n        \\\"company\\\": {\\n          \\\"name\\\": \\\"Romaguera-Crona\\\",\\n          \\\"catchPhrase\\\": \\\"Multi-layered client-server neural-net\\\",\\n          \\\"bs\\\": \\\"harness real-time e-markets\\\"\\n        }\\n      },\\n\\n      ...\\n    ]\\n\\n\\n\\nWhen taking a closer look at it we can identify the following,\\n\\n*   `id` is of type `int` because it returns a single digit\\n\\n*   `name` contains various characters, so this is a `String`\\n\\n*   `username` is a `String`\\n\\n*   `email` is a `String`\\n\\n*   `address` is a JSON object, so we'll require to create its own data model as well because we don't wanna put up a type for that as `Map<String, dynamic>` that would make less robust\\n\\n    So let's identify the property types for each property in `address` field:\\n\\n    *   `street` is a `String`\\n\\n    *   `suite` is a `String`\\n\\n    *   `city` is a `String`\\n\\n    *   `zipcode` is a `String`\\n\\n    *   `geo` is another JSON object, so we'll do the same thing as what we are currently doing for `address`\\n\\n        *   `lat` can be a `String` but since we know it is \\\"latitude\\\" and usually they are in decimal values, so we'll use `double` for that instead\\n        *   `lng` is `double`\\n\\n*   `phone` is a `String`\\n\\n*   `website` is a `String`\\n\\n*   `company` is a JSON object\\n\\n    *   `name` is a `String`\\n    *   `catchPhrase` is a `String`\\n    *   `bs` is a `String`\\n\\n## [](#creating-a-data-model-without-freezed)Creating a data model without freezed\\n\\nUsually when we start to create our data models is that we use this approach, also means that we are writing out a lot of \\\"boilerplate\\\" code which isn't very ideal when you have a large complex application. One could be spending a lot of time just writing up data models this way, manually adding method calls like `toJson()` to convert the data model into a JSON format which is the typical format we use when we are creating requests to a REST API, GraphQL API or any sort of backend service that you could be using.\\\\\\n\\n\\n    class Geo {\\n      final double lat;\\n      final double lng;\\n\\n      Geo({\\n        this.lat = 0.0,\\n        this.lng = 0.0,\\n      });\\n\\n      Map<String, dynamic> toJson() {\\n        return {\\n          'lat': lat,\\n          'lng': lng,\\n        };\\n      }\\n    }\\n\\n    class Address {\\n      final String? street;\\n      final String? suite;\\n      final String? city;\\n      final String? zipcode;\\n\\n      Address({\\n        this.street,\\n        this.suite,\\n        this.city,\\n        this.zipcode,\\n      });\\n\\n      Map<String, dynamic> toJson() {\\n        return {\\n          'street': street,\\n          'suite': suite,\\n          'city': city,\\n          'zipcode': zipcode,\\n        };\\n      }\\n    }\\n\\n    class Company {\\n      final String? name;\\n      final String? catchPhrase;\\n      final String? bs;\\n\\n      Company({\\n        this.name,\\n        this.catchPhrase,\\n        this.bs,\\n      });\\n\\n      Map<String, dynamic> toJson() {\\n        return {\\n          'name': name,\\n          'catchPhrase': catchPhrase,\\n          'bs': bs,\\n        };\\n      }\\n    }\\n\\n    class User {\\n      final int id;\\n      final String? username;\\n      final String? email;\\n      final Address? address;\\n      final String? phone;\\n      final String? website;\\n      final Company? company;\\n\\n      User({\\n        required this.id,\\n        this.username,\\n        this.email,\\n        this.address,\\n        this.phone,\\n        this.website,\\n        this.company,\\n      });\\n\\n      Map<String, dynamic> toJson() {\\n        return {\\n          'id': id,\\n          'username': username,\\n          'email': email,\\n          'address': address?.toJson(),\\n          'phone': phone,\\n          'website': website,\\n          'company': company?.toJson(),\\n        };\\n      }\\n    }\\n\\n\\n\\nThis would take up a lot of your time and could even be counterproductive for you as a developer.\\n\\nAlso notice how I am putting up with the `?` annotation in each of the properties since they could potentially be `null` and that would be considered a bug and will produce crashes in the application during run time or if when our users are using our application.\\n\\nYou can learn more about [null-safety here](https://flutter.dev/docs/null-safety)\\n\\nThere are quite a lot of problems that this gives us when writing our applications since there comes a point where when we will have to copy all values and replace with a new value. In JavaScript we can simply do that with the \\\"triple dot\\\" notation to create a new object from an existing object.\\\\\\n\\n\\n    const person = {\\n      name: \\\"Carlo Miguel Dy\\\",\\n      age: 23,\\n    }\\n\\n    console.log(person)\\n    // { \\\"name\\\": \\\"Carlo Miguel Dy\\\", \\\"age\\\": 23 }\\n\\n    const newPerson = {\\n      ...person,\\n      name: \\\"John Doe\\\",\\n    }\\n\\n    console.log(newPerson)\\n    // { \\\"name\\\": \\\"John Doe\\\", \\\"age\\\": 23 }\\n\\n\\n\\nBut unfortunately we can't do that with Dart yet. We can do that but it's quite a lot of \\\"boilerplate\\\" code.\\n\\n## [](#creating-a-data-model-with-freezed)Creating a data model with freezed\\n\\nA lot of the \\\"boilerplate\\\" code is eliminated when we are using the `freezed` package, what it does is it generates all those \\\"boilerplate\\\" code for us, we can also make use of its annotations which comes very handy. To mention a few these are `@Default` for providing a default value when this property is `null` and we also use `@JsonKey` to override the JSON key just in case the conventions is different from the backend. Some do use `camelCasing` , `snake_casing` and `PascalCasing` so these are the kind of problem it can solve with only a few lines of code.\\\\\\n\\n\\n    import 'package:freezed_annotation/freezed_annotation.dart';\\n\\n    part 'freezed_datamodels.freezed.dart';\\n    part 'freezed_datamodels.g.dart';\\n\\n    @freezed\\n    class Geo with _$Geo {\\n      const factory Geo({\\n        @Default(0.0) double lat,\\n        @Default(0.0) double lng,\\n      }) = _Geo;\\n\\n      factory Geo.fromJson(Map<String, dynamic> json) => _$GeoFromJson(json);\\n    }\\n\\n    @freezed\\n    class Address with _$Address {\\n      const factory Address({\\n        @Default('') String street,\\n        @Default('') String suite,\\n        @Default('') String city,\\n        @Default('') String zipcode,\\n        Geo? geo,\\n      }) = _Address;\\n\\n      factory Address.fromJson(Map<String, dynamic> json) =>\\n          _$AddressFromJson(json);\\n    }\\n\\n    @freezed\\n    class Company with _$Company {\\n      const factory Company({\\n        @Default('') String name,\\n        @Default('') String catchPhrase,\\n        @Default('') String bs,\\n      }) = _Company;\\n\\n      factory Company.fromJson(Map<String, dynamic> json) =>\\n          _$CompanyFromJson(json);\\n    }\\n\\n    @freezed\\n    class User with _$User {\\n      const factory User({\\n        required int id,\\n        required String username,\\n        required String email,\\n        Address? address,\\n        @Default('') String phone,\\n        @Default('') String website,\\n        Company? company,\\n      }) = _User;\\n\\n      factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\\n    } \\n\\n\\n\\nWe only have to write a few lines of code to create the data models and we are utilizing on the annotations that the `freezed` package provides for us.\\n\\nTo break down each data model I defined above for you,\\n\\n*   `Geo`\\n\\n    *   The `lat` property is non-nullable but has a default value of `0.0` when this value is empty\\n    *   The `lng` property is non-nullable but has a default value of `0.0` when this value is empty\\n\\n*   `Address`\\n\\n    *   The `street` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `suite` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `city` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `zipcode` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n\\n*   `Company`\\n\\n    *   The `name` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `catchPhrase` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `bs` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n\\n*   `User`\\n\\n    *   The `id` property is non-nullable but is `required` and this property should never be `null`\\n    *   The `username` property is non-nullable but is `required` and this property should never be `null`\\n    *   The `email` property is non-nullable but is `required` and this property should never be `null`\\n    *   The `address` property is nullable\\n    *   The `phone` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `website` property is non-nullable but has a default value of `''` which means it will be an empty string when this value is empty\\n    *   The `company` property is nullable\\n\\n## [](#generating-code-using-buildrunner-package)Generating code using build_runner package\\n\\nAs the code snippet above you will notice that we have 2 lines of code that uses `part` and it contains `freezed` and `g` these are the ones that will let `freezed` package to recognize that it requires to generate a code whenever we execute the `build_runner` to build generate code for us.\\n\\nTo start generating code for us, execute the following command with-in the root directory of your Flutter project.\\\\\\n\\n\\n    flutter pub run build_runner build --delete-conflicting-outputs\\n\\n\\n\\nTo break it down what each does, the `flutter pub run` will allow us to run script coming from a package like `build_runner` and the `build` is the command or script to tell the `build_runner` package to start generating code for us. It will look for files that contains the following `*.freezed.dart` and `*.g.dart` the `*` is just a wild card that means any file name that contains it will be recognized by the `build_runner` and lastly the `--delete-conflicting-outputs` flag will tell the `build_runner` package to delete any existing `*.freezed.dart` and `*.g.dart` files to prevent duplicate outputs or that it could potentially conflict with those.\\n\\nSo every time you might have to update your data model with new properties, you will always have to execute this the command snippet above to tell `build_runner` to generate code for us.\\n\\nYou can take a peek at what code was generated from the repository or directly from the links below:\\n\\n*   [freezed_datamodels.freezed.dart](https://github.com/carlomigueldy/freezed_data_modeling/blob/main/lib/models/freezed_datamodels.freezed.dart)\\n*   [freezed_datamodels.g.dart](https://github.com/carlomigueldy/freezed_data_modeling/blob/main/lib/models/freezed_datamodels.g.dart)\\n\\n## [](#copying-values-from-a-data-model-but-only-change-values-of-specific-properties)Copying values from a data model but only change values of specific properties\\n\\nComing back with copying values of an object in JavaScript, we can now simply do that as well with our data model that is using the `freezed` package.\\\\\\n\\n\\n    final person = User(\\n      id: 1,\\n      username: 'carlomigueldy',\\n      email: 'carlomigueldy@gmail.com',\\n    );\\n\\n    person.toJson();\\n    // { \\\"id\\\": 1, \\\"username\\\": \\\"carlomigueldy\\\", \\\"email\\\": \\\"carlomigueldy@gmail.com\\\", ... }\\n\\n    final newPerson = person.copyWith(\\n      username: 'johndoe123',\\n    );\\n\\n    newPerson.toJson();\\n    // { \\\"id\\\": 1, \\\"username\\\": \\\"johndoe123\\\", \\\"email\\\": \\\"carlomigueldy@gmail.com\\\", ... }\\n\\n\\n\\nThat's really powerful.\\n\\n## [](#consuming-the-rest-api)Consuming the REST API\\n\\nWe just got a basic application installed, so remove all those comments that make the code too long in `main.dart` file.\\\\\\n\\n\\n    import 'package:flutter/material.dart';\\n\\n    void main() {\\n      runApp(MyApp());\\n    }\\n\\n    class MyApp extends StatelessWidget {\\n      // This widget is the root of your application.\\n      @override\\n      Widget build(BuildContext context) {\\n        return MaterialApp(\\n          title: 'Flutter Demo',\\n          theme: ThemeData(\\n            primarySwatch: Colors.blue,\\n          ),\\n          home: MyHomePage(title: 'Flutter Demo Home Page'),\\n        );\\n      }\\n    }\\n\\n    class MyHomePage extends StatefulWidget {\\n      MyHomePage({Key? key, required this.title}) : super(key: key);\\n\\n      final String title;\\n\\n      @override\\n      _MyHomePageState createState() => _MyHomePageState();\\n    }\\n\\n    class _MyHomePageState extends State<MyHomePage> {\\n      int _counter = 0;\\n\\n      void _incrementCounter() {\\n        setState(() {\\n          _counter++;\\n        });\\n      }\\n\\n      @override\\n      Widget build(BuildContext context) {\\n        return Scaffold(\\n          appBar: AppBar(\\n            title: Text(widget.title),\\n          ),\\n          body: Center(\\n            child: Column(\\n              mainAxisAlignment: MainAxisAlignment.center,\\n              children: <Widget>[\\n                Text(\\n                  'You have pushed the button this many times:',\\n                ),\\n                Text(\\n                  '$_counter',\\n                  style: Theme.of(context).textTheme.headline4,\\n                ),\\n              ],\\n            ),\\n          ),\\n          floatingActionButton: FloatingActionButton(\\n            onPressed: _incrementCounter,\\n            tooltip: 'Increment',\\n            child: Icon(Icons.add),\\n          ),\\n        );\\n      }\\n    }\\n\\n\\n\\nCreate a final field with type `Dio` and instantiate it with a new `Dio` instance, then create a function called `fetchUsers` that will fetch data from this endpoint [`https://jsonplaceholder.typicode.com/users`](https://jsonplaceholder.typicode.com/users) and set it in a private property with type `List<User>` called as `_users` , we can call this function when you will click on the `FloatingActionButton` or for call this function inside the `initState` lifecycle hook of a `StatefulWidget` , for convenience I will just have the code here below for you to reference on if you prefer to write it out yourself. But the full source code will be found in the repository for a better reference.\\\\\\n\\n\\n    class MyHomePage extends StatefulWidget {\\n      MyHomePage({Key? key, required this.title}) : super(key: key);\\n\\n      final String title;\\n\\n      @override\\n      _MyHomePageState createState() => _MyHomePageState();\\n    }\\n\\n    class _MyHomePageState extends State<MyHomePage> {\\n      final Dio dio = Dio();\\n      List<User> _users = [];\\n\\n      Future<void> fetchUsers() async {\\n        final response = await dio.get(\\n          'https://jsonplaceholder.typicode.com/users',\\n        );\\n        print(response.data);\\n        final List list = response.data;\\n\\n        setState(() {\\n          _users = list.map((e) => User.fromJson(e)).toList();\\n        });\\n      }\\n\\n      @override\\n      void initState() {\\n        fetchUsers();\\n\\n        super.initState();\\n      }\\n\\n      @override\\n      Widget build(BuildContext context) {\\n        return Scaffold(\\n          appBar: AppBar(\\n            title: Text(widget.title),\\n          ),\\n          body: ListView.builder(\\n            itemCount: _users.length,\\n            itemBuilder: (context, index) {\\n              final user = _users[index];\\n\\n              return ListTile(\\n                title: Text(user.username),\\n                subtitle: Text(user.email),\\n              );\\n            },\\n          ),\\n          floatingActionButton: FloatingActionButton(\\n            onPressed: fetchUsers,\\n            tooltip: 'Fetch Users',\\n            child: Icon(Icons.data_usage),\\n          ),\\n        );\\n      }\\n    }\\n\\n\\n\\nWhen you have this correctly in your code then it should look very similar to this screenshot.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--vgCw5i3u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8mvv1n5a5q33mevmwswo.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--vgCw5i3u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8mvv1n5a5q33mevmwswo.png)\\n\\n## [](#using-copywith-method-from-a-data-model)Using \\\"copyWith\\\" method from a data model\\n\\nNow let's make it a bit interesting, this is not a very practical approach when building out your applications but it will give you an idea and on how you can make use of this. There are a lot of use cases that you might require to use `copWith` method from a `freezed` data model.\\n\\nFor the sake of demonstration purposes, we will implement the following for when a user taps on any of the `ListTile` under the `ListView` we will change the value of the `username` property and append a string with value of \\\" CLICKED\\\", so for instance when \\\"Bret\\\" is tapped then we will have it display \\\"Bret CLICKED\\\". To put things into action, let's create a function that will take an argument as the index of that item of a `ListTile` then attach it on to the `onTap` property of a `ListTile` and just pass in the current `index` of that item.\\\\\\n\\n\\n    void appendUsername(int index) {\\n        setState(() {\\n          _users[index] = _users[index].copyWith(\\n            username: '${_users[index].username} CLICKED',\\n          );\\n        });\\n      }\\n\\n    // ... \\n\\n    body: ListView.builder(\\n            itemCount: _users.length,\\n            itemBuilder: (context, index) {\\n              final user = _users[index];\\n\\n              return ListTile(\\n                title: Text(user.username),\\n                subtitle: Text(user.email),\\n                onTap: () => appendUsername(index),\\n              );\\n            },\\n          ),\\n\\n\\n\\nThen we'll have the following output when any of the `ListTile` is tapped.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--FX5pGcQl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ivr1mldz020csa5wsivr.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--FX5pGcQl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ivr1mldz020csa5wsivr.png)\\n\\n## [](#example-usage-for-raw-jsonkey-endraw-annotation)Example usage for `@JsonKey` annotation\\n\\nThere are certain cases that we can make use of `@JsonKey` annotation when creating our data models, say we have this data model and we have a property named as `catchPhrase` when this gets generated from the `build_runner` package, the JSON property will be equivalent to `catchPhrase` so basically it will result to something like this `json['catchPhrase']`\\n\\nIn the current API we will be consuming, there'd be no problem since it uses `camelCasing` convention so we can just have that as is\\n\\nBut what happens if the API will have different set of conventions, and we don't do something about it, so eventually our property `catchPhrase` in our `Company` data model will always be `null` since it will never match `CatchPhrase` or `catch_phrase` that is returned in the application when it is trying to retrieve its value by `json['catchPhrase']`\\\\\\n\\n\\n    @freezed\\n    class Company with _$Company {\\n      const factory Company({\\n        @Default('') String name,\\n        @Default('') String catchPhrase,\\n        @Default('') String bs,\\n      }) = _Company;\\n\\n      factory Company.fromJson(Map<String, dynamic> json) =>\\n          _$CompanyFromJson(json);\\n    }\\n\\n\\n\\nSo to fix that we will make use of the `@JsonKey` annotation, just add it before the `@Default` annotation in this case, then we can specify the JSON object property name like so\\\\\\n\\n\\n    @freezed\\n    class Company with _$Company {\\n      const factory Company({\\n        @Default('') String name,\\n        @JsonKey(name: 'catch_phrase') @Default('') String catchPhrase,\\n        @Default('') String bs,\\n      }) = _Company;\\n\\n      factory Company.fromJson(Map<String, dynamic> json) =>\\n          _$CompanyFromJson(json);\\n    }\\n\\n\\n\\nThen whenever we call `Company.fromJson(json)` it will parse that coming from a JSON format into the actual `Company` data model that we defined into our application. Instead of having it retrieve by `json['catchPhrase']` we now retrieving it by what we defined in the `name` property of the `@JsonKey` annotation so in this case it will be `json['catch_phrase']`\\n\\nI hope that makes sense.\\n\\nAnother way of how we can make use of it is when we require to convert a property into a JSON format. For example, for our `User` data model it contains a property for `Company` data model and an `Address` data model. So when we print it out we will have the following value.\\\\\\n\\n\\n    // Where `user` is of type `User`\\n\\n    print(user.toJson());\\n    // {id: 4, username: Karianne, email: Julianne.OConner@kory.org, address: Address(street: Hoeger Mall, suite: Apt. 692, city: South Elvis, zipcode: 53919-4257), phone: 493-170-9623 x156, website: kale.biz, company: Company(name: Robel-Corkery, catchPhrase: Multi-tiered zero tolerance productivity, bs: transition cutting-edge web services)}\\n\\n\\n\\nYou will notice that the `address` property is not in its JSON format, it has the following value instead which tells us it is a class with the its corresponding property and values. Which isn't very ideal whenever we will have to pass this information back into the API, it will throw an exception instead. But this doesn't happen to often when you have to pass back a huge payload to the API.\\\\\\n\\n\\n    address: Address(street: Hoeger Mall, suite: Apt. 692, city: South Elvis, zipcode: 53919-4257)\\n\\n\\n\\nThe way we can fix that up is by using the property `fromJson` and `toJson` converters from the `@JsonKey` annotation. We declare it again before the `@Default` annotation when there exists, otherwise it's just the same spot before the actual property.\\\\\\n\\n\\n    @freezed\\n    class User with _$User {\\n      const User._();\\n      const factory User({\\n        required int id,\\n        required String username,\\n        required String email,\\n        @JsonKey(\\n          fromJson: User._addressFromJson,\\n          toJson: User._addressToJson,\\n        )\\n            Address? address,\\n        @Default('')\\n            String phone,\\n        @Default('')\\n            String website,\\n        @JsonKey(\\n          fromJson: User._companyFromJson,\\n          toJson: User._companyToJson,\\n        )\\n            Company? company,\\n      }) = _User;\\n\\n      static Address? _addressFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Address.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _addressToJson(Address? address) {\\n        if (address == null) return null;\\n\\n        return address.toJson();\\n      }\\n\\n      static Company? _companyFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Company.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _companyToJson(Company? company) {\\n        if (company == null) return null;\\n\\n        return company.toJson();\\n      }\\n\\n      factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\\n    }\\n\\n\\n\\nTo break it down for you,\\n\\nThe `address` we used the `@JsonKey` annotation and passed down the properties for `fromJson` with what we defined as a `static` member of the class which returns the same type of what the property `address` has (`Address?`) which is of type `Address` but is nullable. As per `freezed` package instructions on accessing the same member of the class, it is required that we will have to call this `const User._();`\\\\\\n\\n\\n    @freezed\\n    class User with _$User {\\n      const User._();\\n\\n      const factory User({\\n          // ...\\n        @JsonKey(\\n          fromJson: User._addressFromJson,\\n          toJson: User._addressToJson,\\n        )\\n            Address? address,\\n            // ...\\n      }) = _User;\\n\\n      static Address? _addressFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Address.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _addressToJson(Address? address) {\\n        if (address == null) return null;\\n\\n        return address.toJson();\\n      }\\n\\n        // ...\\n    }\\n\\n\\n\\nThe private static method `_addressFromJson` takes a first argument of type `Map<String, dynamic>` which represents a JSON value and is nullable, then in this method we check if the `json` argument is `null` and if that evaluates to `true` then we'll just return `null` otherwise we can call `Address.fromJson(json)` and have it return an instance of a data model `Address` that we defined.\\\\\\n\\n\\n    static Address? _addressFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Address.fromJson(json);\\n      }\\n\\n\\n\\nThe private static method `_addressToJson` takes a first argument of type `Address` which the data model that we defined is nullable, then in this method we check if the `address` argument is `null` and if that evaluates to `true` then we'll just return `null` otherwise we can call `address.toJson()` and have it return a JSON representation of it.\\\\\\n\\n\\n    static Map<String, dynamic>? _addressToJson(Address? address) {\\n        if (address == null) return null;\\n\\n        return address.toJson();\\n      }\\n\\n\\n\\n## [](#finalizing-our-data-models)Finalizing our data models\\n\\n    import 'package:freezed_annotation/freezed_annotation.dart';\\n\\n    part 'freezed_datamodels.freezed.dart';\\n    part 'freezed_datamodels.g.dart';\\n\\n    @freezed\\n    class Geo with _$Geo {\\n      const factory Geo({\\n        @Default(0.0) double lat,\\n        @Default(0.0) double lng,\\n      }) = _Geo;\\n\\n      factory Geo.fromJson(Map<String, dynamic> json) => _$GeoFromJson(json);\\n    }\\n\\n    @freezed\\n    class Address with _$Address {\\n      const Address._();\\n      const factory Address({\\n        @Default('')\\n            String street,\\n        @Default('')\\n            String suite,\\n        @Default('')\\n            String city,\\n        @Default('')\\n            String zipcode,\\n        @JsonKey(\\n          fromJson: Address._geoFromJson,\\n          toJson: Address._geoToJson,\\n        )\\n            Geo? geo,\\n      }) = _Address;\\n\\n      static Geo? _geoFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Geo.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _geoToJson(Geo? geo) {\\n        if (geo == null) return null;\\n\\n        return geo.toJson();\\n      }\\n\\n      factory Address.fromJson(Map<String, dynamic> json) =>\\n          _$AddressFromJson(json);\\n    }\\n\\n    @freezed\\n    class Company with _$Company {\\n      const factory Company({\\n        @Default('') String name,\\n        @Default('') String catchPhrase,\\n        @Default('') String bs,\\n      }) = _Company;\\n\\n      factory Company.fromJson(Map<String, dynamic> json) =>\\n          _$CompanyFromJson(json);\\n    }\\n\\n    @freezed\\n    class User with _$User {\\n      const User._();\\n      const factory User({\\n        required int id,\\n        required String username,\\n        required String email,\\n        @JsonKey(\\n          fromJson: User._addressFromJson,\\n          toJson: User._addressToJson,\\n        )\\n            Address? address,\\n        @Default('')\\n            String phone,\\n        @Default('')\\n            String website,\\n        @JsonKey(\\n          fromJson: User._companyFromJson,\\n          toJson: User._companyToJson,\\n        )\\n            Company? company,\\n      }) = _User;\\n\\n      static Address? _addressFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Address.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _addressToJson(Address? address) {\\n        if (address == null) return null;\\n\\n        return address.toJson();\\n      }\\n\\n      static Company? _companyFromJson(Map<String, dynamic>? json) {\\n        if (json == null) return null;\\n\\n        return Company.fromJson(json);\\n      }\\n\\n      static Map<String, dynamic>? _companyToJson(Company? company) {\\n        if (company == null) return null;\\n\\n        return company.toJson();\\n      }\\n\\n      factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\\n    }\\n\\n\\n\\nThen as changes were made, we can then generate a new code so let's tell `build_runner` to do that for us by executing it again in your terminal, run the following command\\\\\\n\\n\\n    flutter pub run build_runner build --delete-conflicting-outputs\\n\\n\\n\\n## [](#conclusion)Conclusion\\n\\nCheers you have made it to this very last part! 🎉 Hope you enjoyed and learned something from this, should help you out when you strive to write clean code with-in your codebase.\\n\\nWe learned how we can create data models using the `freezed` package, we learned how we can make use of `@JsonKey` and creating a JSON converter for a specific field, we learned how we can use `copyWith` method to copy existing values and only replace the values that are specified in the parameters, and we learned how we can deal with any backend that returns different naming conventions for their JSON properties (`camelCasing`, `snake_casing` and `PascalCasing`). We may have only learned the basic of it and we can of course refactor some of it, but maybe we can tackle that next time, for now we are just going to make it work and that solves our problem.\\n\\nIf you liked this and find it useful, don't forget to show some love now hit up the like button! 💪 See you on the next one.\\n\\n[💻 Full source code can be found in here](https://github.com/carlomigueldy/freezed_data_modeling)\\n\",\"timestamp\":1636676595,\"title\":\"Data Modeling with Flutter using freezed package\"},\"digest\":\"dtaMa24lCTBTs-LH3LKR6raI7Dl8jn8Ifs1kcKiLAzk\",\"authorship\":{\"contributor\":\"0x3E8c686F499C877D8f4aFB1215b6f0935796b986\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"signature\":\"G-F9opm1REd09pYWsH9Tvo81ZP2qkq4_A_esRxYNO8dpIkAbBkq511i4i90Ol0m6HlwRRmWFv8cM8cdfQJbH7w\",\"signingKeySignature\":\"0xc823d2ab2ee5864fc5495382efb960b4461c3fb598b3be4e5e068c6312ab60ce014c7378c1f02beed8fce37236dc1e3eb8dd28a6f911b33ec4172a1fa8b17f101b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"dtaMa24lCTBTs-LH3LKR6raI7Dl8jn8Ifs1kcKiLAzk\"}"