"{\"content\":{\"body\":\"This article outlines the basic front- and backend flow of adding image uploading functionality to a web project using Javascript (React) and Go. It also addresses some additional features like file size limiting, content type limiting and sending files together with other input like text (adding a new forum post). This article does not touch setting up a React project or a server in Go.\\n\\nStarting from the beginning, we first have to enable the user to upload a picture from the UI. This is done by using the `type=”file”` of the `input` tag:\\n\\n```\\n<input type=\\\"file\\\" name=\\\"Image\\\" onChange={uploadHander} accept=\\\"image/jpeg\\\" />\\n```\\n\\nFile type input automatically inserts a button that takes the user to the local file system.  Event listeners can be added as usual. Optionally, an `accept` attribute can be used to restrict the file types that are available to be selected. Access attribute accepts MIME types as a comma separated list. It only makes other filetypes unclickable for the user  in the UI when selecting a file. File types should still be checked in the backend, too. \\n\\nThe selected image is stored as a `FileList` object containing a list of `File` objects. The selected file(s) can be accessed like an array as follows:\\n\\n```\\nhandleSetImage = (event) => {\\n    this.setState({\\n      image: event.target.files[0]\\n    })\\n}\\n```\\n\\nNext, we send the selected file to the backend using the fetch API:\\n\\n```\\nuploadHandler = () => {\\n  const formData = new FormData();\\n  formData.append('Image', this.state.image);\\n  formData.append('Text', this.state.text);\\n  formData.append('Title', this.state.title);\\n\\n  fetch(\\n    '/api/post/',\\n    {\\n      method: 'POST',\\n      body: formData,\\n    })\\n      .then((response) => {\\n          // Check response code\\n          return response.json();\\n      })\\n      .then((data) => {\\n        if (data.message == \\\"http: request body too large\\\") {\\n          data.message = \\\"File too big, max size is 20 MB\\\"\\n        } else {\\n        // HandleData\\n        }\\n      })\\n      .catch(() => {\\n        // Handle errors\\n      });\\n};\\n```\\n\\nFor storing the data, we use Javascript’s native `FormData` interface. This interface enables storing different types of data from form fields as key-value pairs. Files can be added by using the append method. \\n\\nThe encoding for uploading files usually needs to be `multipart/form-data`, but when using the fetch API, `Content-Type` needs to be omitted entirely for everything to work properly (the fetch API does the necessary work in the background). `FormData` is sent as request body. Here we also check for a specific `\\\"http: request body too large\\\"` error sent by the backend and make the error text more detailed for the user. \\n\\nThis is all the work that is needed from the front-end side. In the backend, we are accepting `POST` requests in a `createPost` handler that returns the status code and a (error or success) message to the frontend. I will not go into detail about the server setup here.\\n\\nThe first important thing we need to check in the backend is file size. We don’t want a careless or a malicious user to exhaust our server resources with a huge upload. Go offers a simple way to check for file size. \\n\\n```\\nmaxSize := 21 << 20\\nr.Body = http.MaxBytesReader(w, r.Body, int64(maxSize))\\n```\\n\\nMaxBytesReader reads the request body and if the body is bigger than the desired `maxSize` (21 MB here), it returns a `\\\"http: request body too large\\\"` error. \\n\\nNext, we have to parse the incoming form, to make it accessible: \\n\\n```\\nerr := r.ParseMultipartForm(maxMemory)\\nif err != nil {\\n    // Error handling\\n}\\n```\\n\\nFile size can also be checked in `ParseMultipartForm`, but this alone would not be enough. The maxMemory param only sets the maximum amount of data that can be read to memory, but the rest of the body is still read to the end and stored in temporary files.  \\n\\nParseMultiPartForm makes the data available by populating `request.Form` and `request.PostForm`. These sore data as a slice. For accessing the direct value, use `request.PostFormValue(Key)`.  Files become accessible through `request.FormFile` , that return a file (type `multipart.File`), a file header (type `*multipart.FileHeader`) and an error: \\n\\n```\\ntype postForm struct {\\n  Title        string\\n  Text         string\\n  ImagePath    string\\n}\\n\\np := postForm{}\\n\\np.Title = r.PostFormValue(\\\"Title\\\")\\np.Text = r.PostFormValue(\\\"Text\\\")\\n\\nimg, imgHeader, err := r.FormFile(\\\"Image\\\")\\nif err != nil {\\n  // check if a file is sent.\\n  if err.Error() == \\\"http: no such file\\\" {\\n    // Error handling\\n  } else {\\n    // handle other errors\\n}\\n\\ndefer img.Close()\\n```\\n\\nIf there is no file attached, `r.FormFile` returns a `\\\"http: no such file\\\"` error. The header gives access to file's attributes like the size and name. The size can used for an additional check for file size (before, we checked the whole body, not the file specifically, so there could still theoretically be files that are a bit over the desired limit).\\n\\n```\\nif imgHeader.Size > 20 << 20 {\\n  // error handling\\n}\\n```\\n\\nWe now have the image in a variable. Files are best stored on the file system, not the database. If dealing with forum posts, attached files can be referenced in the DB by file path. \\n\\n```\\nfileName := fmt.Sprintf(\\\"./uploads/%d%s\\\", time.Now().UnixNano(), filepath.Ext(imgHandler.Filename))\\n\\ndst, err := os.Create(fileName)\\nif err != nil {\\n  // error handling\\n}\\ndefer dst.Close()\\n\\n_, err = io.Copy(dst, img)\\nif err != nil {\\n  // error handling\\n}\\n```\\n\\nTo save a file, we need to first create it and the copy it to our desired destination using `os.Create` and `io.Copy`. Here we create a unique filename by using creation time. `filepath.Ext` appends the correct filename extension to the end. \\n\\nBefore doing this, however, we should check if the filetypes are correct. For that, we read the file’s beginning into a buffer and then test it with a http package’s function `DetectContentType`. After reading the file, we return the pointer to the start for further reading by using img.Seek.\\n\\n```\\nbuff := make([]byte, 512)\\n_, err = img.Read(buff)\\nif err != nil {\\n  // error handling\\n}\\n\\t\\t\\t\\nfiletype := http.DetectContentType(buff)\\nif filetype != \\\"image/jpeg\\\" {\\n  err = errors.New(\\\"Wrong file type. Only jpeg accepted\\\")\\n}\\n\\n_, err = img.Seek(0, io.SeekStart)\\nif err != nil {\\n  // error handling\\n}\\n```\\n\\nNow we have validated our file and saved it to our desired destination. To serve the files to frontend, we can use a `http.FileServer.`\\n\\n```\\nimageServer := http.FileServer(http.Dir(\\\"./uploads\\\"))\\nhttp.Handle(\\\"/uploads/\\\", http.StripPrefix(\\\"/uploads/\\\", imageServer))\\n```\\n\\nTo display the files on the frontend, an `img` tag with a correct `src` attribute is all that is needed. In the case of a forum post, the post can also come without an image. To handle that, we can add an image state and render the image tag conditionally only if a post has an image attached. \\n\\n```\\n{this.state.image && <img src={this.state.ImagePath}  alt=\\\"Post image\\\" width=\\\"200\\\" height=\\\"200\\\"/>}\\n```\\n\\nAnd this is it. We now have a basic workflow for uploading images and displaying them. Hope the post was helpful! \",\"timestamp\":1639996698,\"title\":\"Uploading images (React + Go)\"},\"digest\":\"OkHSBvaA-Hu0uGYAyySDNTN95Hux3YroB42HvUqogLU\",\"authorship\":{\"contributor\":\"0x41EEFB0deDe412cAAAd5D9d1E9DC0e9f9E043259\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"mRpkOS48-caFXR-LmtDn-hrVacBf1My4AQtjSYNFPWs\\\",\\\"y\\\":\\\"C-beMH0BbQVzs87X-FNGFgvVgll7aR79tN4kb0GUP6o\\\"}\",\"signature\":\"gfe0tUkiZrSlNF832phWb72ghKrpb2YKFbgfDNuMuHAgCswmeAaUgUytm-bcidBpNdO6HsxtlvF5YiXp5ElFnA\",\"signingKeySignature\":\"0xbbfa4f96124379b1b63f22021df3845899ce4d89ad954a4350a86676801600c32c6cb091ccea4d3e0d139570006db374fc7e4d83e5e8c7d9209a058f6485be4c1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"mRpkOS48-caFXR-LmtDn-hrVacBf1My4AQtjSYNFPWs\\\",\\\"y\\\":\\\"C-beMH0BbQVzs87X-FNGFgvVgll7aR79tN4kb0GUP6o\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"6r29ECff6RecH3GdYePb5iykcVhbPeOWkxqKz_QoHNA\"}"