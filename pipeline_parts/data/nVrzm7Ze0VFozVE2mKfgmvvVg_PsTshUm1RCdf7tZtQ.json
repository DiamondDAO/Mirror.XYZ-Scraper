"{\"content\":{\"body\":\"本文针对 Metric、Logging、Tracing、Profiling 分别谈谈**技术选型、架构、核心原理以及高可用**几方面的内容。\\n\\n聊聊技术选型，我主要会从**可扩展性、可运维性、功能性和成本**等几个方案考量。\\n\\n先聊 Metric，在 「聊聊可观测性2 - 数据模型」一文中有说对于 Metric，我们选择的是 Cortex 这个方案，这里解释为什么我们选型了 Cortex。\\n\\n其实对于 Metric，业界已经有很多开源方案了，比如 Zabbix、OpenFalcon、InfluxDB，这三个我们都没选，这里简单列举一些他们的缺点。\\n\\nZabbix 是一个古老的监控方案，在物理机时代就有，它的缺点至少有三个：\\n\\n1. 数据放在关系型数据库中（比如 MySQL），随着数据的增加，很难实现线性扩展，可扩展性有问题，而且关系型数据库，维护成本也高\\n2. 数据模型不强大，不支持 label，没法按多维度进行聚合统计和告警配置\\n3. 使用 C 语言开发，维护和二次开发成本高\\n\\nOpenFalcon 是小米开源的一款监控软件，是早期百度内部监控方案的开源实现，它也是诞生于物理机时代，它的缺点：\\n\\n1. 组件众多，安装复杂\\n2. 只支持有限的聚合函数\\n3. 非云原生，监控 k8s 集群有难度\\n4. 社区不活跃，版本不再维护\\n\\n后面 OpenFalcon 逐渐演变成 夜莺，并且推出企业版，对外售卖，夜莺简化了架构和安装流程，也支持了 k8s 监控，不过功能还是有缺陷，社区活跃度长期来说也有隐忧，故而也不选择。\\n\\nInfluxDB 是一款使用 Golang 开发的监控软件（Prometheus 也是），InfluxDB 不仅支持 Metric，还支持 Event，但是它的缺点有：\\n\\n1. InfluxDB 没有开源集群解决方案，集群管理方案需要收费\\n2. 相对 Prometheus，它有两个缺点：\\n   * 压缩比率低， Prometheus 平均一个数据点可以压缩到 1.37 字节，更加节省空间\\n   * 查询语言没有 Prometheus 的 PromQL 强大，PromQL 支持 topk、quantile 分布统计、95值、线性回归预测等\\n\\n我们选择使用 Prometheus 去构建我们的 Metric 平台，Prometheus 已经成为事实上的云原生监控标准，但是 Prometheus 自身是一个单机版，没有高可用和可扩展性。\\n\\n当前业内主要有三个 Prometheus 集群方案，分别是 Prometheus Operator、Thanos 和 Cortex。\\n\\nPrometheus Operator 是基于 k8s Operator 机制实现的一套集群方案，它启动两个 Prometheus，同时采集指标，以保证高可用。\\n\\n但是它有两个致命的缺点：\\n\\n1. 采集能力不可扩展，Prometheus 单机采集能力有限，在大规模集群下，比如数万台，单机采集有瓶颈\\n2. 存储不可扩展，数据保存在本地，无法保存长期的数据\\n\\n对于 Prometheus Operator 的采集和存储不可扩展的两个问题，Thanos 和 Cortex 都解决了，只是解决的方案有所不同。\\n\\n对于采集的扩展性，Thanos 使用了多个  Prometheus 集群 （每个集群是两个 Prometheus replica） 去采集，意味着需要做额外的配置管理，而 Cortex 使用了一个 Scraper 集群（基于 Prometheus 裁剪 ）去采集，对任务自动做 Sharding 以解决采集能力的可扩展性问题。\\n\\n对于存储的扩展性，Thanos 和 Cortex 都使用对象存储，这一点是一样的。\\n\\n![Thanos 架构](https://images.mirror-media.xyz/publication-images/y5meudGUhKPY0XdHXXkGE.png?height=720&width=960)\\n\\n整体上 Thanos 和 Cortex 非常类似，最终我们选择了 Cortex，因为 Cortex 本身更像一个整体的集群，维护成本低，而 Thanos 更像是若干个 Prometheus 集群的联合体，需要额外做配置管理，成本略高。\\n\\n再聊聊 Logging 的选型。\\n\\nLogging 平台业界的方案并不多，主要是 ELK 和比较新的 Loki，我们选择了 Loki（Grafana 开发）。\\n\\nLoki 本质上是一套轻量简洁的 Logging 平台，它是通过有限索引（只索引到文件级别），减少索引大小，并对索引内容（文件）做压缩，减少存储空间。\\n\\n在查询日志上，Loki 提供了 grep、sed、awk 这种命令行一样的体验，它抽象了一套简单的查询语法，叫做：LogQL，具体语法可以 Google。\\n\\nLoki 相比 ELK 的优势：\\n\\n1. Loki 有更好的扩展性，所有的组件均可扩展，而 ELK 数据量一大，ES 首先会面临扩容的问题，维护 ES 集群的复杂度更高\\n2. 吞吐量方面，因为 Loki 仅索引元数据，在写入吞吐量方面远远优于 ELK\\n3. 成本方面，由于压缩比高，Loki 的存储空间只有 ES 的 1/10（Loki 底层支持 gzip 压缩）\\n\\n再聊聊 Tracing 和 Profiling，Tracing 我们使用的是 Grafana 的 Tempo，Tempo 不仅支持 OpenTelemetry 的 Tracing 数据格式，而且和 Cortex、Loki 有一致的架构，还都支持对象存储。Profiling 目前想法是基于 Loki 改造（Profiling 暂未落地），架构当然也是一致的。\\n\\n下面聊一下架构。\\n\\n![Metric、Logging、Tracing、Profiling 统一架构图](https://images.mirror-media.xyz/publication-images/QmqCY5j1I1bcgkwn8to-o.png?height=654&width=602)\\n\\nMetric、Logging、Tracing、Profiling 有一致的架构图，有极好的可运维性。\\n\\n对于写入流来说：\\n\\n1. Distributor 会基于 Ingester 实例构建一个一致性哈希环，基于二分查找找到对应的 Ingester 实例写入，每个 Ingester 实例会持有有若干个 token，以便写入相对均衡。为了数据可靠性，Distributor 会写多个 Ingester 实例。\\n2. Ingester 是一个半有状态服务，它内部有 Cache，相当于热数据，它会定期把数据同步到对象存储（冷数据）。\\n3. Compactor 是一个压缩程序，因为 Distributor 会写多个 Ingester 实例，所以对象存储中有数据冗余，它负责合并掉冗余数据（包括索引）。另外，对于 Metric，它还会把多个 Block（默认 2h）合并成更长时间的 Block，以便节省资源和提升查询效率。\\n\\n对于查询流来说：\\n\\n1. Query-FrontEnd 是接收查询请求的前端，它内部有队列的设计，防止太多请求把服务打挂，而且把请求做分割，然后合并每个分割的结果，另外还会把数据存入 Result Cache，以便下次提升查询结果。\\n2. Querier 是具体查询的组件，它会访问 Ingester 和 Store-Gateway，Ingester 负责查询热数据，Store-Gateway 负责查询冷数据（Logging、Tracing、Profiling 当前没有 Store-Gateway）。\\n3. Store-Gateway 负责从对象存储中读取数据，它会通过 HTTP 206 的方式请求部分内容，并且它内部会保存部分的索引数据，并通过 Index Cache 提升查询效率。\\n4. Ruler 是计算程序，比如 Metric 的聚合计算和告警计算、Logging 基于日志生成指标的计算或告警的计算 等等。\\n\\n最后聊聊高可用的问题，这个架构中最重要的组件是 Ingester，Ingester 的高可用是怎么保证的呢。\\n\\n上面说到 Distributor 会写多个 Ingester 实例，写的数量叫做 replication factor，假设为 n。\\n\\n这里的逻辑是 Distributor 写入和读取 Ingester 实例成功的数量要大于等于 n/2 + 1，否则失败。\\n\\n比如 Ingester 实例是 3，n 是 2，写入和读取成功都必须是 2，如果一个实例故障，只剩 2 个实例，因为数据在环中是打散的，对于写入是没问题，但是对于读取，会有一个实例读取不到数据，所以是有问题的。\\n\\n如果 Ingester 实例是 3，n 是 3，写入和读取成功都必须是 2，一个实例故障，是没问题的。\\n\\n另外，这个架构还支持 Zone Aware Replication，以实现多 Zone 高可用。\\n\\n它要满足两个条件：\\n\\n1. 每个 Zone 的 Ingester 实例数一样\\n2. Zone 的数量要大于等于 n，比如 n = 3（默认值），那么 Zone 的数量至少为 3\\n\\n在[官方这里](https://cortexmetrics.io/docs/guides/zone-aware-replication/)的描述中，故障的 Zone 不超过 floor(n / 2) 就没问题，但事实上通过查看代码和测试得知，必须 n/2 + 1 的 Zone 正常写入和读取才是没问题的。\\n\\n比如 Zone num = 3，无论 n = 2 ，挂掉一个 Zone 是有问题的，如果 n = 3 就没问题。\\n\\n再比如 Zone num = 2，n = 2，挂掉一个 Zone 是有问题的（这个  case 如果想要没问题，可以修改源码，特殊处理，即当 Zone num = 2 时，有一个写入和读取正常当做没问题即可）。\",\"timestamp\":1641915613,\"title\":\"聊聊可观测性3 - 后端架构\"},\"digest\":\"XEDOGRrVRS6nBvHK8b13EaD057fPLolH-sOoLdwT4bA\",\"authorship\":{\"contributor\":\"0xFd007bb46C47D8600C139E34Df9DfceC86F0B319\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XB_bivAgA23-VQVMmuF0YC-iaofTDXnsNByUi4krxJA\\\",\\\"y\\\":\\\"iZsJ--B7EAa1HF0VegzuHvSMiAmqLqnn5MSBI_jR1Lo\\\"}\",\"signature\":\"bQPeJry5lUJyRqU83cTpXuFqvGSA4T8p50Fz3XodkoDD9CCL06xiN558cH4JKVaBLghPc4qfAVnm_FYWRzmD3Q\",\"signingKeySignature\":\"0x50909b2c1669797c58b4ebe19ccca1a1e13f5c27741474d52b088011703540bb3ee304124f88f6e3b3e5daef08f63e78b2bcf4b4b1a1922aa9f416ecf341c2661b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XB_bivAgA23-VQVMmuF0YC-iaofTDXnsNByUi4krxJA\\\",\\\"y\\\":\\\"iZsJ--B7EAa1HF0VegzuHvSMiAmqLqnn5MSBI_jR1Lo\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"fLOkM42RDqm7-HWudtNXRBLKHBBFd65wuglP3CeYP4s\"}"