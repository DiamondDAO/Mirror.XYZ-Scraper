"{\"content\":{\"body\":\"While Dune Analytics has rightly gotten a lot of positive attention recently for providing an easy-to-use platform for doing analytics over Ethereum datasets, you may not know that Google also provides a comprehensive dataset of Ethereum data on its large-scale analytics querying platform, [BigQuery](https://cloud.google.com/bigquery/).\\n\\nNot only are the datasets comprehensive - even including a table of call execution traces for every Ethereum transaction - they also benefit from BigQuery’s distributed nature, meaning that even large and complex queries can be executed quickly. I used BigQuery for both efficiently calculating the ENS airdrop amounts and for our [ENS dashboard](https://datastudio.google.com/s/nkFLZVr363c), and I thought people might find a few tips on how to put the data to work useful.\\n\\n# Where to find it\\n\\nThe Ethereum data can be found in two public projects in the [BigQuery console](https://console.cloud.google.com/bigquery). The first is the `crypto_ethereum` dataset under the `bigquery-public-data` project, which contains general Ethereum-wide datasets: Tables of blocks, logs, transactions, balances, etc.\\n\\nThe second project is `blockchain-etl`, which contains numerous public datasets for Ethereum projects. For example, `blockchain-etl.ethereum_ens` contains tables of events for most major contracts in ENS. If you’re wanting to produce analytics or do data mining for a specific project, look here first.\\n\\n# How to query it\\n\\nIf you’ve used another analytics product like Dune Analytics, this will mostly be pretty familiar; BigQuery uses an SQL dialect just like Dune. For example, if you wanted to get a list of every address used as an ENS resolver, you could do it like this:\\n\\n```\\nSELECT\\n  resolver,\\n  COUNT(*) AS count\\nFROM\\n  `blockchain-etl.ethereum_ens.ENSRegistryWithFallback_event_NewResolver`\\nGROUP BY\\n  resolver\\nORDER BY\\n  count DESC;\\n```\\n\\nLikewise for the `crypto_ethereum` dataset. Want a leaderboard of accounts that have spent the most on transaction fees? Here you go:\\n\\n```\\nSELECT\\n  from_address,\\n  SUM(CAST(receipt_gas_used AS numeric) * CAST(COALESCE(gas_price, receipt_effective_gas_price) AS numeric)) / 1e18 AS total_fees\\nFROM\\n  `bigquery-public-data.crypto_ethereum.transactions`\\nGROUP BY\\n  from_address\\nORDER BY\\n  total_fees DESC\\nLIMIT\\n  100;\\n```\\n\\n# Tips\\n\\n## Aggregating Deltas\\n\\nA lot of Ethereum event data has a common format: each event describes a change to some underlying state. Often what you want, however, is the state itself, rather than the delta. For example, ERC20 transfers are logged as a `Transfer` event, which includes the from address, to address, and amount transferred, but often what you want is a balance sheet of all account balances. For this sort of query, simple aggregates generally suffice. This query, for example, returns a balance sheet for $ENS:\\n\\n```\\nSELECT\\n  address,\\n  SUM(value) AS balance\\nFROM (\\n  SELECT\\n    token_address,\\n    from_address AS address,\\n    -CAST(value AS bigdecimal) / 1e18 AS value\\n  FROM\\n    `bigquery-public-data.crypto_ethereum.token_transfers`\\n  UNION ALL\\n  SELECT\\n    token_address,\\n    to_address AS address,\\n    CAST(value AS bigdecimal) / 1e18 AS value\\n  FROM\\n    `bigquery-public-data.crypto_ethereum.token_transfers` )\\nWHERE\\n  token_address = '0xc18360217d8f7ab5e7c516566761ea12ce7f9d72'\\nGROUP BY\\n  address\\nORDER BY\\n  balance DESC;\\n```\\n\\nNote we’re including the `token_transfers` table here twice, once with negative values for the sender, and once with positive values for the recipient.\\n\\n## Creating a time-series from deltas\\n\\nWhat if you want a balance history - the balance of an address after each transaction? This is where window functions (also called analytic functions) come in incredibly useful:\\n\\n```\\nSELECT\\n  block_timestamp AS timestamp,\\n  address,\\n  SUM(value) OVER (PARTITION BY address ORDER BY block_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS balance\\nFROM (\\n  SELECT\\n    block_timestamp,\\n    token_address,\\n    from_address AS address,\\n    -CAST(value AS bigdecimal) / 1e18 AS value\\n  FROM\\n    `bigquery-public-data.crypto_ethereum.token_transfers`\\n  UNION ALL\\n  SELECT\\n    block_timestamp,\\n    token_address,\\n    to_address AS address,\\n    CAST(value AS bigdecimal) / 1e18 AS value\\n  FROM\\n    `bigquery-public-data.crypto_ethereum.token_transfers` )\\nWHERE\\n  token_address = '0xc18360217d8f7ab5e7c516566761ea12ce7f9d72'\\nORDER BY\\n  balance DESC;\\n```\\n\\nNote the similarities to the previous query - but now we’re no longer grouping the results. Here, the SUM function isn’t aggregating records, it’s summing over other rows in the input set, totalling up the values of all previous transactions for that account. Note how the OVER clause specifies how to partition the rows (by address) and how to order them (by timestamp) and which rows to sum (from the start to the current row) - all resulting in a correct total for our use-case. The result will be one row for every token transaction, but with the balance after the transaction rather than the amount transacted.\\n\\n## Creating deltas from a time series\\n\\nWhat if you want to do the reverse - you have the new value, but instead you want the delta? We see this with ENS registration and renewal events; the contract outputs the expiry time, and we may want to know how long the name was registered or renewed for. Analytics queries come in useful here too, this time with the LAG function, which references a previous row in the input set:\\n\\n```\\nSELECT\\n  block_timestamp,\\n  name,\\n  CAST(expires AS int64) - COALESCE(LAG(CAST(expires AS int64), 1) OVER(PARTITION BY name ORDER BY block_timestamp), UNIX_SECONDS(block_timestamp)) AS duration\\nFROM (\\n  SELECT\\n    block_timestamp,\\n    name,\\n    expires\\n  FROM\\n    `blockchain-etl.ethereum_ens.ETHRegistrarController3_event_NameRegistered`\\n  UNION ALL\\n  SELECT\\n    block_timestamp,\\n    name,\\n    expires\\n  FROM\\n    `blockchain-etl.ethereum_ens.ETHRegistrarController3_event_NameRenewed`)\\n```\\n\\nLAG takes the expression to retrieve and how many rows back to retrieve it - and the OVER expression specifies how the rows should be partitioned and ordered. We also use COALESCE to provide a dynamic value for when a row is the first in the result set (eg, it’s being registered for the first time).\\n\\nIt’s worth noting that this won’t give totally accurate results; if a name expires and is reregistered, it will show the previous registration taking over from when the name expired, not from when it was reregistered. Fixing this is left as an exercise for the reader.\\n\\n## JavaScript user-defined functions\\n\\nFinally, what if you want to do something there isn’t a built-in function for - such as converting between a 256 bit int and its hex representation? Fortunately, BigQuery has you covered, with support for JavaScript user-defined functions, which can even import libraries:\\n\\n```\\nCREATE OR REPLACE FUNCTION `project.dataset.int_str_to_hash`(data STRING) RETURNS STRING LANGUAGE js\\nOPTIONS (library=[\\\"gs://blockchain-etl-bigquery/ethers.js\\\"]) AS R\\\"\\\"\\\"\\nreturn '0x' + ethers.utils.bigNumberify(data).toHexString().slice(2).padStart(64, '0');\\n\\\"\\\"\\\";\\n```\\n\\n## Extracting your own event data\\n\\nAll of this is great, but what if you want to do analytics on events that haven’t been conveniently extracted to a table and decoded by the Blockchain ETL team? If your dataset is widely useful, you may want to follow the instructions in [this post](https://medium.com/@ASvanevik/how-to-get-any-ethereum-smart-contract-into-bigquery-in-8-mins-bab5db1fdeee), to get your dataset added to the blockchain_etl project. If you don’t have time to wait, or you’re working on something more bespoke, however, it’s possible to extract this data yourself using JavaScript UDFs - something I’ll go into in detail in my next post.\",\"timestamp\":1637973459,\"title\":\"Ethereum analytics with BigQuery\"},\"digest\":\"INhEmxgxoyoa8kPZ3rjYNZXoyfGsReLgx42MdDvn4SM\",\"authorship\":{\"contributor\":\"0xb8c2C29ee19D8307cb7255e1Cd9CbDE883A267d5\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"0m33j7WfM-QZCqBRPYFBcG42ZpKdIrjQjtWaAeE-S-E\\\",\\\"y\\\":\\\"qMVtjAa0g7F-TDwkEgbNEy3w9eU6ffj64hZTO175r_o\\\"}\",\"signature\":\"WVv0Tg9A5Pw94mgwd8uJGh_aXOHfG6HwLSTdbPNEOun2WwS4ZIk5hPebhPcxLO1gddRWE8SxOypWpIl6Ra1VeQ\",\"signingKeySignature\":\"0xaf6c769697649f9d663ae1ac6a2df82a229c9398b59440f29f420d4b10517b7412ee5a38429e272ba125f53d6c444476a0a3cc06f67ac0d4a14e86c3327142ec1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"0m33j7WfM-QZCqBRPYFBcG42ZpKdIrjQjtWaAeE-S-E\\\",\\\"y\\\":\\\"qMVtjAa0g7F-TDwkEgbNEy3w9eU6ffj64hZTO175r_o\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"INhEmxgxoyoa8kPZ3rjYNZXoyfGsReLgx42MdDvn4SM\"}"