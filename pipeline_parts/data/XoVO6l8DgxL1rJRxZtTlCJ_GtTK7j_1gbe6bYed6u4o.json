"{\"content\":{\"body\":\"# The Necessary of Confidential Contract\\n\\nFor the Ethereum public main chain, its most proud or important feature is that all transactions are open and transparent, which means that anyone who joins in this network can obtain the whole transaction history. They can analyze them freely.\\n\\nHowever, a coin has two sides. The absolutely privacy still has its vitality. In the DeFi application, due to its transparency, the perpetrator can make some inferences from the transaction and “attacks” with these transaction histories. These transparency may be used to make the perpetrators profitable and cause losses to investors.\\n\\n# Eigen Network Confidential Contracts Framework — — EigenCC\\n\\nBased on a series theoretical foundation and practical experience, The Eigen Network provides several technical infrastructure to support confidential contracts in a public blockchain network, with the L2 solution of Arbitrum.\\n\\nThe framework EigenCC provides an easy way to add new instructions in the trusted execution environment (TEE). We focus on 3 important parts to leverage the confidential trusted computing environment:\\n\\n* Confidential operators: what operators inside TEE can be provided and how it get done;\\n* Secure transportation: how the privacy information is sent or received from the Eigen Network without privacy breach;\\n* On-chain data protection: how we store the privacy information on the chain.\\n\\nThe TEE is often hardware based. It ensures that even the node operator does **NOT** have any access to private data, including immediate computation results. This feature ensures the security of private data. EigenCC provides a decentralized mechanism for TEE nodes. Due to the compatibility of Arbitrum with Ethereum, the Ethereum digital assets (e.g., ERC-20 tokens) can move between Ethereum and our own token, which means that anyone can develop smart contracts with a minor modification.\\n\\n# Confidential Operators\\n\\nSome fundamental confidential operators should be provided to simplify the development and abstract some common calculations. Thus we provide a series of confidential operators. For now, we’ve implemented:\\n\\n* Three arithmetic operators: addition, subtraction and multiplication on 256bits integer\\n* Comparison operators: greater than, less than and equal\\n* Debug operators: encryption and decryption\\n\\nThese operators are done inside TEE, which makes it confidential. The latest implementation and documents could be found in our Github.\\n\\n# Secure Transportation\\n\\nReferring to the security mechanism of TLS, we adopt the RA-TLS schema for a secure channel between end-user and EigenCC. The general workflow is like below:\\n\\n![](https://images.mirror-media.xyz/publication-images/EXWm6M3ilWaXV-W0qHxdG.png?height=735&width=1400)\\n\\nThe main update is that we put the Enclave Quote embedded in the X509 certificate, and the challenger verifies the quote after the general certificate verification.\\n\\nIn our implementation, we provide a socket-based channel between EGVM(AVM) and EigenCC.\\n\\nHence, all above encrypted items are encrypted by an ECC public key with ECIES. When EigenCC launches, it will generate an ECC key pair, and the public key will be registered to PKCS.\\n\\n# On-chain Data Protection\\n\\nThis is a tough issue. Since the on-chain data is openly accessed by anyone, if a vulnerable logic or weak key was used, it leads to all the privacy inside the corresponding contract being exposed to everyone. Hence, how to encrypt the on-chain data becomes crucial.\\n\\nIt recommends taking the secret key into custody by the owner itself, and using re_encrypt to encrypt the privacy information, and upgrade the key periodically.\\n\\n# Use Cases\\n\\nSome use cases are provided to show how to use the EigenCC framework.\\n\\n# EigenCall Library\\n\\nTo make it easy to use and save gases, we implement a link library named EigenCallLibrary[ here](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/libraries/EigenCallLibrary.sol). It can be deployed on L2 and anyone can call them if deployed with the address.\\n\\nEigenCallLibrary is implemented based on[ EGIP 00001](https://github.com/ieigen/ieigen/blob/main/docs/egip/00001.md), for now, we have implemented these public functions in [here](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/libraries/EigenCallLibrary.sol).\\n\\nThese functions hide the details of implementations of eigenCall, so the user does not care about how to compose an eigenCall input bytes, or how to decode the returning RLP encoded value. An assert is put into each wrapper function to ensure eigenCall is called successfully. If any error occurs, the contract call will cause a transaction revert with a message.\\n\\nTo use EigenCallLibrary in a contract, just import it with the right path, and regard it as a typical link library. For example, in[ TestCCCustomToken.sol](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/test/TestCCCustomToken.sol), demo_addCipherCipher function calls EigenCallLibrary.addCipherCipher:\\n\\nfunction demo_addCipherCipher(bytes memory cipher1, bytes memory cipher2)\\n\\npublic\\n\\npure\\n\\nreturns (bytes memory)\\n\\n{\\n\\nbytes memory output = EigenCallLibrary.addCipherCipher(cipher1, cipher2);\\n\\nreturn output;\\n\\n}\\n\\nThe output is ensured a valid cipher result of addCipherCipher operator. So the user can use the result without caring about the correctness of the result.\\n\\nOther demo_\\\\* functions can be found in *TestCCCustomToken.sol*.\\n\\nIf we want to call the contract function in Javascript or Typescript, we should tell the link library address in the contract we want to use EigenCallLibrary.\\n\\nFor example, we can see the snippet in[ exec.js](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/demo-eigencall/scripts/exec.js):\\n\\n// …\\n\\nvar L2EigenCallLibrary = await (\\n\\nawait ethers.getContractFactory(“EigenCallLibrary”)\\n\\n).connect(l2Wallet);\\n\\nL2EigenCallLibrary = await L2EigenCallLibrary.deploy();\\n\\nawait L2EigenCallLibrary.deployed();\\n\\nconsole.log(\\n\\n“EigenCallLibrary is deployed at address:”,\\n\\nL2EigenCallLibrary.address\\n\\n);\\n\\n​\\n\\nvar L2EigenCallLibraryUseDemo = await (\\n\\nawait ethers.getContractFactory(“EigenCallLibraryUseDemo”, {\\n\\nlibraries: {\\n\\nEigenCallLibrary: L2EigenCallLibrary.address,\\n\\n},\\n\\n})\\n\\n).connect(l2Wallet);​\\n\\nconsole.log(“Deploying EigenCallLibraryUseDemo contract to L2”);\\n\\nL2EigenCallLibraryUseDemo = await L2EigenCallLibraryUseDemo.deploy({\\n\\ngasLimit: 25000000,\\n\\n});\\n\\nawait L2EigenCallLibraryUseDemo.deployed();\\n\\nconsole.log(\\n\\n\\\\`EigencallDemo contract is deployed to ${L2EigenCallLibraryUseDemo.address}\\\\`\\n\\n);\\n\\n// …\\n\\nBefore deploying EigenCallLibraryUseDemo which uses EigenCallLibrary, we should ensure that we have got the link address of it, after passing it to the factory function, the contract can be deployed successfully.\\n\\nThe Typescript example can be found in[ cc.ts](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/scripts/cc.ts), it is similar with the Javascript snippet.\\n\\nAfter the successful deployment, we can freely call these contract functions with TEE operators support!\\n\\n# Confidential ERC20\\n\\nThe Standard ERC20 token is widely used for now. Following is an interface contract declaring the required functions and events to meet the ERC20 standard:\\n\\ncontract ERC20 {\\n\\nfunction totalSupply() constant returns (uint totalSupply);\\n\\nfunction balanceOf(address _owner) constant returns (uint balance);\\n\\nfunction transfer(address _to, uint _value) returns (bool success);\\n\\nfunction transferFrom(address _from, address _to, uint _value) returns (bool success);\\n\\nfunction approve(address _spender, uint _value) returns (bool success);\\n\\nfunction allowance(address _owner, address _spender) constant returns (uint remaining);\\n\\nevent Transfer(address indexed _from, address indexed _to, uint _value);\\n\\nevent Approval(address indexed _owner, address indexed _spender, uint _value);\\n\\n}\\n\\nOne of the core functions of ERC20 is transfer. In brief, transfer applies two math operations on corresponding balances, that is, adding the amount to the receiver’s balance and minus the amount to the sender’s balance.\\n\\nFor our Confidential ERC20, which had been implemented at[ TestCCCustomToken.sol](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/test/TestCCCustomToken.sol), The math operators used in balance calculation are privacy operators.\\n\\nFor example, in *TestCCCustomToken.sol*, transfer can be implemented as:\\n\\nfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n\\n// …\\n\\n​\\n\\nbytes memory sender_cipher_hex_balance = _cipher_balances\\\\[_msgSender()\\\\];\\n\\nbytes memory sender_cipher_hex = EigenCallLibrary.subCipherPlain(\\n\\nsender_cipher_hex_balance,\\n\\namount\\n\\n);\\n\\n_cipher_balances\\\\[_msgSender()\\\\] = EigenCallLibrary.copyBytes(sender_cipher_hex);\\n\\nbytes memory recipient_cipher_hex_balance = _cipher_balances\\\\[recipient\\\\];\\n\\nbytes memory recipient_cipher_hex = EigenCallLibrary.addCipherPlain(\\n\\nrecipient_cipher_hex_balance,\\n\\namount\\n\\n);\\n\\n_cipher_balances\\\\[recipient\\\\] = EigenCallLibrary.copyBytes(recipient_cipher_hex);\\n\\nemit TransferCipher(_msgSender(), recipient, bytes(amount.toString()));\\n\\nreturn true;\\n\\n}\\n\\nInstead of store plain balances, cipher balances are used in Confidential ERC20. So typical add and sub are replaced with privacy operators, (here, we use addCipherPlain and subCipherPlain as replacement). Quite easy to implement such tokens with EigenCallLibrary.\\n\\nAlso, we can implement another version of transfer named cipherTransfer, which means the amount can be also cipher:\\n\\nfunction cipherTransfer(address recipient, bytes memory cipher_amount)\\n\\npublic\\n\\nvirtual\\n\\nreturns (bool)\\n\\n{\\n\\n// …\\n\\nbytes memory sender_cipher_hex_balance = _cipher_balances\\\\[_msgSender()\\\\];\\n\\nbytes memory sender_cipher_hex = EigenCallLibrary.subCipherCipher(\\n\\nsender_cipher_hex_balance,\\n\\ncipher_amount\\n\\n);\\n\\n_cipher_balances\\\\[_msgSender()\\\\] = EigenCallLibrary.copyBytes(sender_cipher_hex);\\n\\nbytes memory recipient_cipher_hex_balance = _cipher_balances\\\\[recipient\\\\];\\n\\nbytes memory recipient_cipher_hex = EigenCallLibrary.addCipherCipher(\\n\\nrecipient_cipher_hex_balance,\\n\\ncipher_amount\\n\\n);\\n\\n_cipher_balances\\\\[recipient\\\\] = EigenCallLibrary.copyBytes(recipient_cipher_hex);\\n\\nemit TransferCipher(_msgSender(), recipient, cipher_amount);\\n\\nreturn true;\\n\\n}\\n\\nJust use addCipherCipher and subCipherCipher instead of addCipherPlain and subCipherPlain.\\n\\nWhat about getting the balance? Of course, we can get the cipher balance with cipherBalanceOf.\\n\\nOther functions are implemented similarly. To know more details, we can read the overall source code.\\n\\n \\n About Eigen Network\\n\\n💻 Eigen Network：<https://www.ieigen.com/>\\n🦋 Twitter：<https://twitter.com/Eigen_Network>\\n👬 Telegram：<https://t.me/EigenNetwork>\\n🕳️ Medium：<https://medium.com/@iEigen>\\n🐵 Discord：<https://discord.gg/CkzGRuKwWU>\\n🐱 GitHub：<https://github.com/ieigen> \\n \",\"timestamp\":1637858665,\"title\":\"A Brief Introduction to Confidential Contract Provided by Eigen Network\"},\"digest\":\"U96TR5XO8aoOL3DHy6CEI_fNolEu7Mz_0yIBYlqwRfE\",\"authorship\":{\"contributor\":\"0xC413436E1A6bC5942e0f5Af725c5eeA747b6c473\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"zjShyZ8XxhQmavDSdv7HiaK-AHLagZ6NoKHR5DPM2B0\\\",\\\"y\\\":\\\"FxjqMHCRyjsbg3VhFH8HTYkyboXli6bci1WkN8oHjuQ\\\"}\",\"signature\":\"b8ge1heYvpKUl15eq1osZTrHsA_rAPs3FncYMqBcqvJN7h_vaPtkdkFjQ3KL03cDwGy6HbcErTMuSByZp7silA\",\"signingKeySignature\":\"0x942a1d1fe7d75f74bc89e473107bf76ddd851442942f8d9d7f234457cdd8b80e74e97430b0988ad454c5ce0837940cbbe664ebab3b224277587ad97fe42e47261c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"zjShyZ8XxhQmavDSdv7HiaK-AHLagZ6NoKHR5DPM2B0\\\",\\\"y\\\":\\\"FxjqMHCRyjsbg3VhFH8HTYkyboXli6bci1WkN8oHjuQ\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"RNl22KC5cSdMEweXUkjX-dRK2vnXaMxEsRjlNcJd7Ds\"}"