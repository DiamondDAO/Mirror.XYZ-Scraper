"{\"content\":{\"body\":\"This is the official documentation of lightweight bitcoin mining protocol.\\nIf you’re looking for Stratum mining proxy, please visit [mining proxy howto](https://slushpool.com/help/get-started/mining-proxy).\\nIf you’re looking for mining software compatibility, please go to the [compatibility section](https://slushpool.com/help/#!/manual/stratum-protocol#compatibility).\\n\\n## Content\\n\\n* Why to Change Something That Works?\\n  * HTTP: Communication Is Driven by Miners...\\n  * Ntime Rolling: Not Enough Job for Fast Miners\\n  * Long Polling: An Anti-Pattern\\n* How to Fix All That?\\n  * Stratum Protocol\\n  * Extranonce Rolling: The New Dimension\\n  * Other Decisions\\n* For Mining Software Developers\\n  * Exception Handling\\n  * Real-World Example\\n* Downloads\\n* Compatible Miners\\n\\nThis page is both a technical documentation and advocacy of the new mining protocol which can be used for bitcoin mining.If you're a casual miner or just a regular bitcoin user, then you don't have to understand everything in this document.\\n\\nThe main reason why I designed this protocol and implemented opensource pool server is that the current getwork&LP mining protocolhas many flaws and it can hardly be used in any large-scale setup. ASIC miners are probably coming at the end of the year 2012,so Bitcoin community definitely needs some solution, which will easily scale to tera-hashes per second per pool user...\\n\\n## 1. Why to Change Something That Works?\\n\\n### HTTP: Communication is Driven by Miners...\\n\\n... However pool server knows much better when clients need new mining jobs. HTTP was designed for web site browsing where clients ask servers for specific content. Pooled mining is different - server knows very well what clients need and can control the communication in a more efficient way. Let’s swap roles and leave orchestration to the server!\\n\\n### Ntime Rolling: Not Enough Jobs For Fast Miners\\n\\nNowadays, for every received job from the server, a miner can modify only ntime and nonce. Nonce is a 32bit integer (4.2 billion of iterations). Ntime is a 32bit integer storing UNIX timestamp and should reflect current time, although optimized miners roll ntime slightly into the future, which gives more combinations to miners (nonce range \\\\* ntime range). However, a block created from massively modified ntime can be rejected by Bitcoin network.\\n\\nStrictly following getwork specification, one getwork job is enough for 4.2GHash/s mining rig and (thanks to ntime rolling) this job is usable for one minute or until a new Bitcoin block arrives (depending on what happens first). So, for 42 GHash/s rig you’ll need 10 getwork requests at once, but usually a few more because of some pre-caching strategies implemented by miners to prevent idling on network latencies. And what about 1 THash/s ASIC miners coming soon? We simply need some solution where network load is not at all bounded to miners performance.\\n\\n### Long Polling: An Anti-Pattern\\n\\nGetwork came as an easy solution for building standalone miners (do you remember when the official Bitcoin client was the only miner?), much before I built my first Bitcoin pool and when frequent polling of local bitcoin daemon wasn't an issue. When pools came into the game, people found out that they must decide between short polling intervals (=higher network load, lower stale ratio) and intervals, which don't overload network and servers, but lead to a much higher ratio of rejected shares. And long polling pattern was the answer. Long polling is a great way to achieve real-time updates using standard web technologies. But as I already mentioned in the text above, web technologies are not ideal for Bitcoin mining.\\n\\nLong polling uses separate connection to pool server, which leads to various issues on server side, like load balancing of connections between more backends. Load balancing using IP hashes or sticky HTTP sessions are just another workarounds for keeping all that stuff working.\\n\\nAnother problem consists of packet storms, coming from clients trying to reconnect to the server after long polling broadcasts. Sometimes it's hard to distinguish valid long polling reconnections from DDoS attacks. All this makes pool architecture more complicated and harder to maintain, which is reflected in less reliable pool service and has a real impact on miners.\\n\\nThe solution for such issues is related to the previous point about driving load by the server and not by thousands of (sometimes) strangely implemented miners, who are aggressively trying to reach the server.\\n\\n## 2. How Can We Fix All That?\\n\\nNow we know what's wrong in the current situation, so let's design a new protocol and don't repeat bad decisions again:\\n\\n### Stratum Protocol\\n\\nI originally designed Stratum protocol for lightweight Bitcoin client called Electrum. Later I found out that protocol requirements are quite similar to requirements for bitcoin mining, so I decided to reuse it as-is. Don't be confused by an esoteric protocol name, I tried to stick to standards as much as possible.\\n\\nIn a simplified manner, Stratum is a line-based protocol using plain TCP socket, with payload encoded as JSON-RPC messages. That's all. Client simply opens TCP socket and writes requests to the server in the form of JSON messages finished by the newline character \\\\\\\\n. Every line received by the client is again a valid JSON-RPC fragment containing the response.\\n\\nThere are good reasons for such solution: it is very easy to implement and very easy to debug, because both sides are talking in human-readable format. The protocol is unlike many other solutions easily extensible without messing up the backwards compatibility. As a bonus, JSON is widely supported on all platforms and current miners already have JSON libraries included. So packing and unpacking of the message is really simple and convenient.\\n\\nThere's no HTTP overhead involved and there're no hacks like mining extension flags encoded in HTTP headers anymore. But the biggest improvement from HTTP-based getwork is the fact, that server can drive the load by itself, it can send broadcast messages to miners at any time without any long-polling workarounds, load balancing issues and packet storms.\\n\\n### Extranonce Rolling: The New Dimension\\n\\nThis is probably the most innovative part of the new protocol. In contrary to current mining where only ntime and nonce can be iterated, Stratum mining protocol gives a power to miners to easily build unique coinbase transactions locally, so they'll be able to produce unique block headers locally. I recommend to iterate four bytes of extranonce, which gives the possibility to serve 18 EHash/s (Exa-hashes/s) mining rig from a single TCP connection. But it can be easily changed by the pool operator anytime.\\n\\nNow it is going to be a bit technical, so let's explain it a bit. Block header (that string what is in getwork response and what miners are hashing) is composed from following parts:\\n\\n* Block version, nbits, hash of previous block in the blockchain and some padding bytes, which are constants.\\n* Nonce and ntime, which miner can modify already.\\n* Merkle root hash, which is created by hashing of bitcoin transactions included in the particular mining job.\\n\\nTo produce more unique block headers (and thus be able to generate more unique hashes), we have to modify something.\\n\\nEvery bitcoin block contains so-called coinbase transaction which specify the bitcoin address for sending block reward. Fortunately there's a chance to modify this transaction without breaking anything. By changing coinbase transaction, merkle root will change and we will have unique block header to hash. Currently this (creating unique coinbase) happens on pool servers. So let's move it to miners!\\n\\n### Other Decisions\\n\\n#### JSON Versus Your-Preferred-Protocol\\n\\nI considered many solutions for serializing and deserializing message payloads. I wrote some reasons for JSON above, but let's sumarize them again:\\n\\n* JSON payload is human readable, easy to implement and debug.\\n* All bitcoin miners already have JSON libraries included. JSON has native support in almost every language.\\n* In contrary of most binary protocol, JSON payload can be easily extended without breaking backward compatibility.\\n* JSON-RPC already specifies three native message types which Stratum uses: request, response and notification. We don't need to reinvent a wheel.\\n* JSON has definitely some data overhead, but Stratum mining messages typically fits into one TCP packet...\\n  Why I throw away other serializers:\\n* Custom text protocol is human readable and easy to debug, but not so easy to implement as it may look at first glance. We have to define a way how to pair request and response, because sequential processing of requests may be a bit tricky on some platforms (yes, now I'm referring Twisted framework which I used for pool implementation). We also have to define how to serialize various data types like lists or even mappings. JSON solve all this transparently for us.\\n* Custom binary protocol is the most compact form which can saves a lot of bandwith, especially while dealing with binary data involved in bitcoin mining. However writing (de)serializers *properly* may be a bit tricky. I wanted the protocol which is easy to implement. Fiddling with byte order and binary headers is not what I was looking for.\\n* Protocol buffers by Google is interesting concept which may fit the needs, except that only C++, Python and Java are supported.\\n* Thrift is another binary protocol which I used some time ago, but it is defitely too heavy for our purposes.\\n\\n#### Stratum Versus Getblocktemplate\\n\\nGetblocktemplate introduced in bitcoind 0.7 is a very progressive solution for delegating block creation from full bitcoin client to standalone, specialized software. Stratum mining server uses getblocktemplate mechanism under the hood. There are still some reasons why Stratum is, in my opinion, a better solution for pooled mining:\\n\\n* It is less complex, much easier to implement in existing miners and it still does the job perfectly.\\n* For historical reasons getblocktemplate still uses HTTP protocol and long polling mechanism. I described above why this fails on large scale mining.\\n* Stratum scales much better for rising amount of processed Bitcoin transactions, because it transfers only merkle branch hashes, in the contrary to complete dump of server’s memory pool in getblocktemplate.\\n* Checking submitted shares is also much cheaper on processing resources in Stratum than in getblocktemplate.\\n\\nThere's really only one reason why Stratum is worse than getblocktemplate solution at this time: miners cannot choose Bitcoin transactions on their own. In my experience 99% of real miners don’t care about transaction selection anyway, they just want the highest possible block reward. At this point they share the same interest with pool operator, so there’s no real reason to complicate mining protocol just for those 1% who want to create custom blocks for the pool.\\n\\nI already have some ideas for Stratum mining protocol extension, where miners will be able to suggest their own merkle branch (I call it internally “democratic mining”), which will solve such issues as centralized selection of transactions. For now I decided to focus on such a solution, which will fit to majority of miners and do some extensions later.\\n\\n## 3. For Mining Software Developers\\n\\nStratum protocol is based on JSON-RPC 2.0. In this chapter I expect that you're familiar with this protocol and you understand terms like \\\"request\\\", \\\"response\\\" and \\\"notification\\\". Please read [JSON-RPC specification](http://www.jsonrpc.org/specification) for more details.\\n\\nFor high level image of the Stratum protocol concept, please read [Stratum protocol specification](https://docs.google.com/a/palatinus.cz/document/d/17zHy1SUlhgtCMbypO8cHgpWH73V5iUQKk_0rWvMqSNs/edit?hl=en_US) on Google docs. This document needs some care, but give you the basic examples how to connect to Stratum server.\\n\\n### Exception Handling\\n\\nStratum defines simple exception handling. Example of rejected share looks like:\\n\\n```json\\n{\\\"id\\\": 10, \\\"result\\\": null, \\\"error\\\": (21, \\\"Job not found\\\", null)}\\n```\\n\\nWhere error field is defined as (error_code, human_readable_message, traceback). Traceback may contain additional information for debugging errors.\\n\\nProposed error codes for mining service are:\\n\\n* 20 - Other/Unknown\\n* 21 - Job not found (=stale)\\n* 22 - Duplicate share\\n* 23 - Low difficulty share\\n* 24 - Unauthorized worker\\n* 25 - Not subscribed\\n\\n### Real-World Example\\n\\nThis chapter contains real log of miner-pool communication which solved testnet3 block\\n\\n```\\n000000002076870fe65a2b6eeed84fa892c0db924f1482243a6247d931dcab32\\n```\\n\\n#### Miner Connects the Server\\n\\nOn the beginning of the session, client subscribes current connection for receiving mining jobs:\\n\\n```json\\n{\\\"id\\\": 1, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\\\\n{\\\"id\\\": 1, \\\"result\\\": [ [ [\\\"mining.set_difficulty\\\", \\\"b4b6693b72a50c7116db18d6497cac52\\\"], [\\\"mining.notify\\\", \\\"ae6812eb4cd7735a302a8a9dd95cf71f\\\"]], \\\"08000002\\\", 4], \\\"error\\\": null}\\\\n\\n```\\n\\nThe result contains three items:\\n\\n* Subscriptions details - 2-tuple with name of subscribed notification and subscription ID. Teoretically it may be used for unsubscribing, but obviously miners won't use it.\\n* Extranonce1 - Hex-encoded, per-connection unique string which will be used for coinbase serialization later. Keep it safe!\\n* Extranonce2_size - Represents expected length of extranonce2 which will be generated by the miner.\\n\\n#### Authorize Workers\\n\\nNow let authorize some workers. You can authorize as many workers as you wish and at any time during the session. In this way, you can handle big basement of independent mining rigs just by one Stratum connection.\\n\\n```json\\n{\\\"params\\\": [\\\"slush.miner1\\\", \\\"password\\\"], \\\"id\\\": 2, \\\"method\\\": \\\"mining.authorize\\\"}\\\\n{\\\"error\\\": null, \\\"id\\\": 2, \\\"result\\\": true}\\\\n\\n```\\n\\n#### Server Start Sending Notifications With Mining Jobs\\n\\nServer sends one job *almost* instantly after the subscription.\\n\\nSmall engineering note: There's a good reason why first job is not included directly in subscription response - miner will need to handle one response type in two different way; firstly as a subscription response and then as a standalone notification. Hook job processing just to JSON-RPC notification sounds a bit better to me.\\n\\n```json\\n{\\\"params\\\": [\\\"bf\\\", \\\"4d16b6f85af6e2198f44ae2a6de67f78487ae5611b77c6c0440b921e00000000\\\",\\\"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff20020862062f503253482f04b8864e5008\\\",\\\"072f736c7573682f000000000100f2052a010000001976a914d23fcdf86f7e756a64a7a9688ef9903327048ed988ac00000000\\\", [],\\\"00000002\\\", \\\"1c2ac4af\\\", \\\"504e86b9\\\", false], \\\"id\\\": null, \\\"method\\\": \\\"mining.notify\\\"}\\n```\\n\\nNow we finally have some interesting stuff here! I'll descibe every field of the notification in the particular order:\\n\\n* job_id - ID of the job. Use this ID while submitting share generated from this job.\\n* prevhash - Hash of previous block.\\n* coinb1 - Initial part of coinbase transaction.\\n* coinb2 - Final part of coinbase transaction.\\n* merkle_branch - List of hashes, will be used for calculation of merkle root. This is not a list of all transactions, it only contains prepared hashes of steps of merkle tree algorithm. Please read some materials for understanding how merkle trees calculation works. Unfortunately this example don't have any step hashes included, my bad!\\n* version - Bitcoin block version.\\n* nbits - Encoded current network difficulty\\n* ntime - Current ntime/\\n* clean_jobs - When true, server indicates that submitting shares from previous jobs don't have a sense and such shares will be rejected. When this flag is set, miner should also drop all previous jobs, so job_ids can be eventually rotated.\\n\\n#### How to Build Coinbase Transaction\\n\\nNow miner received all data required to serialize coinbase transaction: Coinb1, Extranonce1, Extranonce2_size and Coinb2. Firstly we need to generate Extranonce2 (must be unique for given job_id!). Extranonce2_size tell us expected length of binary structure. Just be absolutely sure that your extranonce2 generator always produces extranonce2 with correct length! For example my pool implementation sets extranonce2_size=4, which mean this is valid Extranonce2 (in hex): 00000000.\\n\\nTo produce coinbase, we just concatenate Coinb1 + Extranonce1 + Extranonce2 + Coinb2 together. That's all!\\n\\nFor following calculations we have to produce double-sha256 hash of given coinbase. In following snippets I'm using Python, but I'm sure you'll understand the concept even if you're a rubyist! It is as simple as:\\n\\n```javascript\\nimport hashlib\\nimport binascii\\ncoinbase_hash_bin = hashlib.sha256(hashlib.sha256(binascii.unhexlify(coinbase)).digest()).digest()\\n```\\n\\n#### How to Build Merkle Root\\n\\nFollowing Python snippet will generate merkle root for you. Use merkle_branch from broadcast and coinbase_hash_bin from previous snippet as an input:\\n\\n```javascript\\nimport binasciidef\\nbuild_merkle_root(self, merkle_branch, coinbase_hash_bin):\\n  merkle_root = coinbase_hash_bin\\n  for h in self.merkle_branch:\\n    merkle_root = doublesha(merkle_root + binascii.unhexlify(h))\\n  return binascii.hexlify(merkle_root)\\n```\\n\\n#### How to Build Block Header?\\n\\nNow we're almost done! We have to put all together to produce block header for hashing:\\n\\n```javascript\\nversion + prevhash + merkle_root + ntime + nbits + '00000000' +'000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'\\n```\\n\\nFirst zeroes are blank nonce, the rest is padding to uint512 and it is always the same.\\n\\nNote that merkle_root must be in reversed byte order. If you're a miner developer, you already have util methods there for doing it. For some example in Python see Stratum mining proxy source codes.\\n\\n#### Server Can Occasionally Ask Miner to Change Share Difficulty\\n\\nDefault share difficulty is 1 (big-endian target for difficulty 1 is 0x00000000ffff0000000000000000000000000000000000000000000000000000), but server can ask you anytime during the session to change it:\\n\\n```json\\n{ \\\"id\\\": null, \\\"method\\\": \\\"mining.set_difficulty\\\", \\\"params\\\": [2]}\\n```\\n\\nThis Means That Difficulty 2 Will Be Applied to Every Next Job Received From the Server.\\n\\n#### How to Submit Share?\\n\\nWhen miner find the job which meets requested difficulty, it can submit share to the server:\\n\\n```json\\n{\\\"params\\\": [\\\"slush.miner1\\\", \\\"bf\\\", \\\"00000001\\\", \\\"504e86ed\\\", \\\"b2957c02\\\"], \\\"id\\\": 4, \\\"method\\\": \\\"mining.submit\\\"}{\\\"error\\\": null, \\\"id\\\": 4, \\\"result\\\": true}\\n```\\n\\nValues in particular order: worker_name (previously authorized!), job_id, extranonce2, ntime, nonce.\\n\\nThat's it!\\n\\n## 4. Downloads\\n\\n* [Stratum mining proxy](http://www.github.com/slush0/stratum-mining-proxy) - Source code of Stratum proxy on Github\\n* [Windows binaries (EXE) of Stratum mining proxy](https://slushpool.com/media/download/mining_proxy.exe) - Detailed instructions can be found [here](https://slushpool.com/help/#!/get-started/mining-proxy).\\n* [Stratum mining pool](http://www.github.com/slush0/stratum-mining) - Opensource bitcoin mining pool build on Stratum server framework in Python.\\n\\n## 5. Compatible Miners\\n\\nFor all current getwork-compatible miners you can use [Stratum mining proxy](https://slushpool.com/help/#!/manual/stratum-protocol#download) running locally on your mining computer. One mining proxy can handle (almost) unlimited number of connectedworkers, so running one proxy for all of your mining rigs is a way to go.\\n\\nMiners with native support of Stratum protocol (no proxy needed!)\\n\\n* [bfgminer](http://bfgminer.org/)\\n* [cgminer](https://bitcointalk.org/index.php?topic=28402.0) (version 2.8.1 and newer)\\n* [poclbm](https://bitcointalk.org/index.php?topic=1334.0) (version 20120920 and newer)\\n\\nIf you want support of Stratum protocol in your miner, just ask its developer and show him this page. Also don't hesitate to contact me and ask for implementation details.\",\"timestamp\":1638864467,\"title\":\"Stratum Mining Protocol(slushpool)\"},\"digest\":\"-K3GrEBSSe1VtvUEaIK7eQYNehr9uCc5H6UK44CqckU\",\"authorship\":{\"contributor\":\"0x94C0e8Cf59e644fA76d4Fa83164B9F2030d07F31\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"DCwEHt3t8nlX4_6pSoeUsqsUzraEuAbxkeDQyucgxtE\\\",\\\"y\\\":\\\"LXf1Gzm8IGA_Q0hf0tfYvV5jP4DrU-9ViDZ4Cv3SC5o\\\"}\",\"signature\":\"ZXyEkYIXF60RdQEklgzVSqvGTHFSrN7pNr65tZrSMG33wJZgIQDPz6mEfj6CXE3qL77QaNMsTlA2p0Fe3Kq4fw\",\"signingKeySignature\":\"0x62f89b5c41902fb93107569b052b887fcc676e9a5d6efc9202fc6502c0f4046b274d4bd876db5df0c4a9f4fa30f6afc569078d61188eb466ba6a54c994cb10741c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"DCwEHt3t8nlX4_6pSoeUsqsUzraEuAbxkeDQyucgxtE\\\",\\\"y\\\":\\\"LXf1Gzm8IGA_Q0hf0tfYvV5jP4DrU-9ViDZ4Cv3SC5o\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"LiCll74wWdNb1sofluZLZTtQe4mySQHMV58HM6VJ0OY\"}"