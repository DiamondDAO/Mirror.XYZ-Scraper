"{\"content\":{\"body\":\"I've been an active participant and benefactor of web2 over the last 10 years. Worked for most of the major web2 companies including the likes of Microsoft, Akamai, Oracle & Google.\\n\\nNothing has gotten me more excited than web3, which I've deliberated taken a plunge into in the last few weeks. As a beginner, I'm literally mind-blown by the number of community resources available to get things started on Web3. The sheer number of blogs, videos, tutorials & dApps are both intimidating and exciting at the same time.\\n\\nSo I decided to get my hands dirty with web3 and decided to write a small voting app (definitely inspired by some of the official examples available on the solidity documentation).\\n\\nSo what are going to build? A very, very, very basic voting dApp!\\n\\nNow, what's a dApp? Read this gentle introduction to dApp [here](https://www.oreilly.com/library/view/decentralized-applications/9781491924532/ch01.html)\\n\\nNow, why Voting? From my research, I realised that the web3 differs from web2 at a fundamental level. Web3 is all about giving the power back to the users. It's changing the way technology is seen, operated, bought and sold at a foundational level.\\n\\nHere are some examples of where Web3 is being transormative:\\n\\n**Infrastructure** - Web3 shifts the cost of running the system to the same actors that benefit from it E.g. Decentralised Storage, Peer-to-Peer CDN, Decentralised Cloud etc.\\n\\n**Platform** - Joining a social community/platform does not only make you a community member. It also makes you a co-owner of the platform. As a result, the platform is a sum of the contributors\\n\\nNow, from my research, I've realised that Voting is one of the easiest ways to explain the principles of web3. Voting is the fundamental aspect of democracy. Ideally, it makes everyone participate and benefit from the platform at the same time. This is exactly why I believe \\\"A voting app\\\" is the \\\"Hello World\\\" of Web3.\\n\\nJumping right into the core constructs of our basic voting app. In this first release of our web3 voting app, we are going to be implementing a basic version with the following requirements:\\n\\n![Screenshot 2021-11-30 at 11.49.47 AM.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1638253196368/ve_A23Lgc.png?auto=compress,format\\\\&format=webp)\\n\\nNote: There's no central authority in this voting process. So the civilians cast their vote on the blockchain and the results are computed and stored in the same chain.\\n\\n**Here's what we need to implement this** :\\n\\n*   Solidity - A high-level language for implementing a smart contract\\n*   Hardhat - An Ethereum development environment for deploying our contract\\n*   Simulated Ethereum network (Hardhat handles this part).\\n\\nFor the impatient, you can find the code [here](https://github.com/couchrishi/voting-dApp-1) **First let's set up your project**\\n\\nGo to the folder where you want to run this project and do the following -\\n\\n    npm init -y \\n    npm install --save-dev hardhat\\n    npx hardhat     //Creates a Basic project. You should see the project folder structure now. \\n    npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers     // installing dependencies\\n    npx hardhat accounts       // Shows simulated ethereum addresses\\n    npx hardhat compile  // Make sure it works fine\\n    npx hardhat test // Should show sample test output\\n\\n**What should our smart contract execute?**\\n\\n1.  Each sender can vote only once\\n2.  The voter should be able to select the candidate of choice (proposal)\\n3.  Should be able to query the blockchain and find out who won\\n\\n**Under the contracts folder, create Ballot.sol**\\n\\n    pragma solidity >=0.7.0 <0.9.0;\\n    import \\\"hardhat/console.sol\\\";\\n\\n    /// @author @courchrishi\\n    /// @title Voting dApp - Part-1\\n\\n    contract Ballot {\\n        // Declares a complex type (Struct) for representing a single voter\\n\\n        struct Voter {\\n            bool voted;     // if true, the person has already voted\\n            uint vote;      // index of the voted proposal\\n            uint weight;    // weight will be 1 since this is a non-delegated scenario\\n        }\\n\\n        // Declares a complex type (Struct) for a single proposal\\n        struct Proposal {\\n            string name;      // short name (up to 32 bytes)\\n            uint voteCount;         // number of accummulated votes\\n        }\\n\\n        // Declares a state variable (or) mapping that stores a 'Voter' struct for each address\\n        mapping(address => Voter) public voters;    \\n\\n        // A dynamically-sized array of 'Proposal' structs\\n        Proposal[] public proposals;\\n\\n        // A function to register the vote\\n        function vote(uint proposal) external {\\n           /// Initial checks for the sender before getting qualified as a voter\\n            Voter storage sender = voters[msg.sender]; // 1. Creating a Voter Struct and mapping to the sender's address\\n            require(!sender.voted, \\\"Already voted\\\");  // 2. Should not have already voted\\n            sender.voted = true; // Setting the voted flag to true\\n            sender.vote = proposal; // Setting the proposed vote to the vote property\\n            proposals[proposal].voteCount += 1;  // Updating the canditate's votecount\\n\\n        }\\n\\n        // /// Creates a new ballot to choose one of 'proposalNames'. Initiated at the time of contract deployment\\n\\n        constructor(string[] memory proposalCandidates) {\\n            // 'Proposal({...}) creates a temporary proposal object \\n            // proposals.push(...) appends it to the end of the proposals array\\n\\n            for (uint i = 0; i < proposalCandidates.length; i++) {\\n                // `Proposal({...})` creates a temporary\\n                // Proposal object and `proposals.push(...)`\\n                // appends it to the end of `proposals`.\\n                proposals.push(Proposal({ name: proposalCandidates[i], voteCount:0}));\\n            }\\n\\n        }\\n\\n        function winningProposal() public view returns (uint winningProposal_) {\\\\\\n            uint winningCount = 0; \\n            for(uint i=0; i < proposals.length; i++) {\\n                if(proposals[i].voteCount > winningCount) {\\n                    winningCount = proposals[i].voteCount;\\n                    winningProposal_ = i;\\n                    }\\n             }\\n        }\\n\\n        function getElectionResult() external view returns(string memory winnerName_){\\n            winnerName_ = proposals[winningProposal()].name;\\n        }\\n\\n    }\\n\\nNow, let us simulate a voting exercise where civilians cast their vote by registering their proposals. We will write logic to create the following tests -\\n\\n1.  Upload the list of candidates to our \\\"Ballot\\\" smart contract\\n2.  Let 4 civilians cast their vote by registering their candidate proposal\\n3.  Query the blockchain to get the winner of the election\\n\\n**For this, we need to create a \\\"run.js\\\" file under the \\\"Scripts\\\" folder**\\n\\n    const web3 = require(\\\"web3\\\");\\n\\n    const main = async (names) => {\\n      const [owner, civilian1, civilian2, civilian3] =\\n      await hre.ethers.getSigners();\\n      const ballotFactory = await hre.ethers.getContractFactory(\\\"Ballot\\\");\\n      console.log(typeof names);\\n      const ballotContract = await ballotFactory.deploy(names);\\n\\n      await ballotContract.deployed();\\n      console.log(\\\"Contract Deployed to:\\\", ballotContract.address);\\n      console.log(\\\"Contract deployed by:\\\", owner.address);\\n\\n      await ballotContract.vote(1);\\n      await ballotContract.connect(civilian1).vote(1);\\n      await ballotContract.connect(civilian2).vote(1);\\n      await ballotContract.connect(civilian3).vote(2);\\n\\n      const winner = await ballotContract.getElectionResult();\\n      console.log(winner);\\n    };\\n\\n    const runMain = async (names) => {\\n      try {\\n        await main(names);\\n        process.exit(0);\\n      } catch (error) {\\n        console.log(error);\\n        process.exit(1);\\n      }\\n    };\\n\\n    runMain([\\\"candidate-1\\\", \\\"candidate-2\\\", \\\"candiate-3\\\"]);\\n\\nYou should see the following output with the 'declared' winner coming from the blockchain -\\n\\n![Screenshot 2021-11-30 at 12.13.04 PM.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1638254616751/odvsJv-1I.png?auto=compress,format\\\\&format=webp)\\n\\nThat's it! You have a basic voting app working. As you must have noticed, this is a basic app. We still haven't considered many other conditions such as\\n\\n1.  What if two candidates get equal vote?\\n2.  What if a voter wants to delegate their vote to someone else?\\n3.  How about having a chairperson who can give the right to vote each address individually?\\n4.  How about incentivising the voters to participate in the election by rewarding them with some ether?\\n\\nIn the next part, we will try to enhance our voting dApp with a few of the aforementioned features. Cheers!\\n\",\"timestamp\":1638278051,\"title\":\"Voting dApp Series - A Gentle Introduction to Web3\"},\"digest\":\"oh2l1yC_0-0gTWZ4Es4t90eEdsv1G25ZpXLvecyxteY\",\"authorship\":{\"contributor\":\"0x01CdEB35DFeaB0e73c2cE470e6eAb04F0837AAAc\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XT2Sapw-VOVp-D46xsHD5XPcjW6h3fcTfLXxu9lSV6I\\\",\\\"y\\\":\\\"yc3zQOepoR6PRdv42Tqp4ntcxvr-kIWuNwJVuf8phtQ\\\"}\",\"signature\":\"-YRq_NtPTzi2LCEzjloA_inVCm0bOvBdemMD2BEkR4BA7QR50qCIh5F8g9ObL-_SgWkNwDIJXRut8NswOwnzrA\",\"signingKeySignature\":\"0x7de867eae9a46dcf81b1858d203f408b17d4aa3e4beb626264aab8617cf025ae1e6ede1e50f0d495f20d19b8b153172570d851278b02b5e34c0d324ac9b2c5e81b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XT2Sapw-VOVp-D46xsHD5XPcjW6h3fcTfLXxu9lSV6I\\\",\\\"y\\\":\\\"yc3zQOepoR6PRdv42Tqp4ntcxvr-kIWuNwJVuf8phtQ\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"oh2l1yC_0-0gTWZ4Es4t90eEdsv1G25ZpXLvecyxteY\"}"