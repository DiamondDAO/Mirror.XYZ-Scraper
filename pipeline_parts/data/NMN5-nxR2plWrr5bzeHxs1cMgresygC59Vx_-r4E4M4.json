"{\"content\":{\"body\":\"### What is curl?\\n\\ncURL 是一个利用 URL 语法在命令行下工作的文件传输工具，1997 年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称 cURL 为下载工具。\\n\\n### Curl and Wget?\\n\\n1\\\\.curl是libcurl这个库支持的，wget是一个纯粹的命令行命令。\\n\\n2\\\\.curl支持更多的协议。curl supports FTP, FTPS, HTTP, HTTPS, SCP, SFTP, TFTP, TELNET, DICT, LDAP, LDAPS, FILE, POP3, IMAP, SMTP and RTSP at the time of this writing. Wget supports HTTP, HTTPS and FTP.\\n\\n3\\\\.curl 默认支持HTTP1.1（也支持1.0），而wget仅仅支持 **HTTP1.0** 规范。引用wget的man page.\\n\\n```tex\\nPlease be aware that Wget needs to know the size of the POST data in advance. It's not quite clear how to work around this limitation inherent in HTTP/1.0. Although HTTP/1.1 introduces chunked transfer that doesn't require knowing the request length in advance, a client can't use chunked unless it knows it's talking to an HTTP/1.1 server. And it can't know that until it receives a response, which in turn requires the request to have been completed -- a chicken-and-egg problem.\\n```\\n\\n4\\\\.curl在指定要下载的链接时能够支持URL的序列或集合，而wget则不能这样;\\n\\n5\\\\.wget支持递归下载，而curl则没有这个功能。（这是wget的一个主要好处，wget也是有优势的）\\n\\n### HTTP 1.0/1.1/2\\n\\n1. HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接\\n2. HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。\\n3. HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。\\n4. HTTP 2 在底层传输做了很大的改动和优化：\\n   * HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。\\n   * 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。\\n   * 多路复用，直白的说就是所有的请求都是通过一个TCP 连接并发完成。HTTP/1.x 虽然通过 [pipeline](http://en.wikipedia.org/wiki/HTTP_pipelining) 也能并发请求，但是多个请求之间的响应会被[阻塞](http://en.wikipedia.org/wiki/Head-of-line_blocking)的，所以 [pipeline](http://en.wikipedia.org/wiki/HTTP_pipelining) 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，还支持优先级和流量控制。\\n   * Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。\\n\\n​    HTTP/2 主要是 HTTP/1.x 在底层传输机制上的完全重构，HTTP/2 是基本兼容 HTTP/1.x 的语义。Content-Type 仍然是 Content-Type，只不过它不再是文本传输了。\\n\\n### Https\\n\\nhttp本身不具备加密功能，报文使用明文（未经加密的报文）方式发送，通信内容在所有的通信线路上都有可能遭到窥视\\n\\n加密处理的两种方式:\\n\\n```\\n1. 通信的加密：将http和SSL（安全套接层）或者TLS（安全传输层协议）组合使用，与SSL组合使用的HTTP被称为HTTPS（超文本传输安全协议）\\n2. 内容的加密：通信双方都要求有加密和解密的机制，仍有被篡改的风险\\n```\\n\\n​    HTTPS = HTTP + 加密 + 认证 + 完整性保护\\n\\n### HTTPS的加密算法\\n\\n**对称秘钥**:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。通常有两种模式：**流加密和分组加密。**\\n\\n**非对称秘钥**：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\\n\\n**HTTPS保证数据安全的机制：**\\n\\n在HTTP的概念中介绍了HTTP是非常不安全的，那么在服务器与客户端传递数据的过程中HTTPS是如何保证数据的安全呢？\\n\\n```\\n1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）\\n\\n2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；\\n\\n3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；\\n\\n4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。\\n\\n5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。\\n```\\n\\n**CA（电子商务认证机构）认证作用：**\\n\\n​\\t在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。\\n\\n为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。\\n\\n**Http与Https的区别**：\\n\\n1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头\\n2. HTTP 是不安全的，而 HTTPS 是安全的\\n3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443\\n4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层\\n5. HTTP 无法加密，而HTTPS 对传输的数据进行加密\\n6. HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书\\n\\n### Rest API\\n\\n1. 限制GET请求长度的是浏览器，不是HTTP协议\\n2. \\n\\n### TCP/UDP\\n\\n### Tools\\n\\nFtp(All Platfroms)： [FileZilla](https://filezilla-project.org/)\",\"timestamp\":1641032924,\"title\":\"Recording Something Missing in Software Engineering Education\"},\"digest\":\"XBcNG6ALFGBDBl9xVZL_hD_NXkpwfpRz7fgDyKomiNE\",\"authorship\":{\"contributor\":\"0x61bA446A351177d84435860EeABD896ce175a073\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"erjK2NOgPPB3aOlFA5GJBaw8XnhhiuQRpjRA3PDjafk\\\",\\\"y\\\":\\\"kOHbLL0E87uwuiB8UbhAY0NrG5PZwvtyrBP-d4-2DF8\\\"}\",\"signature\":\"o5pXAn5mRK0qgWDQMQsYJ9WWY12PmXN2SmUOUr-hGtjmvTQi8L7wTL81HdQAvuVXUKVJ9_JZp_d99dQNd_5U8A\",\"signingKeySignature\":\"0x93e5bd7014a357b46c6bf684b4df465cb029534b67a5c9c94f8da058f0e50d767acda9a1304664e4fc0c99f198582c655873a0b082e850c1201b4e6cc8123d711b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"erjK2NOgPPB3aOlFA5GJBaw8XnhhiuQRpjRA3PDjafk\\\",\\\"y\\\":\\\"kOHbLL0E87uwuiB8UbhAY0NrG5PZwvtyrBP-d4-2DF8\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"XBcNG6ALFGBDBl9xVZL_hD_NXkpwfpRz7fgDyKomiNE\"}"