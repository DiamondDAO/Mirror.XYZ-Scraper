"{\"content\":{\"body\":\"Mirror recently introduced [splits](https://dev.mirror.xyz/mQ03-JXlfdoBnRrZisC5X3kM9nBkOILlHwxbdq382Gw), a native feature that lets you route funds continuously to an unlimited number of Ethereum addresses, according to a set of percentage allocations.\\n\\nBut what did it take for splits to evolve from an idea to a set of efficient, production ready smart contracts on Ethereum? Read the full story in this post!\\n\\n## How do Mirror Splits Work?\\n\\nThere were three problems that we needed to solve for splits:\\n\\n1. Each split needs a unique address that can be used to receive funds from an economic producer (e.g. NFT auction, crowdfund, or just an EOA sending ETH). It needs be cheap to deploy and specify the split allocations.\\n2. Splits need to allow allocations for many accounts, while being relatively cheap to distribute the funds. At first we were thinking in the range of 15-20 accounts.\\n3. Splits need to be reusable — accounts should be able to withdraw and deposit multiple times\\n\\nTo solve the unique address problem, we use a simple proxy pattern that allows us to deploy a contract that only stores some storage variables and delegates all functionality to a core logic contract. This makes it cheap to have unique addresses, and is a fairly common approach in protocol design. It costs 233,315 gas to deploy a Split, which today would be about $50.\\n\\nWhen we first set out to build our split mechanism, we tried a number of different approaches. The first one was naive: a contract with a function that efficiently sends its balance to a pre-set list of addresses cheaply, according to some allocation verified against a hash.\\n\\nBut what if we wanted to split across 30 addresses? This would make it more expensive to operate, since costs scale linearly with the number of allocations. And 100? At that point, the paradigm breaks down completely.\\n\\nWe decided to try a different approach, using some of the core cryptographic primitives of Ethereum to enable cheap splits. In the next section, we'll go over how these work, and how we integrated them into a useful new feature.\\n\\n### Technical Foundations: Understanding Merkle Trees\\n\\nThe Merkle tree is perhaps the most salient data structure in blockchain architecture. It can be used to create a very small representation of a large amount of data, while still enabling one to prove certain information about the original data in an efficient way. \\n\\nTo create and use a Merkle tree, we split our data into chunks, structuring them as a tree (e.g. a binary tree), and then hash the nodes together repeatedly until we get a root hash. We can use the root hash to prove whether some chunk of data was in the original tree at a given location, without needing to share all of the original data. This kind of proof is known as a Merkle Proof.\\n\\n![We can prove the existence of node 2, using only the root hash and a Merkle Proof.\\n](https://images.mirror-media.xyz/publication-images/11b49380-e373-4af2-810f-2823c5baddc2.jpeg?height=1138&width=2024)\\n\\nGiven a public Merkle Root, we can prove that some data (e.g. a balance) exists at a given place in the tree, by verifying a Merkle Proof. For example, we can provide a proof that Hash 2 is in the given place in this tree.\\n\\nA simple application of a Merkle Proof is to create a Merkle tree for a large database of balances, and publish the root. When someone wants to know what the balance is for a given address, we can return the balance and a proof, which can be verified (assuming you trust the published root) without downloading the contents of the database.\\n\\nTherefore, we can prove facts of a large dataset, even when we only access a very small amount of data. Each block in Ethereum contains multiple Merkle trees to prove various aspects of Ethereum's state and state transitions.\\n\\n### On-chain Merkle Proofs\\n\\nWhile Merkle Proofs have been primarily used as the foundation of core blockchain architecture, they have also found uses in applications built on top of blockchains. \\n\\nSmart contracts that verify Merkle Proofs have been around for many years — for example [Raiden's implementation](https://github.com/raiden-network/raiden/blob/5a82ff6799c94c11df57f3b545ac3eb2381aa89c/raiden/smart_contracts/NettingChannelLibrary.sol#L291-L345) in early 2017, and Ameen Soleimani's later [port of it](https://github.com/ameensol/merkle-tree-solidity). \\n\\nThe most popular application has probably been [Uniswap's 2021 airdrop of 150 million UNI](https://uniswap.org/blog/uni/) to hundreds of thousands of addresses. It would have been infeasible to airdrop tokens to this many addresses without Merkle Proofs — the proofs allowed users to retroactively *claim* their share of the airdrop, instead of Uniswap needing to send an ERC20 transaction to each address up-front.\\n\\n### Integration with Splits on Mirror\\n\\nWith Splits, our goal was to allow someone to specify a list of funding allocations of any length, and then allow those accounts to withdraw funds according to their allocation — without costing the deployer or funder an excessive amount of gas.\\n\\nSo we built upon the existing open-source solutions that used Merkle proofs for airdrops — namely, [Uniswap's implementation](https://github.com/Uniswap/merkle-distributor) — and changed it to allow for a percentage allocation instead of an exact amount. We also added some more functionality to allow for continual use of the contract. One can fund the contract multiple times and allow recipients to keep claiming their allocation. We have open-sourced Splits here: [https://github.com/mirror-xyz/splits](https://github.com/mirror-xyz/splits)\\n\\nThe challenge with allowing continual claiming of an allocation is that, once someone has claimed their allocation, we need some way to prevent them from claiming the same quantity again. A recipient should only be able to claim once from a given deposit.\\n\\n**Claim Windows**\\n\\nOne way to solve this problem would be to track each claim, but this would use a lot of storage and gas to operate. Instead, we decided to add a concept of a claim \\\"window\\\" — an interval for which you could claim an allocation, at any time. The flow for this model is as follows:\\n\\n1. The allocation is specified, and the Merkle proof is set on the contract\\n2. Funds are deposited into the contract\\n3. The window is incremented from 0 to 1\\n4. Anyone can claim their allocation for the first window\\n5. More funds are added\\n6. The window is incremented from 1 to 2\\n7. Anyone can claim their allocation for the first or the second window, or both in the same transaction\\n\\nIn this way, we allowed perpetual claiming of allocations from a contract using Merkle proofs!\\n\\n## Future Work\\n\\nWe think it would be interesting if someone could claim their funds across multiple splits from one address. This would allow someone to accrue revenue continuously from being involved in different splits, and then be able to withdraw all of that in one transaction.\\n\\nIt's also unclear at the moment how this is implemented on layer 2. It might be the case that L2 transfers are so cheap that much of this is over-engineering for a given use-case. We'll have to do more experiments to see, but at the moment there is some demand for this functionality directly on L1.\\n\\nIt would also be interesting to see this architecture being used for important projects such as governance funding — whereby a percentage allocation is budgeted for different departments, and now can be fully transparent and on-chain.\\n\\nWe've also received feedback from people that they'd like to see a real-time dashboard of all the created splits and how much people have received over time. Eventually it could become one component of generating on-chain reputation for applications like credit scores.\\n\\n*It is important to note that splits currently only work with ETH. ERC-20 tokens sent to a split will be permanently lost.*\",\"timestamp\":1620324160,\"title\":\"Engineering Splits\",\"publication\":\"dev\"},\"digest\":\"V_7Jp1hy_g8bz-J1B4Wb5KYSmj5Lt4W7q7cw0noxJsU\",\"authorship\":{\"contributor\":\"0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"2ajcgcwbp1aQz63wqVBHgvY2JI1LjIPr218cgklSVlM\\\",\\\"y\\\":\\\"y9BSSzZEb9aW08OEayzjB7B6Q560GfE-MK34UPZoQWk\\\"}\",\"signature\":\"ZRcWavcmHusy3Q33oA7vPK4LOYpP2jRO2A8j8nY2hWSh8CYZdE9MGiz_sqAjYu5XY4k4Cw_orXASajtt3qREiA\",\"signingKeySignature\":\"0xe0414f7e9b15253e2d56ec0768fa1dc5ca41e0201a1e6fcb2b52912b896147a94c111cfe42f2b496b140ed0729249b9127d6a3472ec2f5b401fd25f04097302a1c\",\"signingKeyMessage\":\"I authorize the publication of articles on dev.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"2ajcgcwbp1aQz63wqVBHgvY2JI1LjIPr218cgklSVlM\\\",\\\"y\\\":\\\"y9BSSzZEb9aW08OEayzjB7B6Q560GfE-MK34UPZoQWk\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"V_7Jp1hy_g8bz-J1B4Wb5KYSmj5Lt4W7q7cw0noxJsU\"}"