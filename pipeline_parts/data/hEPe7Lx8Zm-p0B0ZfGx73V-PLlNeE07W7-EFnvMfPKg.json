"{\"content\":{\"body\":\"> 在查看一些资料的时候, 发现到大家都说 Java 的反射效率低, 那么到底是为什么呢?\\n>\\n> 本文主要来探索这个问题, 本文基于的环境为\\n>\\n> java version \\\"1.8.0_221\\\" Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)\\n>\\n> 主要参考:\\n>\\n> [大家都说 Java 反射效率低, 你知道原因在哪里么](https://juejin.cn/post/6844903965725818887#heading-7)\\n>\\n> [关于反射调用方法的一个log](https://www.iteye.com/blog/rednaxelafx-548536)\\n\\n## 1. 先说结论\\n\\n**Java 反射效率低主要原因是**\\n\\n1. Method#invoke 方法会对参数做封装和解封操作\\n2. 需要检查方法可见性\\n3. 需要校验参数\\n4. 反射方法难以内联\\n5. JIT 无法优化\\n\\n## 2. 获取反射的方法\\n\\n先看示例代码如下,\\n\\n```java\\npublic class RefA {\\n    public void foo(String str) {\\n        System.out.println(\\\"str: \\\" + str);\\n    }\\n}\\n\\npublic class RefTest {\\n    public static void main(String[] args){\\n        try {\\n            Class<?> clz = Class.forName(\\\"com.joe.test.RefA\\\");\\n            Object o = clz.newInstance();\\n            Method m = clz.getMethod(\\\"foo\\\", String.class);\\n            for (int i = 0; i < 16; i++) {\\n                m.invoke(o, Integer.toString(i));\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n```\\n\\n上面是很简单的一段反射的使用, `RefTest` 类上不会有对类 `RefA` 的符号依赖——也就是说在加载并初始化`RefTest` 类时不需要关心类 `RefA `的存在与否, 而是等到`main()`方法执行到调用`Class.forName()`时才试图对类 `RefA` 做动态加载; 这里用的是一个参数版的`forName()`, 也就是使用当前方法所在类的`ClassLoader`来加载, 并且初始化新加载的类\\n\\n编译上述代码, 并在执行 `RefTest` 时加入 `-XX:+TraceClassLoading` 参数\\n\\n截取关键log如下\\n\\n```wiki\\n[Loaded com.joe.test.RefTest from file:/E:/Projects/IdeaPorject/review/basic/target/classes/]\\n[Loaded sun.launcher.LauncherHelper$FXHelper from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded java.lang.Class$MethodArray from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded java.lang.Void from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded com.joe.test.A from file:/E:/Projects/IdeaPorject/review/basic/target/classes/]\\nstr: 0\\nstr: 1\\nstr: 2\\nstr: 3\\nstr: 4\\nstr: 5\\nstr: 6\\nstr: 7\\nstr: 8\\nstr: 9\\nstr: 10\\nstr: 11\\nstr: 12\\nstr: 13\\nstr: 14\\n[Loaded sun.reflect.ClassFileConstants from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.AccessorGenerator from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.MethodAccessorGenerator from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ByteVectorFactory from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ByteVector from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ByteVectorImpl from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ClassFileAssembler from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.UTF8 from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.Label from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.Label$PatchInfo from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.MethodAccessorGenerator$1 from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ClassDefiner from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.ClassDefiner$1 from E:\\\\Dev\\\\Java\\\\jdk1.8.0_221\\\\jre\\\\lib\\\\rt.jar]\\n[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]\\nstr: 15\\n```\\n\\n### 2.1 从获取反射开始\\n\\n在调用反射时, 首先会创建 Class 对象, 然后获取其 Method 对象, 调用 invoke 方法 获取反射方法时, 有两个方法, `getMethod` 和 `getDeclaredMethod`, 我们就从这两个方法开始, 一步步看下反射的原理\\n\\n```java\\n@CallerSensitive\\npublic Method getMethod(String name, Class<?>... parameterTypes)\\n    throws NoSuchMethodException, SecurityException {\\n    // 检查方法权限\\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\\n    // 获取方法\\n    Method method = getMethod0(name, parameterTypes, true);\\n    if (method == null) {\\n        throw new NoSuchMethodException(getName() + \\\".\\\" + name + argumentTypesToString(parameterTypes));\\n    }\\n    return method;\\n}\\n\\n\\n@CallerSensitive\\npublic Method getDeclaredMethod(String name, Class<?>... parameterTypes)\\n    throws NoSuchMethodException, SecurityException {\\n    // 检查方法权限\\n    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);\\n    // 获取方法\\n    Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);\\n    if (method == null) {\\n        throw new NoSuchMethodException(getName() + \\\".\\\" + name + argumentTypesToString(parameterTypes));\\n    }\\n    return method;\\n}\\n```\\n\\n以上, 可以看出, 获取方法的流程基本上就是首先检查方法权限, 是否可以访问, 然后获取方法对象, 返回其引用.\\n\\n`getMethod` 和 `getDeclaredMethod` 的主要区别有:\\n\\n1. `getMethod `中 `checkMemberAccess `传入的是 `Member.PUBLIC`, 而 `getDeclaredMethod `传入的是 `Member.DECLARED`\\n\\n   ```java\\n   /**\\n    * Identifies the set of all public members of a class or interface,\\n    * including inherited members.\\n    */\\n   public static final int PUBLIC = 0;\\n   \\n   /**\\n    * Identifies the set of declared members of a class or interface.\\n    * Inherited members are not included.\\n    */\\n   public static final int DECLARED = 1;\\n   ```\\n\\n   通过注释明显看到, PUBLIC 包括继承的成员, DECLARED 不包括继承的成员\\n2. `getMethod ` 获取方法调用的是 `getMethod0`, 而 `getDeclaredMethod` 调用的是 `searchMethods`;\\n\\n   `privateGetDeclaredMethods `是获取类自身定义的方法, 参数是 `boolean publicOnly`, 表示是否只获取公共方法\\n\\n   而 `getMethod0 `会递归查找父类的方法, 其中会调用到 `privateGetDeclaredMethods `方法\\n\\n可以根据自己的需要选择使用合适的方法, 我们想要详细的分析反射的过程, 所以选择 `getMethod`\\n\\n### 2.2 getMethod() 流程\\n\\n<img src=\\\"<https://gitee.com/JoeMendez/picGoImages/raw/master/img/20201228223314.png>\\\" alt=\\\"image-20201228223312414\\\" style=\\\"zoom:80%;\\\" />\\n\\n## 3. 调用反射的方法\\n\\n获取到方法以后, 通过 `Method#invoke` 调用方法\\n\\n```java\\n// java.lang.reflect.Method\\n\\n@CallerSensitive\\npublic Object invoke(Object obj, Object... args)\\n    throws IllegalAccessException, IllegalArgumentException,InvocationTargetException {\\n    if (!override) {\\n        // 1. 检查权限\\n        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\\n            Class<?> caller = Reflection.getCallerClass();\\n            checkAccess(caller, clazz, obj, modifiers);\\n        }\\n    }\\n    // 2. 获取 MethodAccessor\\n    MethodAccessor ma = methodAccessor;             // read volatile\\n    if (ma == null) {\\n        // 创建 MethodAccessor\\n        ma = acquireMethodAccessor();\\n    }\\n    // 3. 调用 MethodAccessor.invoke\\n    return ma.invoke(obj, args);\\n}\\n\\n// java.lang.reflect.Method\\nprivate MethodAccessor acquireMethodAccessor() {\\n    // First check to see if one has been created yet, and take it\\n    // if so\\n    MethodAccessor tmp = null;\\n    if (root != null) tmp = root.getMethodAccessor();\\n    if (tmp != null) {\\n        methodAccessor = tmp;\\n    } else {\\n        // Otherwise fabricate one and propagate it up to the root\\n        tmp = reflectionFactory.newMethodAccessor(this);\\n        setMethodAccessor(tmp);\\n    }\\n\\n    return tmp;\\n}\\n```\\n\\n可以看到, Method#invoke方法不是自己实现反射调用逻辑, 而是委托给 `sun.reflect.MethodAccessor` 来处理\\n\\n每个实际的 Java 方法只有一个对应的 Method 对象作为 root. 这个 root 是不会暴露给用户的, 而是每次在通过反射获取 Method 对象时新创建 Method 对象把 root 包装起来再给用户. 在第一次调用一个实际 Java 方法对应得 Method 对象的 invoke() 方法之前, 实现调用逻辑的 MethodAccessor 对象还没创建; 等第一次调用时才新创建 MethodAccessor 并更新给 root, 然后调用 MethodAccessor.invoke() 真正完成反射调用.\\n\\n### MethodAccessor\\n\\n```java\\n// sun.reflect\\npublic interface MethodAccessor {\\n    // var1 => obj, var2 => args\\n    Object invoke(Object var1, Object[] var2) \\n        throws IllegalArgumentException, InvocationTargetException;\\n}\\n```\\n\\n是一个单接口方法, invoke 与 Method.invoke() 对应.\\n\\n创建 MethodAccessor 实例的是 ReflectionFactory\\n\\n```java\\n// sun.reflect.ReflectionFactory\\n// 该类的注释来自于 R大\\n\\npublic class ReflectionFactory{\\n    \\n    /** We have to defer full initialization of this class until after \\n        the static initializer is run since java.lang.reflect.Method's \\n        static initializer (more properly, that for \\n        java.lang.reflect.AccessibleObject) causes this class's to be \\n        run, before the system properties are set up. */  \\n    private static void checkInitted() {\\n        if (!initted) {\\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\\n                // Tests to ensure the system properties table is fully  \\n                // initialized. This is needed because reflection code is  \\n                // called very early in the initialization process (before  \\n                // command-line arguments have been parsed and therefore  \\n                // these user-settable properties installed.) We assume that  \\n                // if System.out is non-null then the System class has been  \\n                // fully initialized and that the bulk of the startup code  \\n                // has been run.  \\n                public Void run() {\\n                    if (System.out == null) {\\n                        return null;\\n                    } else {\\n                        String var1 = System.getProperty(\\\"sun.reflect.noInflation\\\");\\n                        if (var1 != null && var1.equals(\\\"true\\\")) {\\n                            ReflectionFactory.noInflation = true;\\n                        }\\n\\n                        var1 = System.getProperty(\\\"sun.reflect.inflationThreshold\\\");\\n                        if (var1 != null) {\\n                            try {\\n                                ReflectionFactory.inflationThreshold = Integer.parseInt(var1);\\n                            } catch (NumberFormatException var3) {\\n                                throw new RuntimeException(\\\"Unable to parse property sun.reflect.inflationThreshold\\\", var3);\\n                            }\\n                        }\\n\\n                        ReflectionFactory.initted = true;\\n                        return null;\\n                    }\\n                }\\n            });\\n        }\\n    }\\n    \\n    \\n    public MethodAccessor newMethodAccessor(Method var1) {\\n \\t   \\tcheckInitted();\\n        if (noInflation && !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) {\\n            return (new MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());\\n        } else {\\n            NativeMethodAccessorImpl var2 = new NativeMethodAccessorImpl(var1);\\n            DelegatingMethodAccessorImpl var3 = new DelegatingMethodAccessorImpl(var2);\\n            var2.setParent(var3);\\n            return var3;\\n        }\\n\\t}\\n    \\n}\\n```\\n\\n如注释所述, 实际的MethodAccessor实现有两个版本, 一个是Java实现的, 另一个是native code实现的.\\n\\n一共有三种 MethodAccessor: `MethodAccessorImpl`, `NativeMethodAccessorImpl`, `DelegatingMethodAccessorImpl`\\n\\n采用哪种 MethodAccessor 根据 `noInflation` 进行判断, noInflation 默认值为 false, 只有指定了 sun.reflect.noInflation 属性为 true, 才会采用 MethodAccessorImpl; 所以默认会调用 NativeMethodAccessorImpl\\n\\nJava实现的版本在初始化时需要较多时间, 但长久来说性能较好; native版本正好相反, 启动时相对较快, 但运行时间长了之后速度就比不过Java版了.\\n\\n这是HotSpot的优化方式带来的性能特性, 同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用, 它就像个黑箱一样让虚拟机难以分析也将其内联, 于是运行时间长了之后反而是托管版本的代码更快些.\\n\\n为了权衡两个版本的性能, Sun 的 JDK 使用了“inflation”的技巧：让Java方法在被反射调用时, 开头若干次使用native版, 等反射调用次数超过阈值时则生成一个专用的 MethodAccessor 实现类, 生成其中的invoke()方法的字节码, 以后对该Java方法的反射调用就会使用Java版.\\n\\n> Sun的JDK是从1.4系开始采用这种优化的\\n\\n开头若干次用到的是 `DelegatingMethodAccessorImpl`, 是一个间接层, 方便在 native 和 java 版的 MethodAccessor 之间实现切换\\n\\n```java\\n// sun.reflect.DelegatingMethodAccessorImpl\\nclass DelegatingMethodAccessorImpl extends MethodAccessorImpl {\\n    private MethodAccessorImpl delegate;\\n\\n    DelegatingMethodAccessorImpl(MethodAccessorImpl var1) {\\n        this.setDelegate(var1);\\n    }\\n\\n    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {\\n        return this.delegate.invoke(var1, var2);\\n    }\\n\\n    void setDelegate(MethodAccessorImpl var1) {\\n        this.delegate = var1;\\n    }\\n}\\n```\\n\\n下面是 native 版的 methodAccessor\\n\\n```java\\nclass NativeMethodAccessorImpl extends MethodAccessorImpl {\\n    private final Method method;\\n    private DelegatingMethodAccessorImpl parent;\\n    private int numInvocations;\\n\\n    NativeMethodAccessorImpl(Method var1) {\\n        this.method = var1;\\n    }\\n\\n    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {\\n        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {\\n            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());\\n            this.parent.setDelegate(var3);\\n        }\\n\\n        return invoke0(this.method, var1, var2);\\n    }\\n\\n    void setParent(DelegatingMethodAccessorImpl var1) {\\n        this.parent = var1;\\n    }\\n\\n    private static native Object invoke0(Method var0, Object var1, Object[] var2);\\n}\\n```\\n\\n每次 `NativeMethodAccessorImpl.invoke()` 方法被调用时, 都会增加一个调用次数计数器, 看超过阈值没有; 一旦超过, 则调用`MethodAccessorGenerator.generateMethod()` 来生成 Java 版的 `MethodAccessor` 的实现类, 并且改变`DelegatingMethodAccessorImpl`所引用的 `MethodAccessor` 为 Java 版. 后续经由 `DelegatingMethodAccessorImpl.invoke()` 调用到的就是 Java 版的实现了.\\n\\ninvoke0() 是 native 方法, 在HotSpot VM里是由JVM_InvokeMethod()函数所支持的, 在此就不深入了, 感兴趣的可以看 R 大的分析\\n\\n\\\\###　MethodAccessorGenerator\\n\\n该类的基本工作是在内存里生成新的专用 Java 类, 并将其加载, 这里只贴出一个方法\\n\\n```java\\n// sun.reflect.MethodAccessorGenerator\\n\\nprivate static synchronized String generateName(boolean var0, boolean var1) {\\n    int var2;\\n    if (var0) {\\n        if (var1) {\\n            var2 = ++serializationConstructorSymnum;\\n            return \\\"sun/reflect/GeneratedSerializationConstructorAccessor\\\" + var2;\\n        } else {\\n            var2 = ++constructorSymnum;\\n            return \\\"sun/reflect/GeneratedConstructorAccessor\\\" + var2;\\n        }\\n    } else {\\n        var2 = ++methodSymnum;\\n        return \\\"sun/reflect/GeneratedMethodAccessor\\\" + var2;\\n    }\\n}\\n```\\n\\n对本文开头的例子的A.foo(), 生成的Java版MethodAccessor大致如下:\\n\\n```java\\npackage sun.reflect;  \\n  \\npublic class GeneratedMethodAccessor1 extends MethodAccessorImpl {      \\n    public GeneratedMethodAccessor1() {  \\n        super();  \\n    }  \\n      \\n    public Object invoke(Object obj, Object[] args)     \\n        throws IllegalArgumentException, InvocationTargetException {  \\n        // prepare the target and parameters  \\n        if (obj == null) throw new NullPointerException();  \\n        try {  \\n            A target = (A) obj;  \\n            if (args.length != 1) throw new IllegalArgumentException();  \\n            String arg0 = (String) args[0];  \\n        } catch (ClassCastException e) {  \\n            throw new IllegalArgumentException(e.toString());  \\n        } catch (NullPointerException e) {  \\n            throw new IllegalArgumentException(e.toString());  \\n        }  \\n        // make the invocation  \\n        try {  \\n            target.foo(arg0);  \\n        } catch (Throwable t) {  \\n            throw new InvocationTargetException(t);  \\n        }  \\n    }  \\n}  \\n```\\n\\n就反射调用而言, 这个 `invoke()` 方法非常干净( 然而就“正常调用”而言这额外开销还是明显的).\\n\\n注意到参数数组被拆开了, 把每个参数都恢复到原本没有被 `Object[]` 包装前的样子, 然后对目标方法做正常的 `invokevirtual` 调用. 由于在生成代码时已经循环遍历过参数类型的数组, 生成出来的代码里就不再包含循环了.\\n\\n当该反射调用成为热点时, 它甚至可以被内联到靠近`Method.invoke()`的一侧, 大大降低了反射调用的开销. **而 native 版的反射调用则无法被有效内联, 因而调用开销无法随程序的运行而降低**.\\n\\nSun 的 JDK 这种实现方式使得反射调用方法成本比以前降低了很多, 但 `Method.invoke()` 本身要用数组包装参数;\\n\\n而且每次调用都必须检查方法的可见性(在 `Method.invoke()` 里), 也必须检查每个实际参数与形式参数的类型匹配性(在`NativeMethodAccessorImpl.invoke0()` 里或者生成的 Java 版 `MethodAccessor.invoke()` 里) ; 而且 `Method.invoke()` 就像是个独木桥一样, 各处的反射调用都要挤过去, 在调用点上收集到的类型信息就会很乱, 影响内联程序的判断, 使得`Method.invoke()` 自身难以被内联到调用方.\\n\\n## 4. 总结\\n\\n### 1. Method#invoke 方法会对参数做封装和解封操作\\n\\n可以看到, invoke 方法的参数是 Object\\\\[\\\\] 类型, 也就是说, 如果方法参数是简单类型的话, 需要在此转化成 Object 类型, 例如 long ,在 javac compile 的时候 用了Long.valueOf() 转型, 也就大量了生成了Long 的 Object, 同时 传入的参数是Object\\\\[\\\\]数值,那还需要额外封装object数组. 而在上面 MethodAccessorGenerator#emitInvoke 方法里我们看到, 生成的字节码时, 会把参数数组拆解开来, 把参数恢复到没有被 Object\\\\[\\\\] 包装前的样子, 同时还要对参数做校验, 这里就涉及到了解封操作. 因此, 在反射调用的时候, 因为封装和解封, 产生了额外的不必要的内存浪费, 当调用次数达到一定量的时候, 还会导致 GC\\n\\n### 2. 需要检查方法可见性\\n\\n通过上面的源码分析, 我们会发现, 反射时每次调用都必须检查方法的可见性(在 Method.invoke 里)\\n\\n### 3. 需要校验参数\\n\\n反射时也必须检查每个实际参数与形式参数的类型匹配性 (在NativeMethodAccessorImpl.invoke0 里或者生成的 Java 版 MethodAccessor.invoke 里)\\n\\n### 4. 反射方法难以内联\\n\\nMethod#invoke 就像是个独木桥一样, 各处的反射调用都要挤过去, 在调用点上收集到的类型信息就会很乱, 影响内联程序的判断, 使得 Method.invoke() 自身难以被内联到调用方\\n\\n### 5. JIT 无法优化\\n\\n在 [JavaDoc](https://docs.oracle.com/javase/tutorial/reflect/index.html) 中提到：\\n\\n> Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.\\n>\\n> 因为反射涉及动态解析的类型, 所以某些Java虚拟机优化无法执行. 因此, 反射操作的性能比非反射操作慢, 应该避免在对性能敏感的应用程序中频繁调用的代码段中使用反射操作\\n\\n因为反射涉及到动态加载的类型, 所以无法进行优化\",\"timestamp\":1642148602,\"title\":\"关于 Java 反射效率问题\"},\"digest\":\"PXYBWM7q8rwKvGuVjLj4p9iFWrQD0P8vS-AJgSs_Zws\",\"authorship\":{\"contributor\":\"0xB94ce874bef7472b0B3D18BF5bDb7Ba74f2d110A\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"v__e3LARGE91pieFQlTqRl11qA1bB1sghq6au-fAmdE\\\",\\\"y\\\":\\\"gAx1yyBxHcJGcalIeAlnRWLbeSvF_zaChRyvEyuNiMI\\\"}\",\"signature\":\"HVz_CMJX4Qh9u85mzI2G6FtuUu9iNSyaFkp-sY091kktmQ2Tiqg3VBcywYaB3oEvk6KFE2zfgHzrXDf7V_uGfQ\",\"signingKeySignature\":\"0xe32baeb937a1a26201ec42db89f6d53ad9a483bed3ae61c6d1cf8b8c8bf53b39058086f89f11da10f69f11d32e66db1ff170f7144d3aba5579709f1b4037bd691c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"v__e3LARGE91pieFQlTqRl11qA1bB1sghq6au-fAmdE\\\",\\\"y\\\":\\\"gAx1yyBxHcJGcalIeAlnRWLbeSvF_zaChRyvEyuNiMI\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"3xJ6XZLpBoUCEA1x-xtM6hMkeochbUR706DK1N4iZp0\"}"