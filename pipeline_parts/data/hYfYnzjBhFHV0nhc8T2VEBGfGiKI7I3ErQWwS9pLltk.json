"{\"content\":{\"body\":\"Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\\n\\nNFTs give us new tools to solve this problem — by a representing previously infinitely reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \\n\\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\\n\\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\\n\\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \\n\\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\\n\\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\\n\\nThis could signal the beginning of a movement towards journalist and artist DAOs.\\n\\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\\n\\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\\n\\n## Problems We're Solving\\n\\n- Writers want funding for a long-form piece of content before writing it\\n- Contributors want to fund their favorite writers, and receive some return on their investment\\n- Contributors want to be recognized as patrons of public goods\\n- Speculators want to invest in NFTs, including those that represent *written* works\\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\\n\\n## What Success Looks Like\\n\\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\\n- The work is represented by a tradable NFT\\n- The Creator can update the NFT's metadata once the work is finished\\n- The Creator can trade that NFT for a profit\\n- Contributors can trade their ownership stake on Uniswap\\n- Contributors can divest their stake for accumulated revenue\\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\\n\\n## Out of Scope\\n\\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\\n\\n## Implementation Summary\\n\\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\\n- The contract has a \\\"hard cap\\\", beyond which nobody else can join the crowdfund.\\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\\n    - The downside is that one person might just buy all of it, which is less fun.\\n\\n## Potential Downsides\\n\\n- It could have a vulnerability, and lose funds.\\n\\n## Implementation Details\\n\\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\\n\\n```js\\n// A completely untested sketch of a contract, written in a Notion doc.\\ncontract Crowdfund is ERC20 {\\n    using SafeMath for uint256;\\n\\n    // A list of possible states for crowd-funding.\\n    enum Status {FUNDING, TRADING}\\n    // The actual status of the crowd-fund, one of `Status`.\\n    Status internal _status;\\n\\n    // Events representing crowdfunding life-cycle.\\n    event FundingOpened(\\n        address media,\\n        address creator,\\n        uint256 creatorEquityPercent\\n    );\\n    event Contribution(address contributor, uint256 amount);\\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\\n    event BidAccepted(uint256 amount);\\n    event Withdrawal(address contributor, uint256 amount);\\n\\n    // The NFT's information.\\n    address private _nftAddress;\\n    uint256 _tokenId;\\n\\n    // Creator's information.\\n    // John is the artist and controls this contract.\\n    address private _johns_address;\\n    uint256 _johns_equity_percent;\\n\\n    // Cap it at 10 ETH.\\n    uint256 private _funding_cap_eth = 10;\\n\\n    modifier onlyJohn() {\\n        require(msg.sender == _johns_address);\\n        _;\\n    }\\n\\n    constructor(\\n        address johns_address,\\n        address mediaAddress,\\n        Data memory nftData,\\n        uint256 johns_equity_percent,\\n        address WETH_\\n    ) public ERC20(\\\"John's Crowdfund\\\", \\\"JOHN\\\") {\\n        _nftAddress = mediaAddress;\\n\\n        // TODO: Mint an NFT with the owner being this contract, using\\n        // using nftData.\\n\\n        _johns_address = johns_address;\\n        _johns_equity_percent = johns_equity_percent;\\n\\n        _status = Status.FUNDING;\\n\\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\\n    }\\n\\n    /*\\n        Contributor Crowdfunding Methods\\n     */\\n\\n    function contribute(uint256 amount) external {\\n        require(_status == Status.FUNDING, \\\"Status must be funding\\\");\\n\\n        uint256 currentBalance = balanceOf(address(this));\\n        require(\\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\\n            \\\"Total contributions would exceed funding cap\\\"\\n        );\\n\\n        // Pull funds from the contributor to this contract.\\n        require(\\n            transferFrom(msg.sender, address(this), amount),\\n            \\\"Contribution Failed\\\"\\n        );\\n\\n        // Mint equity for the contributor.\\n        _mint(msg.sender, amount);\\n\\n        emit Contribution(msg.sender, amount);\\n    }\\n\\n    // The contributor can withdrawl at any time for their percent\\n    // of the pool.\\n    function withdraw(uint256 tokenAmount) external {\\n        uint256 percentStake = tokenAmount.div(totalSupply());\\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\\n\\n        _burn(msg.sender, tokenAmount);\\n\\n        require(transfer(msg.sender, withdrawAmount), \\\"Withdraw failed\\\");\\n\\n        emit Withdrawal(msg.sender, withdrawAmount);\\n    }\\n\\n    /*\\n        Operational Methods\\n    */\\n\\n    function closeFunding() external onlyJohn {\\n        require(_status == Status.FUNDING, \\\"Status must be funding\\\");\\n\\n        // Transfer all funds to John.\\n        uint256 amountRaised = balanceOf(address(this));\\n        require(transfer(_johns_address, amountRaised), \\\"Withdraw failed\\\");\\n\\n        // Mint John some percent of the total supply.\\n        // For example, if the total supply is 3 ETH, and\\n        // John is set to get 5%, then he will get 0.15 ETH.\\n        // 3 / 100 * 5 = 0.15.\\n        uint256 tokensForJohn =\\n            totalSupply().div(100).mul(_johns_equity_percent);\\n        _mint(_johns_address, tokensForJohn);\\n\\n        // Close funding status, move to tradable.\\n        _status = Status.TRADING;\\n\\n        emit FundingClosed(amountRaised, tokensForJohn);\\n    }\\n\\n    // As the operator, John is allowed to accept a bid for the\\n    // NFT from the market. This should increase the money in the contract.\\n    function acceptNFTBid(Bid calldata bid) external onlyJohn {\\n        require(_status == Status.TRADING, \\\"Status must be trading\\\");\\n\\n        // TODO: Accept a bid from an NFT market, thereby\\n        // receiving funds. Unwrap WETH if necessary.\\n\\n        emit BidAccepted(bid.amount);\\n    }\\n\\n    /*\\n        Miscellaneous operational functions, e.g. update NFT data.\\n    */\\n\\n    // Allows John to update metadata associated with the NFT.\\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\\n        // Update data on the NFT.\\n        // TODO: Emit event.\\n    }\\n\\n    // Allows John to update metadata associated with the NFT.\\n    function updateTokenMetadataURI(string calldata metadataURI)\\n        external\\n        onlyJohn\\n    {\\n        // Update data on the NFT.\\n        // TODO: Emit event.\\n    }\\n\\n    receive() external payable {\\n        // only accept ETH via fallback from the WETH contract\\n        assert(msg.sender == WETH);\\n    }\\n}\\n```\",\"timestamp\":1611173980,\"title\":\"Crowdfunding Writing with NFTs\",\"publication\":\"dev\"},\"digest\":\"wPRE9orSf-V6fwg7LCxcN7bQmNfC_sa9mvxnF_I3avI\",\"authorship\":{\"contributor\":\"0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Y145rmpdL8brLnJOGKaRCFROF9SSGs9SiHJpOtj_X-Y\\\",\\\"y\\\":\\\"RiM0H9oyhhkqY4pTiosfP6eyxf6FR_NSSgBHj4R50vw\\\"}\",\"signature\":\"-8vnZjYxs9rDdBY1W8WAAlzIsZp8qOm5wWIiP1U1nS0VYgpNfe0zSKnield8dkAbaKnmCxY8sgt7vUjrQhkWwg\",\"signingKeySignature\":\"0xff61d93797c7ac900a8b9d8a86d64e62b629aac5e9ecf762e35ffbd602b24aab53c973eb77acaa229ad659c28ed46c80a7bc081e5ca475e004b81ed8c10c4b071c\",\"signingKeyMessage\":\"I authorize the publication of articles on dev.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Y145rmpdL8brLnJOGKaRCFROF9SSGs9SiHJpOtj_X-Y\\\",\\\"y\\\":\\\"RiM0H9oyhhkqY4pTiosfP6eyxf6FR_NSSgBHj4R50vw\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"version\":\"12-21-2020\",\"originalDigest\":\"llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ\"}"