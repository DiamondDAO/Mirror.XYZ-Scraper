"{\"content\":{\"body\":\"问答类游戏，在开发过程中还算是比较简单的一个分类，核心的内容就是问题与答案。抽象来讲，问题可能是文字，也可以是图片，也可以是声音等等，而对应玩家可以选择的答案，也可以不同的表现形式。例如看电影海报猜电影名字，听音乐片段猜歌曲等等\\n\\n【诗仙与诗魔】，是一个诗词挑战类游戏，本质上也算是一个答类游戏，问题变成了某一首诗中的某一句，而答案就是从给定的类似诗句中选择正确的那一句。**接下来我将从技术有角度来解析一下这个游戏的整个开发过程。**\\n\\n这个游戏现在可以直接从商店下载体验，在 AppStore 或 TapTap 搜索 **`诗仙与诗魔`** 即可找到。\\n\\n![](https://blog.moeif.com/postimages/how-to-make-a-quiz-game/poemstars.png)\\n\\n这个游戏现在可以直接从商店下载体验，在 AppStore 或 TapTap 搜索 **`诗仙与诗魔`** 即可找到。\\n\\niOS 下载连接: <https://apps.apple.com/app/id1583234447>\\n\\nAndroid 下载连接: <https://www.taptap.com/app/222178>\\n\\n先解析一下这个游戏，诗仙与诗魔有三种玩法，独自练习，就是关卡模式。无尽冲榜，就是不断地累积得分，然后进行排行榜。匹配挑战，是可以与其他玩家进行联网匹配的玩法，这一个涉及到服务器部分的开发。\\n\\n## 客户端的部分\\n\\n1.  客户端在启动后，会先去一个固定的域名，拉取一些必要的配置信息，例如服务器的状态，排行榜和匹配服务器的连接地址，服务器的状态等等。这个可以自己根据需求配置各种各样的信息，只有这些必要的信息拉到后，游戏才会继续下一步。\\n\\n2.  接下来会从本地尝试读取用户数据，如果本地没有，则会从服务器尝试请求，如果服务器也没有，则认为这是一个新玩家。弹出玩家昵称输入界面，玩家确定后，会将用户的ID和昵称等数据发到服务器，并且在本地存档，然后就会进入游戏。如果本地没有用户数据，但是服务器有，就会使用服务器保存的用户数据，进行数据恢复，然后在本地存档。\\n\\n3.  接下来就进入了主界面，可以选择三种不同的玩法。先说一下诗词数据。诗词数据是使用 flatbuffers 存储在游戏包里的。每一个记录，保存了一首诗的ID，名字，作者，内容等。游戏启动后，会读取所有的诗词数据，进行结构化存储。每一首诗，会创建一个 `Poem` 对象，里面保存了这首诗的内容，以及额外的数据，例如这首诗有几句，每一句的字数，这些数据会用于随机生成问题，以及根据字数，从其他诗词中选择类似的诗句，用作答案。\\n\\n    **关卡模式**，就是罗列出诗词配置表中的每一首诗，作为一个关卡，当玩家作答完毕后，会记录所用时间。在关卡界面，所以看到每一首作答过的诗词所用的时间。\\n\\n    **无尽冲榜**，首先进入时会消耗体力，对于每一个新玩家，会给予默认300体力，还有2个复活道具，5个刷新道具。在冲榜模式中，每一首诗会有10秒的倒计时，在过程中，玩家可以选择使用一个刷新道具，换一首诗作答，以此不终断冲榜过程。冲榜结束后，会给出得分，客户端会得得分提交到服务器。对于头衔，是由得分计算出来的，这个直接在客户端计算。游戏没有作作弊方面的处理，对于这个游戏来说，没什么必要。如果失败，则必须消耗一个复活道具，才能继续从失败的地方继续冲榜。如果道具或体力不足，则可以通完看广告获得。\\n\\n    **匹配挑战**，匹配挑战同样会消耗体力，进入后，首先会向服务器发送匹配消息，服务器会在根据匹配的等待时间，根据玩家的 elo 分值，进行实力相当的匹配，如果最后没有真实玩家，则会匹配一个机器人，与玩家一起玩。每一局匹配挑战由10首诗构成，由哪10首诗，以及每一首诗的可选择答案，则由服务器生成，以此保证两个玩家使用的挑战数据是一致的，保证公平性。\\n\\n    匹配挑战的分得计算，每一首诗为1000分，如果答错，则0分。如果答对，先得500分，剩下的500分，根据作答速度，剩余时间的百分比，进行得分。得分由服务器计算，一定程度上受网络影响。\\n\\n## 服务器的部分\\n\\n服务器可以分为三部分，服务器及用户基础数据，排行榜，匹配，这三部分是使用不同的方式实现的。\\n\\n1.  服务器及用户基础数据 这一部分使用 aws 的 DynamoDB、Lambda、 API gateway 实现的。通过API gateway 调用 lambda 读写 DynamoDB的数据，可以根据网上一些视频教程来操作来下。逻辑很简单，主要是配置各种权限的时候稍微麻烦一点，也还好。\\n\\n2.  排行榜 排行榜放在了 aws 的免费 ec2上，因为游戏的量不大，所以免费的也够用，数据直接放在了 Redis 中，API 逻辑是使用 Rust 来写的。\\n\\n3.  匹配 匹配部分也是放在 aws 的免费 ec2 上。也是使用 Rust 写的。连接模块使用了 message-io 的 websocket。客户端和服务器使用了简单的 json 交互，因为数据比较简单，就没有使用更复杂的协议。期中，匹配开了两个线程，一个用于监听客户端的连接，收到连接后，会将连接数据发往另一个线程，数据的交互是使用了 rust 的 channel。游戏管理器收到新的连接，就会加入到客户端的列表。收到客户端发来的消息后，会进行解析，然后进行逻辑处理。\\n\\n    收到匹配消息后，会放到匹配队列中，到了匹配时间后，会取出匹配用户，以及另一个用户，或者创建一个机器人，组成一个局新的游戏。创建一个 `Game` 对象，加入到游戏管理器中。游戏管理器会不断更新游戏的时间，以及逻辑。当两个玩家作答都结束时，就会同步发送游戏结束消息，客户端弹出结束界面。\\n\\n服务器部分的代码已开源，可以在Github查看\\n\\n排行榜的代码：<https://github.com/moeif/poemstars-leaderboard-server>\\n\\n匹配逻辑的代码: <https://github.com/moeif/poemstars-match-server>\\n\",\"timestamp\":1642236804,\"title\":\"如何开发一个问答类游戏\"},\"digest\":\"mrHh9ayzE4GNarOvQcMU2DIQ1LJp3qlv9W6_Buogkz0\",\"authorship\":{\"contributor\":\"0xcdE934DFFB60ff73D5f1F9795cB4289217D87cDc\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"X2KL3XZ296zwtPQgTFgmIi4YEw1T423dPvDrVitLttU\\\",\\\"y\\\":\\\"kCqBMZLhICJsRsoqvobFXH_pmyhyejizBRhwCjE6Paw\\\"}\",\"signature\":\"vAS2k-_t53m4B6N2fbQKEqrdyFWH8Eg-_Lr11Gqa_78Qem42bYf7g9_3ulGx4hSvlToa9zdTe_9Z1gCbJcVf3w\",\"signingKeySignature\":\"0x728cc8f93919d56d1b374310fd464a8acf3d6c4d765d07d187be2f120f911bf9712debc2f67ad42511efd0df4d371ab485d734641a21b8c839a104a32ccb0bd61b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"X2KL3XZ296zwtPQgTFgmIi4YEw1T423dPvDrVitLttU\\\",\\\"y\\\":\\\"kCqBMZLhICJsRsoqvobFXH_pmyhyejizBRhwCjE6Paw\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"mrHh9ayzE4GNarOvQcMU2DIQ1LJp3qlv9W6_Buogkz0\"}"