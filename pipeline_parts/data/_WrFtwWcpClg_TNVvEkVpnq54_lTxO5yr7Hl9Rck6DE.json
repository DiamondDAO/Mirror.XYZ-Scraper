"{\"content\":{\"body\":\"![](https://images.mirror-media.xyz/publication-images/5GTIkoQmxwr1NF5FURQC-.png?height=978&width=1740)\\n\\n以太坊扩容项目 Polygon（前身为 Matic Network）以 2.5 亿美元收购了Hermez Network，这是一个由 ZK-Rollups提供支持的以太坊扩容解决方案。\\n\\n了解Layer2技术现状（特别是对zk Rollup技术）的小伙伴，知道zk Rollup目前不支持EVM，缺失可编程性/可组合性，让zk Rollup限制在特定场景。zkEVM，通过zkp技术证明EVM的执行过程是非常有挑战的技术难点。\\n\\nEthCC 4会议上Hermez团队介绍了他们对zkEVM的理解和设计：\\n\\n<https://www.youtube.com/watch?v=17d5DG6L2nw>\\n\\nHermez团队负责人Jordi Baylina比较清晰地给出了zkEVM大体的设计思路。本文梳理一下对zkEVM设计的理解。抛砖引玉，有理解偏差，小伙伴们可以留言讨论。\\n\\n虚拟机证明\\n\\nJordi在演讲开头提出：The Ethereum Virtual Machine was not designed to run in a zk-circuit （以太坊虚拟机在设计时并没有考虑zk电路证明）。也就是说，zkEVM天生比较难。当初设计EVM的时候并没有考虑到后期还需要zk进行证明。在这种情况下，目前有三条路可以走：\\n\\n[https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfyFzBFPNQpLsx3YZglfuIRxK8LjSSTgzLc944P3PZA7FFn68bGQfWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfyFzBFPNQpLsx3YZglfuIRxK8LjSSTgzLc944P3PZA7FFn68bGQfWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\\n\\n第一条：从头设计一种新的虚拟机，该虚拟机对zk友好，方便证明。不需要理会EVM。\\n\\n第二条：从头设计一种新的虚拟机，该虚拟机对zk友好，方便证明。适配当前的EVM的开发工具，保持solidity兼容。\\n\\n第三条：直接支持EVM指令集，完全兼容solidity指令集。\\n\\nHermez团队选择了第三条。其他两种做法在当前的环境下，不太经济。Hermez给出了选择第三条路的理由：\\n\\n[https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfVIqlcM6RYkj0em5icIuqQ1N3CoSibefO505foicpKMTE5EticN9KT7WoWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfVIqlcM6RYkj0em5icIuqQ1N3CoSibefO505foicpKMTE5EticN9KT7WoWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\\n\\n总的来说，就是兼容性好，安全性高。\\n\\n总体思路\\n\\n因为EVM在设计当初没有考虑zk电路证明，支持solidity指令集需要引入中间指令（micro opcode）。这些中间指令比较适合电路证明。这些指令构成uVM。EVM需要编译在uVM中执行。\\n\\n[https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfviaGYE0pbVlcGMEv8JaqRRmDIuWaYoIXqd1WWevaUwDV9pGvsj2NmmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](https://mmbiz.qpic.cn/mmbiz_png/IXicdJl0t7b6dMNjEMbTpKPkjtTBmQbTfviaGYE0pbVlcGMEv8JaqRRmDIuWaYoIXqd1WWevaUwDV9pGvsj2NmmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\\n\\n众所周知，EVM有一些变长的指令，比如CALL，DATACOPY，EXP，CREATE等等。这些指令天生对电路证明不友好。利用中间指令能相对友好地“表达”出这些指令的逻辑。\\n\\n对于一个区块中的所有交易，相关的指令可以一个个的执行。执行的模型是：老的状态 + 所有交易指令 -> 新的状态。一个细节是状态的迁移是以区块为单位，并不是以交易为单位的。\\n\\n多项式承诺\\n\\n在继续解释细节实现之前，Jordi简单介绍了一下多项式承诺。多项式有两种表示方式：1/系数表示 2/ 点值表示。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n在给定一个多项式承诺（cm）的情况下，验证者可以提供随机挑战r，证明者必须给出多项式在r的取值以及承诺证明。随机挑战值r，可以通过Fiat-Shamir算法产生，将交互式的协议变成非交互式协议。在给出多个多项式承诺证明的前提下，通过取值的关系可以确定多项式之间的关系。通过多项式承诺可以证明如下的多项式关系：\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n多项式相等，多项式取值等等。熟悉Plonk或者Plookup协议的小伙伴应该知道，这些协议的基础就是多项式承诺。\\n\\n**[零知识证明 - Plookup算法介绍](http://mp.weixin.qq.com/s?__biz=MzU5MzMxNTk2Nw==&mid=2247487753&idx=1&sn=cba7602c7b75d24caa196862688f9b7b&chksm=fe130019c964890f3fdafe0c3bc50a058e60a703202b2f789528a39cdb3045e7246ae02dae26&scene=21#wechat_redirect)**\\n\\n**[零知识证明 - 深入理解PlonK算法](http://mp.weixin.qq.com/s?__biz=MzU5MzMxNTk2Nw==&mid=2247487516&idx=1&sn=f64cab59e7236993549e0b803eb73bf9&chksm=fe13010cc964881aac6d262fa98e830bbebec839d5954303d0c79cc3307ab33c5ac9470e808d&scene=21#wechat_redirect)**\\n\\nuVM的整体框架\\n\\nuVM由如下的模块组成：ROM，RAM，Storage以及各种计算功能模块。Main SM（主状态机）由子模块组成。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n需要证明程序的执行状态正确，要保证如下的一些状态正确：\\n\\n### **如何证明执行程序正确？**\\n\\n执行程序存储在ROM中。将指令和位置进行编码后，得到执行程序的多项式表示 rom (x)。将Main SM中的代码执行指令和PC进行同样的编码后形成的多项式instTrace(x)。无论这份代码如何执行（循环的次数，跳转方式），instTrace(x)中的元素都应该属于rom(x)。这种从属关系可以采用Plookup协议进行证明。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n注意的是，instTrace指的是执行实例的Trace。虽然，通过Plookup能证明instTrace(x)中的元素属于rom(x)，但是instTrace(x)的执行正确性并没有证明。试想一下instTrace中少一两条指令，同样满足从属关系。简单的说，这种从属证明只是证明了Main SM和ROM状态的一致性。\\n\\n### **内存状态正确？**\\n\\n在Main SM中的内存的读写情况，应该和内存RAM的状态一致。这种一致也是通过Plookup协议进行证明。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n内存RAM本身逻辑是否正确需要额外证明。\\n\\n### **存储状态正确？**\\n\\nuVM的存储是通过key-value对实现。所有存储（key-value对）用merkle树进行组织。所以，存储模块包括merkle树和hash计算。Plookup协议可以证明多个模块之间的一致性。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n### **整体证明构成**\\n\\n一个程序的执行状态的正确性分割成多个子模块的状态正确性验证。总之，证明包括两部分：1/ 单个模块的逻辑正确 2/ 模块和模块之间的一致性。\\n\\n<data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==>\\n\\n证明大量采用多项式承诺。验证这些多项式承诺需要不小的开销。Jordi提出了多种验证思路：\",\"timestamp\":1639208617,\"title\":\"Hermez Network\"},\"digest\":\"VtLXKVrWYbZXmvomW06CMtTyFqCwxYhaSNHOizABQzM\",\"authorship\":{\"contributor\":\"0xf3FE8c6c75bE4afB2F8200Fc77339abE4D7CFF33\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"jMBCqqQ-oG9HvvVCgi3AUypOhndSu9x03ivXkjS5rsA\\\",\\\"y\\\":\\\"dSfdNvTkULxhYfMLG8_0I65r4vcjXkSKEyR27inkK-c\\\"}\",\"signature\":\"KRxoKCBujlHai-0IuIoKCS6Sp740FuIn-qphmQ-2gNe5-vWTgb2tqo6QXzrjPPJSj8q_smN7b7ZO2lT2DPhRcg\",\"signingKeySignature\":\"0x4d22044a2afbb8b1d1a98995ebf8225a4e2e88652e2965c0b59f06fc1c0c65bf0be3f7090db1775cfb6885d10d484aa89171d1bd95a1455cf39f9ddfbe6f894f1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"jMBCqqQ-oG9HvvVCgi3AUypOhndSu9x03ivXkjS5rsA\\\",\\\"y\\\":\\\"dSfdNvTkULxhYfMLG8_0I65r4vcjXkSKEyR27inkK-c\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"VtLXKVrWYbZXmvomW06CMtTyFqCwxYhaSNHOizABQzM\"}"