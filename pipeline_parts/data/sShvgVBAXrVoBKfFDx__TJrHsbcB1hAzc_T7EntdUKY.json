"{\"content\":{\"body\":\"我们构建一个DeFi dapp，需要从链外的API中获取一些数据，比如让您的用户能够获取ETH交易对的价格。JavaScript 应用程序或者其他的中心化应用程序可以轻松获取此类信息，比如向Binance 公共 API（或任何其他公开提供价格信息的服务）发出请求。但是，智能合约不能直接访问链外的数据。所以我们想做的是从去**中心化的预言机网络（DON）**和去**中心化的数据源**中获取我们的数据。\\n\\nChainlink 是一个去中心化预言机网络（DON）的框架，是一种跨多个预言机从多个来源获取数据的方法。这个 DON 以去中心化的方式聚合数据，并将其放在**区块链上的智能合约中**供我们读取。因此，我们所要做的就是从 Chainlink 网络不断为我们的合约读取数据！\\n\\n使用 Chainlink 数据馈送是一种在这种去中心化环境中更便宜、更准确、更安全地从现实世界收集数据的方法。由于数据来自多个来源，因此多个人可以参与生态系统，它**甚至比运行集中式预言机更便宜。并且可以极大程度的减少错误集中，**Chainlink 网络使用一种称为链下报告的系统来就链下数据达成共识，并将经过加密验证的单一交易中的数据报告回链上供用户使用。\\n\\n然后，您可以使用它制作[Synthetix](https://synthetix.io/)、[Aave](https://aave.com/)和[Compound](https://compound.finance/)等协议！\\n\\n目前chainlink为我们提供了几种服务：\\n\\n* `DATA FEEDS`快速获取链上交易对价格\\n* `USING RANDOMNESS` 获取可信赖的随机数\\n* `CONNECT TO ANY API` 调用第三方API\\n* `CHAINLINK KEEPERS` 为用户提供去中心化的节点网络\\n\\n### Oracle数据交互流程：\\n\\n![](https://images.mirror-media.xyz/publication-images/Jh6VZMNH6J_T44EIDiSo7.png?height=1674&width=3261)\\n\\n## \\n\\n### 1.DATA FEEDS 数据馈送\\n\\n* **功能简介**\\n\\n  Data Feeds 是将您的智能合约与资产的真实市场价格联系起来的最快方式。例如，Data Feeds 的一个用途是使智能合约能够在一次调用中检索资产的最新定价数据。您可以使用智能合约来获取 EVM 链上的资产价格,比如ETH/USD交易对\\n* **实际开发**\\n\\n  对于我们合约来说，我们需要通过和另外一个Oracle合约进行交互。对于交互的代码框架我们可以从[Chainlink GitHub repository](https://github.com/smartcontractkit/chainlink) 进行导入。\\n\\n  在程序中导入AggregatorV3Interface.sol，这样你就可以创建一个AggregatorV3Interface实例，并且使用它提供的接口。需要注意的是我们构建函数的时候需要传入Oracle的合约地址，你可以通过链上[Feeds Registry](https://docs.chain.link/docs/feed-registry/)或者chainlink文档Data Feeds Contract Addresses中提供的地址。\\n\\n![](https://images.mirror-media.xyz/publication-images/JgIIREfGYHey03u7snsGh.png?height=961&width=1009)\\n\\n因为在智能合约中浮点数是不被允许的，因为浮点数的精度对于价格数据来说是致命的，所以latestRoundData.pricefeed 获取到的是一个整数数据。所以我们需要通过 decimals()来取得真实的位数。\\n\\n当然Data Feeds还支持检索前一轮 ID 的价格数据的函数：getRoundData(roundId)\\n\\n```\\nfunction getHistoricalPrice(uint80 roundId) public view returns (int256) {\\n        (\\n            uint80 id, \\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.getRoundData(roundId);\\n        require(timeStamp > 0, \\\"Round not complete\\\");\\n        return price;\\n    }\\n```\\n\\n我们还可以用Chainlink Feed Registry 来直接获取交易对的数据。Chainlink Feed Registry 是资产到 Feed 的链上映射。它使您可以直接从资产地址查询 Chainlink 数据提要，而无需提前知道合约地址。它们使智能合约能够通过单个合约在单个调用中获取资产的最新价格。\\n\\n我们可以使用`Denominations`Solidity 库来获取以太坊地址的货币标识符，这样我们就不需要去搜索对应的TOKEN。\\n\\n```\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/Denominations.sol\\\";\\r\\n\\n/**\\n     * Returns the ETH / USD price\\n     */\\n    function getEthUsdPrice() public view returns (int) {\\n        (\\n            uint80 roundID,\\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = registry.latestRoundData(Denominations.ETH, Denominations.USD);\\n        return price;\\n    }\\n```\\n\\n* **API参考**\\n\\n  [https://docs.chain.link/docs/price-feeds-api-reference/](https://docs.chain.link/docs/price-feeds-api-reference/)\\n\\n\\n### 2.USING RANDOMNESS 获取随机数\\n\\n在我们的合同中，我们一直在处理伪随机性。我们的`keccak256`功能是创建智能合约随机数的好方法。但是我们知道在区块链上的随机数是不可能真正随机的。虽然我们可以用一些全局变量来生成随机数，来使得随机数变得更难预测。\\n\\nuint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));\\n\\n然而，即使是这些数字也具有可预测性：\\n\\n* `msg.sender` 发送者钱包地址：发件人知道\\n* `block.difficulty` 区块难度：直接受矿工影响\\n* `block.timestamp` 时间戳：是可预测的\\n\\n  在区块链之外获得随机性的另外一种方法是使用链外 API 调用返回随机数的服务。但是，如果该服务出现故障、被贿赂、被黑客入侵或其他原因，您可能会取回一个损坏的随机数。而且这种方式是一种中心化的方式。所以chainlink为我们提供了使用去中心化的**Chainlink VRF** ，这无疑是一种更好的方案。\\n\\n\\n* **功能简介**\\n\\n  Chainlink VRF（可验证随机函数）是为智能合约设计的可证明公平且可验证的随机源。智能合约开发人员可以使用 Chainlink VRF 作为防篡改随机数生成器（RNG），为依赖不可预测结果的任何应用程序构建可靠的智能合约：\\n  * 区块链游戏和 NFT\\n  * 随机分配职责和资源（例如随机分配法官处理案件）\\n  * 为共识机制选择代表性样本\\n\\n    当然，要使用预言机，我们必须支付一点 gas，也称为LILNK代币。LINK 代币专门设计用于与预言机合作并确保 Chainlink 预言机网络的安全性。每当我们按照基本请求模型提出请求时，我们的合约必须支付由我们使用的特定预言机服务定义的一定数量的 LINK （每种服务有不同的gas 费用）。\\n\\n    总结来说，智能合约通过指定用于唯一标识 Chainlink 预言机的哈希来请求随机性。Chainlink 节点使用该哈希值和自己的密钥生成一个随机数，然后将其连同加密证明一起返回给链上合约。链上合约（称为`VRF Coordinator`）采用随机数和证明，并使用预言机的公钥进行验证。\\n\\n    交互流程：\\n\\n![](https://images.mirror-media.xyz/publication-images/_EpBeF26IiOoORrPVgbbz.png?height=1123&width=3484)\\n\\n* **实际开发**\\n\\n  在合约中我们需要继承`VRFConsumerBase 合约`在构造函数中提供chainlink VRF的合约地址以及link的TOKEN地址。在继承合约的构造函数中提供 VRF对应的Key Hash 以及gasfee。这些地址都可以在chainlink的官方文档中获取，详细链接请参考下面的API参考。\\n\\n![](https://images.mirror-media.xyz/publication-images/nQ646SiFKB_UenjI6iYTf.png?height=1197&width=1399)\\n\\n其中 requestRandomness 用于发起获取随机数事件，它会返回一个单一请求的requestID 。\\n\\nfulfillRandomness 由 VRFCoordinator 在收到有效的 VRF 证明时调用。重写此函数以对链联 VRF 生成的随机数执行操作。\\n\\n当然我们也可以用mapping将返回的随机数和requestId 或者address对应：\\n\\n```\\nmapping(bytes32 => uint256) public requestIdToRandomNumber;\\r\\n\\r\\nfunction getRandomNumber() public returns (bytes32 requestId) {\\r\\n    require(LINK.balanceOf(address(this)) >= fee, \\\"Not enough LINK - fill contract with faucet\\\");\\r\\n    return requestRandomness(keyHash, fee);\\r\\n}\\r\\n\\r\\nfunction fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\r\\n    requestIdToRandomNumber[requestId] = randomness;\\r\\n}\\r\\n```\\n\\n* **API参考**\\n\\n[https://docs.chain.link/docs/vrf-contracts/](https://docs.chain.link/docs/vrf-contracts/)\\n\\n### 3.CONNECT TO ANY API 调用第三方API\\n\\n* **功能简介**\\n\\n  Chainlink 的去中心化预言机网络为智能合约提供了推送和拉取数据的能力，这使智能合约能够通过去中心化预言机网络访问*任何外部数据源。*促进了链上和链下应用程序之间的互操作性。\\n* **实际开发**\\n\\n  要使用 API 响应，智能合约应继承自`ChainlinkClient`. 该合约公开了一个名为`Chainlink.Request`的结构，智能合约应该使用它来构建 API 请求。该请求应包括预言机地址、作业 ID、费用、适配器参数和回调函数签名。\\n\\n  目前，任何返回值都必须在 32 字节以内，如果该值大于需要发出多个请求。\\n\\n  首先我们需要继承ChainlinkClient合约，并且在构造函数中给与预言机地址、作业 ID、费用参数。如果目标区块链的 LINK 地址尚未公开，请将构造函数中的`setPublicChainlinkToken`替换为`setChainlinkToken(_address)`，其中`_address`是对应的 LINK 代币合约。`oracle`关键字是指合约进行 API 调用的特定 Chainlink 节点，而`jobId`是该节点要运行的特定ID。每个ID都是唯一的，并返回不同类型的数据。\\n\\n  ```\\n  pragma solidity ^0.8.7;\\n  import \\\"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\\\";\\n  contract APIConsumer is ChainlinkClient {\\n      using Chainlink for Chainlink.Request;\\n    \\n      uint256 public volume;\\n      address private oracle;\\n      bytes32 private jobId;\\n      uint256 private fee;\\n      \\n      constructor() {\\n          setPublicChainlinkToken();\\n          oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;\\n          jobId = \\\"d5270d1c311941d0b08bead21fea7747\\\";\\n          fee = 0.1 * 10 ** 18; // (Varies by network and job)\\n      }\\n  ```\\n\\n  然后我们需要构造请求，并且重写回调处理函数：\\n\\n  ```\\n  function requestVolumeData() public returns (bytes32 requestId) \\n      {\\n          Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\\n          \\n          // Set the URL to perform the GET request on\\n          request.add(\\\"get\\\", \\\"https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD\\\");\\n          \\n          request.add(\\\"path\\\", \\\"RAW.ETH.USD.VOLUME24HOUR\\\");\\n          \\n          // Multiply the result by 1000000000000000000 to remove decimals\\n          int timesAmount = 10**18;\\n          request.addInt(\\\"times\\\", timesAmount);\\n          \\n          // Sends the request\\n          return sendChainlinkRequestTo(oracle, request, fee);\\n      }\\n      \\n      /**\\n       * Receive the response in the form of uint256\\n       */ \\n      function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)\\n      {\\n          volume = _volume;\\n      }\\n  ```\\n\\n  其中在我们add完GET请求后，需要add API响应中返回数据的路径，它使用JSONPath来确定数据的位置，比如例中就需要处理返回JSON中 RAW.ETH.USD.VOLUME24HOUR的数据。最后我们需要重写`fulfill()`来处理返回的数据。\\n\\n  上面的代码示例从 oracle 响应中返回一个无符号整数，但有多种数据类型可用，例如：\\n  * `uint256` - 无符号整数\\n  * `int256` - 有符号整数\\n  * `bool` - 真或假值\\n  * `bytes32` - 字符串和字节值\\n\\n  如果需要返回字符串，请使用`bytes32`. 这是转换`bytes32`为`string`. 目前，任何返回值都必须在 32 字节以内，如果该值大于则需要进行多个请求。\\n\\n  特定作业返回的数据类型取决于它支持的任务。确保使用支持我们的合约需要使用的数据类型的预言机进行请求。\\n\\n  同理`HttpPost` 可以add相应的body以及http头\\n\\n  ```\\n  req.add(\\\"post\\\", \\\"http://post.example.com\\\");\\r\\n  req.add(\\\"queryParams\\\", \\\"firstKey=firstVal&secondKey=secondVal\\\");\\r\\n  req.add(\\\"extPath\\\", \\\"price/BTC/USD\\\"); \\n  ```\\n\\n  #### 参数\\n  * `postPOST`: 接受一个包含要向其发出请求的 URL 的字符串。\\n  * `headers`: 将包含键作为字符串和值作为字符串数组的对象。\\n  * `queryParams`: 为 URL 的查询参数获取一个字符串或字符串数​​组。\\n  * `extPath`: 将斜杠分隔的字符串或字符串数​​组附加到作业的 URL。\\n  * `body`：将用作请求中的数据的 JSON 正文（作为字符串）。\\n\\n  ### json解析\\n\\n  核心适配器遍历`path`指定并返回在该结果中找到的值。如果从HttpGet或HttpPost适配器返回 JSON 数据，则必须使用此适配器来解析响应。\\n\\n  #### 参数\\n  * `path`: 接受一个字符串数组，每个字符串是在字符串化 JSON 结果或单个点分隔字符串中解析出的下一个键。\\n\\n    对于字符串化的 JSON：\\n\\n    ```\\n    {\\\"RAW\\\": {\\\"ETH\\\": {\\\"USD\\\": {\\\"LASTMARKET\\\": \\\"_someValue\\\"}}}}\\n    ```\\n\\n  我们可以将json解析到我们定义的数组当中：\\n\\n  ```\\n  string[] memory path = new string[](4);\\r\\n  path[0] = \\\"RAW\\\";\\r\\n  path[1] = \\\"ETH\\\";\\r\\n  path[2] = \\\"USD\\\";\\r\\n  path[3] = \\\"LASTMARKET\\\";\\r\\n  req.addStringArray(\\\"path\\\", path);\\n  ```\\n\\n  或者对json中单个节点进行解析：\\n\\n  ```\\n  req.add(\\\"path\\\", \\\"RAW.ETH.USD.LASTMARKET\\\");\\n  ```\\n\\n  最后我们会在fulfill()中回调得到我们解析后构造得json数据，当然对于数组我们也可以指定解析得数组偏移：\\n\\n  ```\\n  req.add(\\\"path\\\", \\\"3.standardId\\\");\\n  ```\\n\\n  在之前提到过合约中是不支持浮点类型得数据得，所以对于有浮点类型得数据，在请求中我们可以`run.addInt(\\\"times\\\", 100);`来为浮点数做一个乘基：\\n\\n  **参数**\\n  * `times`：将输入乘以的数字。\\n\\n  ### 服务Sleep\\n\\n  当然对于服务得并发任务来说，我们也可以控制节点得调用时间：`req.addUint(\\\"until\\\", now + 1 hours);`核心适配器将在给定的持续时间内暂停当前任务管道。您必须设置`ENABLE_EXPERIMENTAL_ADAPTERS=true`才能使用睡眠适配器。\\n\\n  参数\\n  * `until`：作业应该停止睡眠并在管道中的下一个任务处恢复的 UNIX 时间戳。\\n\\n  ### 在不指定 URL 的情况下选择 Oracle 作业\\n\\n  如果您的合约正在调用公共 API 端点，则可能已经存在一个 Oracle 作业。这可能意味着您不需要将 URL 或其他适配器参数添加到请求中，因为作业已经配置为返回所需的数据。这使得智能合约代码更加简洁。例如使用预先配置的现有作业来发出请求以获取数据，就可以不用add URL信息：\\n\\n  ```\\n      /**\\n       * Initial request\\n       */\\n      function requestElectionWinner() public returns (bytes32 requestId) \\n      {\\n          Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\\n          request.add(\\\"date\\\", \\\"2021-11-02\\\");\\n          request.add(\\\"raceId\\\", \\\"12111\\\");\\n          request.add(\\\"statePostal\\\", \\\"FL\\\");\\n          request.add(\\\"resultsType\\\", \\\"l\\\"); // Replace with l for live results.  \\n          return sendChainlinkRequestTo(oracle, request, fee);\\n      }\\n  \\n      /**\\n       * Callback function\\n       */\\n      function fulfill(bytes32 _requestId, uint256 _voteCount, bytes32 _firstName, bytes32 _lastName, bytes32 _candidateId, bytes32 _party, bytes[] memory _candidates) public recordChainlinkFulfillment(_requestId)\\n      {\\n          voteCount = _voteCount;\\n          firstName = _firstName;\\n          lastName = _lastName;\\n          candidateId = _candidateId;\\n          party = _party;\\n          candidates = _candidates;\\n          emit WinnerFound(firstName, lastName, voteCount, candidateId, party);\\n      }\\n  ```\\n\\n  ### 选择 Oracle 作业\\n\\n  Chainlink 推动了各种预言机数据服务的推出，这些服务允许 dApp 通过提供商拥有的节点来访问自外部数据源的丰富数据。我们可以从数据提供者节点列表中找到我们需要得特定功能的oracle节点。\\n* **API参考**\\n\\n  [https://docs.chain.link/docs/chainlink-framework/](https://docs.chain.link/docs/chainlink-framework/)\\n\\n\\n### 4.CHAINLINK KEEPERS\\n\\n**功能简介**\\n\\n智能合约不能在任意时间或任意条件下触发或启动自己的功能。只有当交易由另一个账户（例如用户、预言机或合约）发起时，才会发生状态更改。(中心化的应用程序可以使用线程或者定时器来进行一些操作，比如定时的数据处理，数据上报等)。那当我们部署的合约需要实现这些功能就会比较麻烦。除非我们在部署完合约之后，在写一套用于维护的工具。\\n\\n为了解决这个问题，区块链项目可以：\\n\\n* 创建高度可靠的基础设施触发智能合约功能。这是集中式的，而且构建和维护通常很昂贵。\\n* 外包给第三方。此选项也是集中式的，并且会产生单点故障。\\n* 使用公开市场解决方案。这个选项是去中心化的，但伴随着复杂的激励调整、竞争机器人的潜力会增加执行成本以及难以确保可靠性。\\n\\n**Chainlink Keeper**网络也为我们提供了这个解决方案。Chainlink Keepers 为用户提供去中心化的节点网络，这些节点被激励(合约注册了节点服务需要支付一定的费用)执行所有已注册的工作（或*维护*），而不会相互竞争。网络有几个好处：\\n\\n* 为开发人员提供超可靠、去中心化的智能合约自动化\\n* 提供可扩展的计算，允许开发人员以更低的成本构建更高级的 dApp\\n* 灵活性和可编程性\\n\\n那么我们来说一下Chainlink Keeper Network ：\\n\\nChainlink Keeper Network 为智能合约提供选项，以最小化信任和去中心化的方式外包定期维护任务。该网络旨在为 Keeper 生态系统内的激励和治理提供协议。\\n\\n网络中有三个主要参与者：\\n\\n* **客户端合约**：需要外部实体来为其维护任务提供服务的智能合约。\\n* **Keepers**：执行注册维护的 Chainlink 节点。\\n* **Registry**：任何人都可以通过它创建和管理维护，节点运营商可以执行维护的合约。\\n\\n下图描述了 Keeper 网络的架构。它负责管理网络上的参与者并补偿 Keepers 以执行成功的维护。客户可以注册维护，节点运营商可以注册为守护者。\\n\\n![](https://images.mirror-media.xyz/publication-images/rB9Ark5DJzqGF2s8opFmk.png?height=497&width=600)\\n\\n* **实际开发**\\n\\n需要我们部署的合约支持chainlink keepers协议功能，我们只需要为我们的合约提供两个公开的合约接口，用于第三方的维护程序进行调用编程。\\n\\n首先我们需要导入KeeperCompatible.sol头文件，并且继承KeeperCompatibleInterface：\\n\\n```\\npragma solidity ^0.7.0;\\n\\n// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and\\n// ./interfaces/KeeperCompatibleInterface.sol\\nimport \\\"@chainlink/contracts/src/v0.7/KeeperCompatible.sol\\\";\\n\\ncontract Counter is KeeperCompatibleInterface {\\n}\\n```\\n\\nKeeperCompatibleInterface为我们提供了两个接口`checkUpkeep`和`performUpkeep`：\\n\\nKeeper 节点运行此方法是`eth_call`为了确定您的合约是否需要完成一些工作。如果您的链下模拟`checkUpkeep`确认满足您的预定义条件，则 Keeper 将向区块链广播执行`performUpkeep`方法。\\n\\n```\\nfunction checkUpkeep(bytes calldata checkData)external returns (\\n    bool upkeepNeeded,\\n    bytes memory performData\\n  );\\n```\\n\\n### 参数\\n\\ncheckData 检查维护时传递给合同的数据。在维护注册中指定，因此注册的维护始终相同。\\n\\n`upkeepNeeded`：指示 Keeper 是否应该呼叫`performUpkeep`。\\n\\n`performData` ：`performUpkeep`如果需要维护，Keeper 应该调用的字节。如果您想对数据进行编码以便稍后解码，请尝试`abi.encode`.\\n\\n区块上会根据`upkeepNeeded`的返回值来确定是否执行`performUpkeep` ，如果需要执行就将返回的 `performData`传递给`performUpkeep`。由`performUpkeep`中对数据进行处理。\\n\\n```\\nfunction performUpkeep(bytes calldata performData) external;\\n```\\n\\n当然我们可以用我们可以用枚举的方式在函数中实现各种维护的业务：\\n\\n![](https://images.mirror-media.xyz/publication-images/Bi6W63pMl9tiiJbYgkBXa.png?height=1084&width=1426)\\n\\n* **API参考**\\n\\n[https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/](https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/)\\n\\n## 5.运行Chainlink 节点\\n\\n我们可以运营 Chainlink 节点成为 Chainlink 网络的一部分，帮助开发人员构建混合智能合约，让他们能够访问真实世界的数据和服务。\\n\\n具体操作请参考官方文档-Node Operators：\\n\\n[https://docs.chain.link/chainlink-nodes/](https://docs.chain.link/chainlink-nodes/)\\n\\n\",\"timestamp\":1642670491,\"title\":\"去中心化Oracle-Chainlink使用\"},\"digest\":\"ePvk30HmD0n5hSErHDRo2RFIrb_FdpWxSnbp54xY2fs\",\"authorship\":{\"contributor\":\"0x9CF515b5472EBce6Dee1084a4C5947E1735EeD1C\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"YOKVvZ1PZzGL56j5umsHLKRnjZPowZwBjAYfihJYpSA\\\",\\\"y\\\":\\\"oYP0aeFwUw__fh9BTdRFBPviLG2VJsy75sH3dPsY4M0\\\"}\",\"signature\":\"zSXlzodvxS5wi7nKduhZc5K0HWGYgIX4W9Za0vIEwEv5ItW238Q4OHrgkHzxuYLdJB85K6jFoZFY_CQ3n-rF1A\",\"signingKeySignature\":\"0x2d8aa66726e00b23e2ccaac5fc33fe7c4b53218ba580d61552079e9e4699078d1d1f2be5a448373b6f71f0658b25830233414dbfafdef39bc8016b79ac272e781b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"YOKVvZ1PZzGL56j5umsHLKRnjZPowZwBjAYfihJYpSA\\\",\\\"y\\\":\\\"oYP0aeFwUw__fh9BTdRFBPviLG2VJsy75sH3dPsY4M0\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"ePvk30HmD0n5hSErHDRo2RFIrb_FdpWxSnbp54xY2fs\"}"