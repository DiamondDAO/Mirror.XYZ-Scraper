"{\"content\":{\"body\":\"## [](#introduction)Introduction\\n\\nIn this post, we will tackle about \\\"Inversion of Control\\\" principle. We will learn when to use it and how we can use it with Laravel using [Contextual Binding](https://laravel.com/docs/8.x/container#contextual-binding) in the [Service Container](https://laravel.com/docs/8.x/container). Although this topic assumes that you have the basic knowledge with Laravel and a general OOP concepts.\\n\\nAt the time of writing this, the current version for Laravel is on version 8.\\n\\n## [](#what-is-inversion-of-control)What is Inversion of Control?\\n\\nIf you know what is [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection) then it's basically just a reverse of it. For Dependency Injection the code typically depends directly on the [class](https://www.w3schools.com/php/php_oop_classes_objects.asp). With [Inversion of Control (IoC)](https://en.wikipedia.org/wiki/Inversion_of_control) we invert it, the code does not depend on the class directly but only to the interface and we bind it in the [service container](https://laravel.com/docs/8.x/container). So when we Inject dependency to a certain class or [Controller](https://laravel.com/docs/8.x/controllers) we call the [Interface](https://www.w3schools.com/php/php_oop_interfaces.asp) and not the class.\\n\\n## [](#when-to-use-inversion-of-control)When to use Inversion of Control?\\n\\nOne must be aware and has to fully understand the scenario or what problem or certain feature to be implemented. There are a lot of problems and are a lot of ways to address it. But to choose the proper method of addressing the problem is a good way to approach it. Things does not have to be complex and should just be simple as possible.\\n\\nOther than that, say for a given scenario, your client wants to support multiple payment providers for the project that you are building. At your first glance you might think that you'll have to create a lot of classes for it and have different implementation details on each one of them, but the problem arises that you might have to inject a lot these in your Controllers or that you might have to put up some conditional logics just to use the correct payment provider.\\n\\nThat can work but it may not the ideal implementation. Then that's the time we will make use of abstraction using Inversion of Control, we can then only inject a single dependency to a Controller or whatever class it requires and that leaves us lesser code to write. It keeps it simple, and that also means it'll be easier to maintain it in the long term.\\n\\n## [](#creating-a-paymentinterface)Creating a PaymentInterface\\n\\nJust for a quick, simple, and straight-forward example let's have a `PaymentInterface` that requires 1 method to implement whichever a class implements this interface or abstract.\\n\\nSo let's just create a directory under `app` directory of a fresh Laravel project, and call this directory as `Interfaces` and have a file created named as `PaymentInterface.php` and for its content, we have this\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Interfaces;\\n\\n    interface PaymentInterface\\n    {\\n      /**\\n       * @param float $amount \\n       * @return mixed \\n       */\\n      public function pay(float $amount): string;\\n    } \\n\\n\\n\\nWe only require classes to implement `pay` method that takes an argument `$amount` type hinted with `float` and it returns a `string`\\n\\n## [](#creating-payment-services-that-implements-paymentinterface)Creating payment services that implements PaymentInterface\\n\\nLet's say the client wants to have at least 3 payment providers, let's just call it whatever we want in this case.\\n\\n*   Paypal\\n*   SquarePay\\n*   Stripe\\n\\nWe have at least 3 payment providers but with different implementation details because we might have to setup a few configuration for each of these third party APIs. Typically we want these configuration setup private and should not be exposed publicly, we only expose what is defined in the `PaymentInterface`\\n\\nSo let's define these services, we'll start off with `Paypal`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Services;\\n\\n    use App\\\\Interfaces\\\\PaymentInterface;\\n\\n    class PaypalService implements PaymentInterface\\n    {\\n        public function pay(float $amount): string\\n        {\\n            return \\\"From PaypalService $amount\\\";\\n        }\\n    }\\n\\n\\n\\nThe `PaypalService` implements the `PaymentInterface` and the `pay` method as well, and as defined from the abstract class or interface that `pay` should return a `string` then we'll return it with a type of `string` so we basically just know right away what we should be returning.\\n\\nFor the `SquarePayService`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Services;\\n\\n    use App\\\\Interfaces\\\\PaymentInterface;\\n\\n    class SquarePayService implements PaymentInterface\\n    {\\n        public function pay(float $amount): string\\n        {\\n            return \\\"From SquarePayService $amount\\\";\\n        }\\n    }\\n\\n\\n\\nFor the `StripeService`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Services;\\n\\n    use App\\\\Interfaces\\\\PaymentInterface;\\n\\n    class StripeService implements PaymentInterface\\n    {\\n        public function pay(float $amount): string\\n        {\\n            return \\\"From StripeService $amount\\\";\\n        }\\n    }\\n\\n\\n\\nNow we have those defined and implemented the `PaymentInterface` we can move on to having to dynamically bind the interface with the corresponding class or payment provider.\\n\\n## [](#exposing-the-payment-service-providers-to-rest-api)Exposing the payment service providers to REST API\\n\\nNow let's go over and create the controllers for each of these payment service providers that we defined. If you are coding along then open up your terminal and let's create these controllers using the artisan commands.\\\\\\n\\n\\n    # Will create a directory called \\\"PaymentProvider\\\" and have \\n    # the controller named as defined \\\"PaypalController\\\" for example\\n\\n    # Paypal\\n    php artisan make:controller PaymentProvider/PaypalController\\n\\n    # Stripe\\n    php artisan make:controller PaymentProvider/StripeController\\n\\n    # SquarePay\\n    php artisan make:controller PaymentProvider/SquarePayController\\n\\n\\n\\nThen we'll go over each of these controllers and we will inject `PaymentInterface` into the constructor and pass it down into a private field.\\n\\n`PaypalController`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Http\\\\Controllers\\\\PaymentProvider;\\n\\n    use App\\\\Http\\\\Controllers\\\\Controller;\\n    use App\\\\Contracts\\\\PaymentInterface;\\n    use Illuminate\\\\Http\\\\Request;\\n\\n    class PaypalController extends Controller\\n    {\\n        private $paymentService;\\n\\n        public function __construct(PaymentInterface $paymentService)\\n        {\\n            $this->paymentService = $paymentService;\\n        }\\n\\n        public function index()\\n        {\\n            return response()->json([\\n                'data' => $this->paymentService->pay(250.0),\\n            ]);\\n        }\\n    }\\n\\n\\n\\n`StripeController`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Http\\\\Controllers\\\\PaymentProvider;\\n\\n    use App\\\\Http\\\\Controllers\\\\Controller;\\n    use App\\\\Contracts\\\\PaymentInterface;\\n    use Illuminate\\\\Http\\\\Request;\\n\\n    class StripeController extends Controller\\n    {\\n        private $paymentService;\\n\\n        public function __construct(PaymentInterface $paymentService)\\n        {\\n            $this->paymentService = $paymentService;\\n        }\\n\\n        public function index()\\n        {\\n            return response()->json([\\n                'data' => $this->paymentService->pay(10.0),\\n            ]);\\n        }\\n    }\\n\\n\\n\\n`SquarePayController`\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Http\\\\Controllers\\\\PaymentProvider;\\n\\n    use App\\\\Http\\\\Controllers\\\\Controller;\\n    use App\\\\Contracts\\\\PaymentInterface;\\n    use Illuminate\\\\Http\\\\Request;\\n\\n    class SquarePayController extends Controller\\n    {\\n        private $paymentService;\\n\\n        public function __construct(PaymentInterface $paymentService)\\n        {\\n            $this->paymentService = $paymentService;\\n        }\\n\\n        public function index()\\n        {\\n            return response()->json([\\n                'data' => $this->paymentService->pay(5.0),\\n            ]);\\n        }\\n    }\\n\\n\\n\\nOnce that's done, we can then expose these controllers as an endpoint to the REST API.\\n\\nWe define it in `api.php`\\\\\\n\\n\\n    <?php\\n\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\PaypalController;\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\SquarePayController;\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\StripeController;\\n    use Illuminate\\\\Support\\\\Facades\\\\Route;\\n\\n    Route::get('pay-with-paypal', [PaypalController::class, 'index']);\\n    Route::get('pay-with-stripe', [StripeController::class, 'index']);\\n    Route::get('pay-with-squarepay', [SquarePayController::class, 'index']);\\n\\n\\n\\nI just defined it with `GET` request HTTP method just for simplicity of the tutorial. But for actual payment implementations, prefer to use `POST` instead that it contains a payload data of payment information containing the amount, the account ID and any other sensitive information.\\n\\nSo there we defined it, you might be tempted to test it out with your HTTP client to see if it works. But actually it won't work yet as we didn't define it to act that way. So let's proceed to using Contextual Binding implementation.\\n\\n## [](#contextual-binding)Contextual Binding\\n\\nWe will be defining these bindings in the `AppServiceProvider` or you can create a different service provider that is relevant to its implementation, it can be `PaymentServiceProvider` (or any other name as you prefer) and have it registered in `AppServiceProvider`. But just for the sake of simplicity for the tutorial I will just bind the interface and their corresponding services directly into the `AppServiceProvider`.\\\\\\n\\n\\n    <?php\\n\\n    namespace App\\\\Providers;\\n\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\PaypalController;\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\SquarePayController;\\n    use App\\\\Http\\\\Controllers\\\\PaymentProvider\\\\StripeController;\\n    use App\\\\Interfaces\\\\PaymentInterface;\\n    use App\\\\Services\\\\PaypalService;\\n    use App\\\\Services\\\\SquarePayService;\\n    use App\\\\Services\\\\StripeService;\\n    use Illuminate\\\\Http\\\\Request;\\n    use Illuminate\\\\Support\\\\ServiceProvider;\\n\\n    class AppServiceProvider extends ServiceProvider\\n    {\\n        /**\\n         * Register any application services.\\n         *\\n         * @return void\\n         */\\n        public function register()\\n        {\\n            $this->app->when(PaypalController::class)\\n                ->needs(PaymentInterface::class)\\n                ->give(PaypalService::class);\\n\\n            $this->app->when(StripeController::class)\\n                ->needs(PaymentInterface::class)\\n                ->give(StripeService::class);\\n\\n            $this->app->when(SquarePayController::class)\\n                ->needs(PaymentInterface::class)\\n                ->give(SquarePayService::class);\\n        }\\n\\n        /**\\n         * Bootstrap any application services.\\n         *\\n         * @return void\\n         */\\n        public function boot()\\n        {\\n            //\\n        }\\n    } \\n\\n\\n\\nOn the `register` method of the `AppServiceProvider` is where we define the Contextual Binding, as you can see it checks on the `Controller` using the `when` method then the `needs` is referring to the dependency of that particular controller, and the last method chaining is `give` which is what we want to bind it to, these are the service classes that we defined `PaypalService`, `StripeService`, and `SquarePayService`.\\n\\nIn other words, if the `PaypalController` injects the `PaymentInterface` the service container would know that its corresponding binding will result to `PaypalService` and the same goes for `StripeController` and `SquarePayController`.\\n\\nNow that we defined that in the service container, we can proceed to testing it out manually using our HTTP or just the browser to see if it worked.\\n\\n## [](#manually-testing-in-browser)Manually Testing in browser\\n\\nIt's just a simple test. So make sure you have an active server running via `php artisan serve` and then just put up the endpoints that we defined in `api.php`; We have the following:\\n\\n*   `/api/pay-with-paypal`\\n*   `/api/pay-with-stripe`\\n*   `/api/pay-with-squarepay`\\n\\nNow let's see each of these if it returns the actual implementation from each services that we defined above when creating them.\\n\\n`/api/pay-with-paypal`\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--dwFM3ZmY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/s7efoxj18glnbabpi3nv.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--dwFM3ZmY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/s7efoxj18glnbabpi3nv.png)\\n\\nThat is exactly what we wrote in `PaypalService` to return a string from the `pay` method and we even specified it with \\\"PaypalService\\\" just for us to indicate where the implementation is coming from. So using Contextual Binding works and it solves our problem!\\n\\n`/api/pay-with-stripe`\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--1aMmStSm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vpymv4072dydw0wma3bg.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--1aMmStSm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vpymv4072dydw0wma3bg.png)\\n\\nAnd this is for Stripe.\\n\\n`/api/pay-with-squarepay`\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--CUlV1HBY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/irqy89t91rz22z0jjams.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--CUlV1HBY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/irqy89t91rz22z0jjams.png)\\n\\nAnd our last payment provider that our client wants. We got it.\\n\\n## [](#conclusion)Conclusion\\n\\nNow that we learned how to tackle multiple payment providers using the **Inversion of Control (IoC)** principle, we learned how to implement it with Laravel's service container using Contextual Binding, and we understand that we'll always go with the best approach to address a problem. Don't use Inversion of Control when it's not really relevant solution at all, no need to add complexity. Only use it when it seems the best solution.\\n\\nI hope this was useful and that you have learned something new. Thanks for taking the time to read and have a good day!\\n\\n[Full Source Code](https://github.com/carlomigueldy/laravel-inversion-of-control-tutorial)\\n\",\"timestamp\":1636676563,\"title\":\"Laravel Inversion of Control Implementation using Contextual Binding\"},\"digest\":\"5Q-ZrBzSKPi_gg9OA5aTDgbipXrE54Sq-HBJ984awKw\",\"authorship\":{\"contributor\":\"0x3E8c686F499C877D8f4aFB1215b6f0935796b986\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"signature\":\"kqiSeJeQwdSea03aWno_uHumer0R54TWiZNFgvLglnOp8dN-4WNO0NqdAUHpz1YPpJQPtikJetI-t6AO38u4xA\",\"signingKeySignature\":\"0xc823d2ab2ee5864fc5495382efb960b4461c3fb598b3be4e5e068c6312ab60ce014c7378c1f02beed8fce37236dc1e3eb8dd28a6f911b33ec4172a1fa8b17f101b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"5Q-ZrBzSKPi_gg9OA5aTDgbipXrE54Sq-HBJ984awKw\"}"