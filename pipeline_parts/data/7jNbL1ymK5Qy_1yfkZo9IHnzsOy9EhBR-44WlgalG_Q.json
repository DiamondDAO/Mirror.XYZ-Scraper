"{\"content\":{\"body\":\"# Background\\n\\nI’ve recently learned python. I’m not good at it - I still suck - but I’m a lot better. I was reflecting on how I learned it - what *obstacles I had to overcome* as well as *how* a couple of colleagues in particular helped me. And I was reflecting on my experience teaching SQL to \\\\~50 people and what types of problems they encountered most. \\n\\n# What it means to suck at coding\\n\\nEveryone who starts coding sucks at first. But what does it mean to suck? Basically, you suck if you can’t do anything useful with it. Why can’t you?\\n\\n1. Because you don’t know the logic and the syntax. It’s not natural to you yet. Why?\\n2. Because you don’t have enough experience with it. Why don’t you have much experience yet?\\n3. Because doing anything in a language you don’t know is a slow, hard slog because of errors. Why is it slow with a lot of errors? \\n4. Because to learn a language (to stop sucking) means overcoming many errors until you know *what you will do if you see error X*. You may not know exactly what the cause is, but you’ll have *a strategy to solve it*, and you’ll be confident that you will be able to find a solution.\\n\\nLearning a language starts at the bottom of this list (4. strategy to solve errors), then your speed improves (3), then you build up your experience (2) and then you understand the logic and syntax (1). Then you don’t suck anymore. Yay!\\n\\nIf all that’s true, then you can really accelerate how fast someone learns a language by focusing on (4) - helping learners fix errors faster. Everything falls into place much more easily after that. \\n\\n# Focusing on solving errors fast\\n\\nLearning a new language is about learning how to be ok with failing many times in a row until your ratio of fail to succeed on each line of code gets above some threshold (say 50%).\\n\\nIn general, you’ll fail every time you try to do something new in a language, and you’ll also fail most times to do the thing you successfully did last week. But you’ll get to success faster the 2nd time, and even faster the 10th time. \\n\\nIt takes multiple times of seeing the same error (5-10 for me) before I \\\"learn\\\" something that I will remember for a week. And I probably need to encounter a particular error 30-50 times to learn it permanently.\\n\\nWhen teaching students, the value that teachers add is that they've seen the error many times and know one or both of the following *naturally*: \\n\\n* What is causing the error (just from looking at the code)\\n* How to debug it (if it’s not an obvious problem or they don’t know the underlying data structure)\\n\\nDebugging is a learnable skill. Essentially, the best strategy is to narrow the problem down to its absolute essence. To do this:  \\n\\n* Creativity is needed \\n* Hypotheses are needed\\n* Experience helps, but is not necessary \\n\\n# Theoretical solution\\n\\nTake the absolute simplest python task: \\n\\n```\\nvar = 1\\nprint \\\"var = \\\" + var\\n```\\n\\nGives this error:\\n\\n```\\nTypeError                   Traceback (most recent call last)\\n<ipython-input-9-63b6d99501e5> in <module>()\\n      1 var = 1\\n----> 2 print \\\"var = \\\" + var\\n\\nTypeError: cannot concatenate 'str' and 'int' objects\\n```\\n\\nIf you’re not familiar with python (or programming generally as many learners aren’t), you don’t know: \\n\\n* What exactly the problem is\\n* What ‘str’ and ‘int’ stand for and maybe the word concatenate. What TypeError, Traceback <module>() or the rest of the error message is saying.\\n\\nAnd most importantly, **you don’t know: what to do next to solve it** \\n\\nIf you had a good teacher sitting beside you, they would help you understand all of those things. But you don’t. \\n\\nSo, what if you could automate what a good teacher would do. Well, perhaps you can. \\n\\nEach learner has made this error many times (i.e. 30-50 times to get to the point where it’s hard-wired into their brain), and collectively, every single python user has made this exact error many times. We can leverage that. How? \\n\\nBy figuring out what the likely solution is. How do we know what the solution is? It’ll follow this pattern: \\n\\n* Try X → fail\\n* Modify X *slightly* → succeed \\n\\nSo, to automate this learning (using the example). When you type this:\\n\\n```\\nvar = 1\\nprint \\\"var = \\\" + var\\n```\\n\\nAnd get the error above, we can search for examples in your code history where: \\n\\n* You got that exact error\\n* Then immediately after, with *very similar code* (i.e. fuzzy matching or diff distance) you didn’t get an error. The change you made before is very likely to be the solution to this new problem.\\n\\nMore concretely, it would quickly find that this example on the right which syntactically identical to the a couple of examples that *didn’t* give an error: \\n\\n![](https://images.mirror-media.xyz/publication-images/jMh5DOj9mgjx0er2Q2FdI.png?height=382&width=1318)\\n\\nAnd with those two examples - from your own coding history if possible - the learner will be able to debug their current issue much faster and accelerate how quickly they learn. \\n\\n# Technically how it might work\\n\\nCapture every code execution along with the error codes if there are errors. For python, a library like [this](https://github.com/mihneadb/python-execution-trace/blob/master/README.md) might be the foundation. Or [this](https://github.com/lgpage/nbtutor/blob/master/README.rst). Or [this](https://github.com/sametmax/devpy/blob/master/README.rst).\\n\\nWhen an error occurs at code execution, a browser window will open. In that window: \\n\\n1. All of your previous executions that resulted in that error are listed, ordered by how similar the code is that caused the error. Your code is highlighted first because it might flag your memory and use variables you understand. \\n2. But also the closest related code patterns from other YSAC users that eventually worked are also listed \\n3. Automatic, streamlined google/stack overflow/github search provides the top answers likely to help\\n4. \\\\[later paid option\\\\] ask for help from a \\\"code coach\\\" - offline or real-time via chat. A mechanism to quickly provide everything the coach would need to be able help the student.\\n\\nFor (1) and (2) it’s basically a matching algorithm to find similar code that failed then worked. A nicely designed diff interface makes it easy to figure out what subtle changes made it work. \\n\\nFor (4) cost is fixed for the student and usually $2-20. Coaches would bid on it and receive the code. If the question isn't clear, nobody will take it. Coaches would provide back: \\n\\n* Code that doesn't error (including an automatically created diff)\\n* Explanation of the error \\n* If the code still doesn't work 1-2 retries would be possible as well as 1:1 chat to quickly ask clarifying questions\\n\\nIn principle, this sort of structure could work for any programming language and maybe even natural languages (English, Spanish)\\n\\n# Benefits\\n\\nIf I think about my own learning pace, I’d estimate that having this would have helped me to learn python at least 2-3x faster. That’s an enormous gain. \\n\\nThe gains from this will be highest for those with the least experience. And it could make the difference for many between getting over the initial learning “hump” and giving up. That’s huge. \\n\\n# Updates\\n\\nIt links well with the ideas in this blog post: [How to help a student get unstuck](https://offbyone.us/posts/how-to-help-a-student-get-unstuck/).\\n\\n\\\\--\\n\\nI have no intention of pursuing this right now but I’d be delighted to hear if someone is working on something like it. Let me know at mcclelland (dot) jeff at gmail.com\\n\\n[Go back to the main page](https://mirror.xyz/mrjeff.eth/s4lo91PGvKbaqy_jd505XcYdVzX81ElPFu3fnXzTotQ).\\n\\nPhoto by [Chris Ried](https://unsplash.com/@cdr6934?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\",\"timestamp\":1639945959,\"title\":\"YSAC - You Suck At Coding\"},\"digest\":\"k4gAPct02cGmLMuHXffGj4RskKA4TANnCF-buxj_Hzg\",\"authorship\":{\"contributor\":\"0x885076fe3868E6C027e4D376ce27FA3bAC04eFc6\",\"signingKey\":\"{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"9mFGNGmYW0earuesVYw1J4QOSc8z1GNdPJx9neY2LVk\\\",\\\"y\\\":\\\"YcHhSMIYKYgLeHOIRVDHqf9A8gIX2dmNoIt14KsDg4Y\\\"}\",\"signature\":\"AlGyeCQ1_FmNr2UkZQ8f_3jpFksb_EaNWStCgYuYyv94n6ab_18JIz90BC-DWhauZgvF174TvUGDR6H9ke5pNw\",\"signingKeySignature\":\"0xe3a7e18dc06081a8048282b1c2fe7183b972bf2c7c776ad1b99e60ee1924985e21414f441db3f1d02c094820cead0d4aad6a9cae95157772649202a5f9684bff1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"9mFGNGmYW0earuesVYw1J4QOSc8z1GNdPJx9neY2LVk\\\",\\\"y\\\":\\\"YcHhSMIYKYgLeHOIRVDHqf9A8gIX2dmNoIt14KsDg4Y\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"k4gAPct02cGmLMuHXffGj4RskKA4TANnCF-buxj_Hzg\"}"