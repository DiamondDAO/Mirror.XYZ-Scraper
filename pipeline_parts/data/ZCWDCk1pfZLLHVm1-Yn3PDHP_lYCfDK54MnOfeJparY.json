"{\"content\":{\"body\":\"Today we're excited to officially introduce a new feature to the writers of Mirror: **You can now embed reserve auctions for zNFTs into any entry!**\\n\\n![](https://images.mirror-media.xyz/publication-images/48330597-1c94-4397-be25-e8648336b431.jpeg?height=900&width=1600&hide=true)\\n\\nThe journey to get to this release is full of adventure. A month ago, Mint Fund had an idea to add timed auctions to the Zora Protocol, and decided to crowdfund the effort on Mirror. Mint Fund ran this crowdfund on March 5th, raising 7 ETH to hire a developer to build a reserve auction contract.\\n\\n[https://twitter.com/themintfund/status/1368023582727696384?s=20](https://twitter.com/themintfund/status/1368023582727696384?s=20)\\n\\n## Building Auctions\\n\\nMirror and Zora worked together to outline a contract that would work with the Zora Protocol. Then, with the funds they raised, Mint Fund commissioned developer [Billy Rennekamp](https://twitter.com/billyrennekamp) to build an implementation of that outline.\\n\\nThis implementation was a promising first pass, but after we reviewed the code closely, we found at least 3 critical bugs and some other issues that needed to be patched before we could say that it was production ready. We did attempt to run the original version with a live auction, but it broke due to an interoperability issue that wasn't handled. Luckily, we were able to exploit a bug in the admin functionality, by creating a mock version of the Zora protocol, updating the Media address, and having the NFT and funds sent to our address, to retrieve the funds and the NFT. All of that is a feverish episode more appropriately described in its own post, but ultimately we were able to recover from the problem without loss of funds, and everyone involved was patient and gracious. It was yet another lesson in building and maintaining smart contracts on Ethereum, which requires extreme diligence.\\n\\nFollowing the failed trial run, the Mirror team took full ownership of the auction contract, which involved allocating a few days for intensively rewriting, reviewing, and testing it. We arrived at [a new version](https://github.com/mirror-xyz/reserve-auction-v2/blob/main/contracts/ReserveAuctionV3.sol) that we thought was tight from a security and UX perspective (developers: see note at end).\\n\\nWe then ran a high-value auction using this contract for the Generalist, including two animated NFTs by artist Jack Butcher:\\n\\n[https://twitter.com/mariodgabriele/status/1378032448664170505](https://twitter.com/mariodgabriele/status/1378032448664170505)\\n\\nThe auction was successful, and has been covered by a few mainstream media outlets such as *[The Hustle](https://twitter.com/mariodgabriele/status/1380174352113676294)*, which has over 1.5 million subscribers. This speaks to the power of protocols, the fascinating work that's happening on Ethereum, and how it can touch creators in a real way. We're delighted to be able to build these open source tools for creators to use.\\n\\n## Auction in Action\\n\\nHere is an example of the Mirror auction block in action. This auction was used for to auction the Mint Fund source code NFT.\\n\\n[Token #1522](auction://0xabEFBc9fD2F806065b4f3C237d4b59D9A97Bcac7?network=mainnet&tokenId=1522)\\n\\n## Quick Walkthrough of its Design\\n\\nThe auction [code](https://github.com/mirror-xyz/reserve-auction-v2/blob/main/contracts/ReserveAuctionV3.sol) is really well documented, and anyone who wants to understand the functionality at a deep level should be able to do so by reading it. Almost every line contains a comment that explains its purpose. Here I'll quickly take you through some of the setup.\\n\\nIt is open-sourced under the GPL3 license, which means anyone can use this code. It is compiled with Solidity version 0.6.8, so that it can be compiled and tested alongside Zora's contracts, and will be compatible.\\n\\n```jsx\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n```\\n\\nA key part of the philosophy of this auction design is that it's immutable — i.e. it's not configurable or upgradable by admins. If we want to change the rules, we'll deploy a new version and that'll exist separately. These configuration settings are all constants declared at the top of the file.\\n\\n```jsx\\n// ============ Constants ============\\n\\n// The minimum amount of time left in an auction after a new bid is created; 15 min.\\nuint16 public constant TIME_BUFFER = 900;\\n// The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\\nuint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\\n// Interface constant for ERC721, to check values in constructor.\\nbytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n// Allows external read `getVersion()` to return a version for the auction.\\nuint256 private constant RESERVE_AUCTION_VERSION = 1;\\n```\\n\\nThere are also some settings that are configured when the contract is deployed, which allows them to be different based on test networks. One important setting here is the `adminRecoveryAddress`, which is a multisig that Mirror controls that is able to fish out funds and any NFTs from the auction contract if something goes wrong. This is functionality that will be turned off forever once the auction is proven to be absolutely secure.\\n\\n```jsx\\n// ============ Immutable Storage ============\\n\\n// The address of the ERC721 contract for tokens auctioned via this contract.\\naddress public immutable nftContract;\\n// The address of the WETH contract, so that ETH can be transferred via\\n// WETH if native ETH transfers fail.\\naddress public immutable wethAddress;\\n// The address that initially is able to recover assets.\\naddress public immutable adminRecoveryAddress;\\n```\\n\\nThe auction contract can also be paused, which again allows us to step in if there's anything wrong with the contract once it's running. This will be turned off when all admin functionality is disabled. The last thing we want is for funds or NFTs to be lost due to a bug, and so we want to be explicit about the admin having this capability for the first few auctions. We definitely don't want this capability in the long-run, however.\\n\\nFinally, you can see that we store a mapping of all of the auctions that are currently running. Auctions are deleted from storage once they have finished running, to free up storage space on the Ethereum network.\\n\\n```jsx\\n// ============ Mutable Storage ============\\n\\n/**\\n * To start, there will be an admin account that can recover funds\\n * if anything goes wrong. Later, this public flag will be irrevocably\\n * set to false, removing any admin privileges forever.\\n *\\n * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\\n */\\nbool private _adminRecoveryEnabled;\\n/**\\n * The account `adminRecoveryAddress` can also pause the contracts\\n * while _adminRecoveryEnabled is enabled. This prevents people from using\\n * the contract if there is a known problem with it.\\n */\\nbool private _paused;\\n\\n// A mapping of all of the auctions currently running.\\nmapping(uint256 => Auction) public auctions;\\n```\\n\\n## How Bidding Works\\n\\nCreate bid uses best practices in validating that the amount the user sends is the same amount that they intend to bid with — by adding an `amount` parameter to the `createBid` function, and requiring that it equal the implicit ETH value in `msg.value`. We also use OpenZeppelin's well-tested ReentrancyGuard function to block reentrancy in this function.\\n\\n```jsx\\nfunction createBid(uint256 tokenId, uint256 amount)\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        auctionExists(tokenId)\\n        auctionNotExpired(tokenId)\\n    {\\n        // Validate that the user's expected bid value matches the ETH deposit.\\n        require(amount == msg.value, \\\"Amount doesn't equal msg.value\\\");\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n```\\n\\nFrom there we check if there is already a bid on this auction. If not, we keep track of the time when the first bid was placed. This will allow us to known whether to extend or close the auction later. We also validate that the amount is greater than the auction's reserve price.\\n\\n```jsx\\nif (auctions[tokenId].amount == 0) {\\n    // If so, it is the first bid.\\n    auctions[tokenId].firstBidTime = block.timestamp;\\n    // We only need to check if the bid matches reserve bid for the first bid,\\n    // since future checks will need to be higher than any previous bid.\\n    require(\\n        amount >= auctions[tokenId].reservePrice,\\n        \\\"Must bid reservePrice or more\\\"\\n    );\\n }\\n```\\n\\nOtherwise, if this bid follows others in the auction, we ensure that it is at least 10% higher in value than the previous highest bid. We then transfer the previous bid amount to the previous bidder. Note: This means that we escrow funds for the highest bid for each auction, which differs from some other auction protocols, like Zora, which just require that there is an allowance on the given token.\\n\\n```jsx\\n} else {\\n    // Check that the new bid is sufficiently higher than the previous bid, by\\n    // the percentage defined as MIN_BID_INCREMENT_PERCENT.\\n    require(\\n        amount >=\\n            auctions[tokenId].amount.add(\\n                // Add 10% of the current bid to the current bid.\\n                auctions[tokenId]\\n                    .amount\\n                    .mul(MIN_BID_INCREMENT_PERCENT)\\n                    .div(100)\\n            ),\\n        \\\"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\\\"\\n    );\\n\\n    // Refund the previous bidder.\\n    transferETHOrWETH(\\n        auctions[tokenId].bidder,\\n        auctions[tokenId].amount\\n    );\\n}\\n```\\n\\nWe then update the auction's current bid amount along with the bidder. If we're within 15 minutes of the end of the auction, this new bid will extend the auction so that it ends in 15 minutes. Therefore, we always keep the auction alive for at least 15 minutes, until there hasn't been a bid for at least 15 minutes.\\n\\n```jsx\\n// Update the current auction.\\nauctions[tokenId].amount = amount;\\nauctions[tokenId].bidder = msg.sender;\\n// Compare the auction's end time with the current time plus the 15 minute extension,\\n// to see whether we're near the auctions end and should extend the auction.\\nif (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\\n    // We add onto the duration whenever time increment is required, so\\n    // that the auctionEnds at the current time plus the buffer.\\n    auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\\n        auctionEnds(tokenId)\\n    );\\n}\\n```\\n\\nFinally, we emit an event to broadcast that an auction bid has been created.\\n\\n```jsx\\n// Emit the event that a bid has been made.\\nemit AuctionBid(tokenId, nftContract, msg.sender, amount);\\n```\\n\\n## Future Steps for the Zora Protocol\\n\\nZora is now going to take this work and expand it in ways that more fully utilize the Zora Protocol. While our version doesn't support bidding in any ERC20 token, it's quite tight and efficient. But many communities might want to run auctions in their own token, and that's where the full features of the Zora Protocol can be quite powerful. We look forward to seeing what Zora ends up deploying on this front.\\n\\n## Using Auctions on Mirror\\n\\nIf you earned and burned your $WRITE token to create a Mirror publication, you're now able to create an auction in your Mirror dashboard for any zNFT that you own. (If you haven't earned a $WRITE token yet, join [$WRITE RACE](https://mirror.xyz/race).)\\n\\nHere's how to do it:\\n\\n1. Mint any new or existing post on Mirror as an NFT. If you would like to mint an NFT that isn't a Mirror post, head over to [zora.co](https://zora.co/) and mint a zNFT through their UI.\\n2. Go to [mirror.xyz/dashboard/auctions](http://mirror.xyz/dashboard/auctions) and click \\\"Create Auction\\\"\\n3. Enter parameters like duration, reserve price, recipient address, etc.\\n4. Deploy the auction\\n5. Grab some tea. Meditate. Answer emails. Ponder existential life questions. After a couple minutes, your auction should be deployed to the Ethereum network.\\n6. At this point, you will be redirected to the auction detail page. From here, copy the embed code and paste it in any post on Mirror and voilà! You're ready to go.\\n\\n## Note to developers\\n\\nAuditing companies such as Open Zeppelin and Trail of Bits are currently booked up until Q4 this year, and so it isn't feasible for us to get this formally audited by a reputable auditing firm in the near term. However, we do have a bug bounty — so if you're up for it, please review our code and report any issues you see, and we will grant rewards in ETH for doing so. The Mirror team will offer up to 10 ETH for bugs that could result in loss of assets.\",\"timestamp\":1618438763,\"title\":\"Introducing Auctions to Mirror\",\"publication\":\"dev\"},\"digest\":\"sDbRYY3g9FzE0jaCmgYY8MFwEzD2dF015z2WaVVSMsY\",\"authorship\":{\"contributor\":\"0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"GU680Ana9mLFT-lY1S8KaDajUh_z1WKR-XxkCqpxvss\\\",\\\"y\\\":\\\"793T7RBQXyePcjCV-ssedv-sth83JalVCRUWvCr86U4\\\"}\",\"signature\":\"Yfm7ACsxSsCmzrMYA7BBqnWe5mmXyrYxVkB8M2MRVnV0DAIiSMljaDQk-hFee4zQJWO5Rq-DFKBANyvPU2-aig\",\"signingKeySignature\":\"0xdb9ff23e820a845aae784ecdf2871251f79a484d31066f454f8b1a18f9c44c6664546a453a52c7bcf65b104f2987612cff7205e4c72ac81adae71760fac8701c1b\",\"signingKeyMessage\":\"I authorize the publication of articles on dev.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"GU680Ana9mLFT-lY1S8KaDajUh_z1WKR-XxkCqpxvss\\\",\\\"y\\\":\\\"793T7RBQXyePcjCV-ssedv-sth83JalVCRUWvCr86U4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"_OstP6dwYsX-0YsIaGDw-W4fs3VzESC_QpxrhiyM_Bg\"}"