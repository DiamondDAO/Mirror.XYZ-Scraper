"{\"content\":{\"body\":\"In the [previous](https://www.codeforests.com/2022/01/14/deploy-your-first-nft-with-python/) post, we have discussed how to deploy a NFT smart contract with Python Brownie. Once your contract is deployed into the blockchain, you can interact with your live contract either by building up your own Dapp or using scripts to perform some repetitive tasks like batch token transferring or airdrop. In this article, we will share with you some popular approaches to interact with smart contract in Python once the contract is live in public network.\\n\\n#### Prerequisite\\n\\nIf you do not have [Brownie](https://eth-brownie.readthedocs.io/en/stable/index.html) installed, you shall go ahead to run the below pip command in your own Python virtual environment to install it:\\n\\n    #run in your venv\\n    pip install eth-brownie\\n\\nBrownie is heavily relying on [Web3.py](https://web3py.readthedocs.io/en/stable/index.html) and use [ganache cli](https://trufflesuite.com/docs/ganache/index.html) as the default emulator for the development network, so you will get these dependencies installed automatically.\\n\\nAnd assuming you have already compiled your smart contract and run the deployment script without any issue, if not, you may check through [this](https://www.codeforests.com/2022/01/14/deploy-your-first-nft-with-python/) post before proceeding. Now let’s explore how to interact with a deployed contract.\\n\\n#### Work with Contract in Ganache Local Network\\n\\n##### Using Ganache CLI\\n\\nThe Ganache CLI is used by default for development, and the local network is spin up when you are running your deployment script and terminated as soon as the script finished execution. In this case, the deployed contract is not stored anywhere permanently and you can only interact with it within same session before Ganache is shut down. The deployed contract is added into Brownie’s deployment map automatically, so you do not have to note down contract address when you want to refer to it. For instance, you can get your last deployed contract as per below:\\n\\n    # assuming a smart contract LegendNFT has been deployed\\n    last_deployed_contract = LegendNFT[-1]\\n\\nI would recommend you to use Brownie console when you just get started. It’s a Python interactive mode with all Brownie stuff loaded, and you can immediately get feedbacks if something goes wrong in your code. When everything is tested ok in the console, you can then copy your code to the Python script and make it re-usable for later use.\\n\\nTo start Brownie console for your local network, you can use the below command:\\n\\nAnd from the console, you can also deploy your contract:\\n\\n    >>> contract = LegendNFT.deploy({'from' : accounts[0]})\\n\\n    Transaction sent: 0x38643bde3b513dbaedf887c60162e5bb915b32bde2a804172dfaa2520b4d4ac8\\n    Gas price: 0.0 gwei Gas limit: 12000000 Nonce: 0\\n    LegendNFT.constructor confirmed Block: 1 Gas used: 3188048 (26.57%)\\n    LegendNFT deployed at: 0x3194cBDC3dbcd3E11a07892e7bA5c3394048Cc87\\n\\nThen you can verify that the contract address returned from *deploy* function is the same as the last record stored in Brownie’s deployment map:\\n\\n    >>> LegendNFT[-1]\\n    <LegendNFT Contract '0x3194cBDC3dbcd3E11a07892e7bA5c3394048Cc87'>\\n    >>> contract == LegendNFT[-1]\\n    True\\n\\nIn this case, you can always use *LegendNFT\\\\[-1] *to get the last deployed contract instead of replying on the contract address returned from your *deploy* function, and the deployment script can be kept separately so that you don’t accidently redeploying the contract when you want to run your other functions.\\n\\nOne advantage of using console is that you can use *dir* function to inspect what are the available functions in the contract instance, e.g.:\\n\\n    >>> dir(LegendNFT[-1])\\n    [abi, address, approve, balance, balanceOf, bytecode, decode_input, getApproved, \\n    getTotalNFTsMintedSoFar, get_method, get_method_object, info, isApprovedForAll, \\n    makeLegendNFT, name, ownerOf, safeTransferFrom, selectors, setApprovalForAll, \\n    signatures, supportsInterface, symbol, tokenURI, topics, totalSupply, transferFrom, tx]\\n\\n*Some of these functions are not explicated implemented in the contract but inherited from other contracts, you will be able to call them as long as the functions have public or external visibility specifier.*\\n\\nNow you can call whatever functions available in your contract, for instance:\\n\\n    >>> contract.name()\\n    'Codeforests Legend'\\n    >>> contract.totalSupply()\\n    1000000\\n\\n    >>> contract.getTotalNFTsMintedSoFar()\\n    0\\n\\nAnd you can also call your mint function which will change the state of the blockchain:\\n\\n    >>> contract.makeLegendNFT({'from':accounts[0]})\\n\\n    Transaction sent: 0x6dabe95e4c54d43864e91bfeb398c2bfb0549bf48d51db2cd42b9882e501a905\\n      Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 1\\n      LegendNFT.makeLegendNFT confirmed   Block: 2   Gas used: 777946 (6.48%)\\n\\n    <Transaction '0x6dabe95e4c54d43864e91bfeb398c2bfb0549bf48d51db2cd42b9882e501a905'>\\n\\nOf course you would still not be able to see how it looks like for your newly minted NFT since the minting was only happening in your local network. If you use the *tokenURI *function and pass in the first token ID, you shall see some base64 encoded data similar to below:\\n\\n    >>> contract.tokenURI(0)\\n\\n    'data:application/json;base64,eyJuYW1lIjogIlNwbGVuZGlkIEMjIFByb2dyYW0iLCAiZGVzY3JpcHRpb24iOiAiQSBsZWdlbmQgTkZUIGNvbGxlY3Rpb24gZm9yIGFsbCBjb2RlZm9yZXN0cyByZWFkZXJzLiIsICJpbWFnZSI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MG5hSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY25JSEJ5WlhObGNuWmxRWE53WldOMFVtRjBhVzg5SjNoTmFXNVpUV2x1SUcxbFpYUW5JSFpwWlhkQ2IzZzlKekFnTUNBek5UQWdNelV3Sno0OGMzUjViR1UrTG1KaGMyVWdleUJtYVd4c09pQWpSa1ZHUlVaRk95Qm1iMjUwTFdaaGJXbHNlVG9nVEdWaFozVmxJRk53WVhKMFlXNDdJR1p2Ym5RdGMybDZaVG9nTWpSd2VEc2dmVHd2YzNSNWJHVStQSEpsWTNRZ2QybGtkR2c5SnpFd01DVW5JR2hsYVdkb2REMG5NVEF3SlNjZ1ptbHNiRDBuSXpBMU1UWXlNaWNnTHo0OGRHVjRkQ0I0UFNjMU1DVW5JSGs5SnpVd0pTY2dZMnhoYzNNOUoySmhjMlVuSUdSdmJXbHVZVzUwTFdKaGMyVnNhVzVsUFNkdGFXUmtiR1VuSUhSbGVIUXRZVzVqYUc5eVBTZHRhV1JrYkdVblBsTndiR1Z1Wkdsa0lFTWpJRkJ5YjJkeVlXMDhMM1JsZUhRK1BDOXpkbWMrIn0='\\n\\nThis is the URI info for your NFT, and you can use base64 decoder to decode the data to see more details, or use this [website](https://nftpreview.0xdev.codes/) to preview the NFT content.\\n\\n##### Using Ganache UI\\n\\nIf you are using [Ganache](https://trufflesuite.com/ganache/) desktop version, you can add a new network in Brownie and let Brownie to connect to your Ganache RPC client. Below is the command to add a new network:\\n\\n    brownie networks add Development ganache-local host=http://127.0.0.1 network_id=5777 port=7545 cmd=ganache-cli\\n\\nThe network ID/host/port can be found from your Ganache client as per below:\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Ganache client](https://www.codeforests.com/wp-content/uploads/2022/01/ganacheui.png \\\"Python Interact with Smart Contract 1\\\")\\n\\nOnce you have added the network, you can start your Brownie console as per below:\\n\\n    brownie console --network ganache-local\\n\\n    #Attached to local RPC client listening at '127.0.0.1:7545'...\\n\\nAnd then deploy your contract:\\n\\n    >>> LegendNFT.deploy({'from' : accounts[0]})\\n\\nYou shall see some transactions went through if you check the Ganache client:\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Ganache client](https://www.codeforests.com/wp-content/uploads/2022/01/ganache-gui-contract-creation.png \\\"Python Interact with Smart Contract 2\\\")\\n\\nSo you will be able to trace the transaction history from Ganache client, and once you restart it, those history data will be gone and you will get a fresh new blockchain environment same as how the Ganache CLI works.\\n\\n#### Work with Smart Contract in Public Network\\n\\nWhen you use Brownie to deploy your contracts to public network such as rinkeby or mainnet, it automatically organize the contract ABI file by chain ID into the build/deployments folder as per below:\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Ganache client](https://www.codeforests.com/wp-content/uploads/2022/01/brownie-build-folder-e1642432762499.png \\\"Python Interact with Smart Contract 3\\\")\\n\\nSo as long as you do not delete these files, you can use *ContractName\\\\[-1] *to get the last deployed contract. To connect to rinkeby in Brownie console, specify the network as rinkeby:\\n\\n    brownie console --network rinkeby\\n\\nThen you can interact with your contract same as working in the local network except you will need to load a real wallet. If you want to be sure you are working on the correct contract, you can use *LegendNFT.at *with deployed contract address instead of *LegendNFT\\\\[-1] :*\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Ganache client](https://www.codeforests.com/wp-content/uploads/2022/01/Mint-on-rinkeby.png \\\"Python Interact with Smart Contract 4\\\")\\n\\nAwesome! you can now mint your NFT from your deployed contract in a public network. Probably you don’t want to always type the same code in the console window when you want to mint a new NFT. so let’s put the code we have tested into a script called mint.py in our scripts folder as per below:\\n\\n    from brownie import network, config, accounts, LegendNFT\\n\\n    def get_account():\\n        if network.show_active() in [\\\"development\\\", \\\"ganache-local\\\"]:\\n            return accounts[0]\\n        else:\\n            return accounts.add(config[\\\"wallets\\\"][\\\"from_key\\\"])\\n\\n    def mint_nft():\\n        contract = LegendNFT[-1]\\n        account = get_account()\\n        tx = contract.makeLegendNFT({\\\"from\\\" : account})\\n        tx.wait(1)\\n        print(\\\"Minted a new NFT with txn hash:\\\", tx.txid)\\n\\n    def main():\\n        mint_nft()\\n\\nSo when we are running this script in local network, it will just pick a dummy account for deployment, but when working in public network, it will load the account from our config for deployment.\\n\\nLet’s run this script with below:\\n\\n    brownie run mint.py --network rinkeby\\n\\nYou shall see similar output as we did from console window:\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Ganache client](https://www.codeforests.com/wp-content/uploads/2022/01/brownie-mint-NFT-from-script.png \\\"Python Interact with Smart Contract 5\\\")\\n\\nAnd [here](https://rinkeby.etherscan.io/tx/0xae45828e952ab4768c3869354d0d884c901e2e5118c71e570fea078547f07ee7) is the transaction details we can see from the etherscan by searching the transaction hash.\\n\\nWhat if I have accidentally deleted my ABI file or I want to access the contract created by someone else where I do not have the ABI data?\\n\\nDon’t worried, as long as you have your contract address, you will still be able to access the contract. You can use the below *from_explorer* from the *Contract* object to fetch the information from network explorer. For instance:\\n\\n    >>> contract = Contract.from_explorer(\\\"0xaa629be88190fe2077b970aa02f52da40ce98454\\\")\\n    Fetching source of 0xaA629BE88190fe2077b970aa02f52dA40cE98454 from api-rinkeby.etherscan.io...\\n\\n    >>> contract.name()\\n    'Codeforests Legend'\\n\\nAnd if you want to try the hard way, you can actually copy the ABI data from the network explorer such as etherscan, ployscan etc. into a local file, then load it manually into a JSON object. For instance, I have saved the ABI data from [here](https://rinkeby.etherscan.io/address/0xaA629BE88190fe2077b970aa02f52dA40cE98454#code) into a file called abi_from_rinkeby.json:\\n\\n![Python Interact with Smart Contract, Python mint NFT, Python Brownie, Smart Contract ABI](https://www.codeforests.com/wp-content/uploads/2022/01/rinkeby-contract-abi.png \\\"Python Interact with Smart Contract 6\\\")\\n\\nand with Brownie console connected to Rinkeby,  I can access my contract as per below:\\n\\n    >>> import json\\n    >>> with open(\\\"./scripts/abi_from_rinkeby.json\\\") as file:\\n    ...     contract_abi = json.load(file)\\n    ...\\n    >>> contract = Contract.from_abi(\\\"LegendNFT\\\", \\\"0xaA629BE88190fe2077b970aa02f52dA40cE98454\\\", contract_abi)\\n    >>>\\n    >>> contract.totalSupply()\\n    1000000\\n    >>>\\n    >>> contract.getTotalNFTsMintedSoFar()\\n    3\\n\\nNow with the above approach, you can start mint an NFT from someone else’s contract without going through their website.\\n\\n#### Conclusion\\n\\nIn this article, we have reviewed through a few approaches you can use to interact with your smart contract. Brownie is built up on top of the [Web3.py](https://web3py.readthedocs.io/en/stable/), but you can still use the APIs from the web3 module to interact with your contract. There are also quite a few of popular JavaScript libraries such as web3.js, ethers.js etc., you may take a look if you are planning to interact with the contract from your frontend JavaScript code.\\n\",\"timestamp\":1642606039,\"title\":\"Python Interact With Smart Contract | CODE FORESTS\"},\"digest\":\"GW7-C8yeCAF2aiJNKGR7KuEtVitXyePyPm5RXMznRcA\",\"authorship\":{\"contributor\":\"0xF36f242CE662b9fe44A203924B6b965e1d5a1B48\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"ESwaQ1q4SUSWV2E8C5CSJiNLmTZozuXolz8L7v7TP6s\\\",\\\"y\\\":\\\"vyPx2XmObAiOP53eVFwp1vd6i4cq9j5NUMloPV95ZFU\\\"}\",\"signature\":\"Z7H1qcWiXPx3R3sugbOSYHbVJ4fKmkm6E8hkqb7c8z_7GpuVvNgU0kSTGVOAbvA7ZLqpXU7bNN26OYyYfUJKlA\",\"signingKeySignature\":\"0x178ae061890ec0e312d594256f9891d402124895914f41e64b5a3e5b4d641a6a0f9514e19a72c5e12e2d1a6eea03a6154247cc16cbd4726cc6e5472ffd15e4781c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"ESwaQ1q4SUSWV2E8C5CSJiNLmTZozuXolz8L7v7TP6s\\\",\\\"y\\\":\\\"vyPx2XmObAiOP53eVFwp1vd6i4cq9j5NUMloPV95ZFU\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"GW7-C8yeCAF2aiJNKGR7KuEtVitXyePyPm5RXMznRcA\"}"