"{\"content\":{\"body\":\"### About this guide\\n\\nThis guide will probably be most helpful for people who have already used StarkNet some.\\n\\nI've been implementing a project on StarkNet full time for the past 3-4 weeks, and this contains some of the lessons learned. Questions or suggestions: [ping me on twitter @RoboTeddy](https://twitter.com/RoboTeddy).\\n\\n### Sidebar for anyone who is new to StarkNet\\n\\n* Public Service Announcement: You don't need to understand how STARKs work in order to use StarkNet!\\n* Thanks to hard work by the Starkware team, you can just learn and use Cairo (a programming language) and StarkNet (a place to deploy programs written in Cairo).\\n* The best way to learn is by following the [StarkNet documentation](https://www.cairo-lang.org/docs/hello_starknet/index.html). You can learn any Cairo you need as you go by using the [Cairo documentation](https://www.cairo-lang.org/docs/hello_cairo/index.html) and completing exercises in the [cairo playground](https://www.cairo-lang.org/playground/).\\n  * Eventually, you may want to read the more advanced [How Cairo Works](https://www.cairo-lang.org/docs/how_cairo_works/index.html), but you can definitely begin writing code without reading it.\\n\\n## StarkNet architecture mini primer\\n\\n(Note: A full explanation of how rollups work is out of scope here — for that, try [Vitalik's guide](https://vitalik.ca/general/2021/01/05/rollup.html).)\\n\\nIn StarkNet, you submit tx (e.g. contract calls, contract deployment, etc) to a sequencer. This sequencer is currently centralized and closed-source, but will later be decentralized and open-source.\\n\\nThe sequencer executes batches of tx and generates two things:\\n\\n1. A list of state deltas caused by the transaction batch (e.g. \\\\`\\\\[\\\"Update storage cell 5 to value 10\\\", \\\"Update storage cell 9 to value 12345\\\"\\\\])\\n2. A proof that there exists a set of transactions that, were they executed faithfully against the previous StarkNet state, results in the state deltas listed in item (1)\\n\\nNotably, the StarkNet transactions themselves never end up recorded on-chain at all. (They actually don't even need to be published at all for the system to operate safely!).\\n\\n* In StarkNet, transactions are off-chain and the resultant state is stored on-chain in L1 calldata.\\n* In e.g. Arbitrum, by comparison, the transactions are stored on-chain in L1 calldata and the resultant state is computed off-chain.\\n\\n## Maxim: Computation is cheap. Writes are expensive.\\n\\nStarkNet doesn't have fees on testnet. Fees on mainnet will be charged in eth, at least at first. Fees might start out simple and inaccurate, but will over time likely evolve to reflect the fundamental costs of running StarkNet:\\n\\n* **Cheap things**:\\n  * Transaction calldata. It's totally fine to have large tx! As noted above, these aren't stored on-chain.\\n  * Computation (adding, multiplying, calling functions, etc) — this all happens off-chain in a batch and is relatively cheaply verified on-chain.\\n  * Reading from a storage var — this happens off-chain.\\n* **Expensive things**:\\n  * Modifying a storage var: these modifications have to be written to L1 calldata, which is expensive.\\n\\nWhile writing code, I tend to think of everything as \\\\~free (within reason) except for state modifications.\\n\\n### Costs of particular kinds of writes\\n\\nBecause writes are expensive, it's important to be able to estimate how much they cost.\\n\\n#### A basic write that modifies a single storage_var slot\\n\\nSay you define a storage var like this:\\n\\n```ruby\\n@storage_var\\nfunc _balances(addr: felt) -> (res: felt):\\nend\\n```\\n\\nLet's examine much it might cost to execute `_balances.write(1, 123456)`.\\n\\n* **Base cost:** Writing a single storage slot costs \\\\~$0.60 (as of Nov 2021). The math:\\n  * The write causes a state diff of 64 bytes (32 bytes for the slot index number, and 32 bytes for the slot storage value)\\n  * L1 calldata costs 16 gas/byte\\n  * Gas price is \\\\~130 gwei (Nov 2021)\\n  * Eth price is \\\\~$4200 (Nov 2021)\\n  * `64 bytes * 16 gas/byte * 130e-9 eth/gas * $4200/eth = ~$0.60`\\n  * This is still 20x cheaper than an Ethereum SSTORE\\n* **'Batching rebate':** If a particular storage slot is written to `n` times within a single StarkNet batch (\\\\~1-4 hours), each write costs only `1/n`th as much. This is true even if the writes to the storage slot were caused by different tx, calls from other contracts, etc.\\n* **'Compression rebate':** If the value you're storing is a common one, it will likely compress well and take a bit less calldata. It might be complicated for StarkNet to pass these savings on to you, so I wouldn't rely on it happening soon.\\n\\nNote that only *modifying* a storage var will be costly. If you write the same value that was already written, it should be free modulo the computation costs.\\n\\n#### Cost of writing a struct to storage\\n\\nIt's possible to write structs to storage vars, and often useful to do so:\\n\\n```ruby\\nstruct Account:\\n    member id: felt\\n    member username: felt\\n    member karma: felt\\nend\\n\\n@storage_var\\nfunc _accounts(addr: felt) -> (res: Account):\\nend\\n\\n# ...\\n\\n_accounts.write(2, Account(id=3, username=23434, karma=1000))\\n```\\n\\nWriting a struct that has `n` members costs roughly `n` times as much as a basic write that modifies a single storage slot.\\n\\n#### Cost of writing to a storage var that has compound keys\\n\\nIt's possible to create a storage var that has a compound key, e.g.:\\n\\n```ruby\\n@storage_var\\nfunc _profiles(world: felt, country: felt, user_id: felt) -> (res: felt):\\nend\\n\\n# ...\\n\\n_profiles.write(10, 1, 1234, 100)\\n```\\n\\nIn this case, the key is `(10, 1, 1234)`, and the value written is `100`. Inside of StarkNet (h/t Tom Brand), this compiles down into `storage.write(key=hash(hash(10, 1), 1234), value=100)` — i.e., it requires slightly more computation due to the extra hashes, but it's still only modifying a single storage value. It costs about the same as a single basic write.\\n\\n### Use extra computation to avoid writes\\n\\nRemember the maxim: computation is cheap, writes are expensive.\\n\\nImagine you're implementing Reddit on StarkNet and want to prevent people from upvoting submissions multiple times. Options:\\n\\n1. Store every `(user_id, submission_id)` pair on-chain (too expensive!)\\n2. Store an application-wide bloom filter. When someone attempts to upvote a submission increment the upvote counter iff `hash(user_id, submission_id)` isn't already in the bloom filter.\\n\\nThe second option is probabilistic (upvotes won't be tracked perfectly), but could be *much* cheaper: there's a single small set of felts (those for storing the bloom filter) which are updated many times in each batch, resulting in a big batching rebate.\\n\\n### Cheaper writes are on the horizon\\n\\nStarkware seems to be working hard on validium/volition options that could make storage writes *much* cheaper (possibly at the expense of some censorship resistance and liveness guarantees, depending on their implementation.)\\n\\n## Learn by reading Cairo code\\n\\n* [Cairo standard library](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/common) — read this both to learn Cairo, and to learn what library functions are available for your use (they aren't well-documented elsewhere yet)\\n* [starknet-dai-bridge](https://github.com/makerdao/starknet-dai-bridge/) is a small but high-quality example. It also has an interesting deployment script that deploys to both L1 and L2.\\n* [OpenZepplin StarkNet contracts](https://github.com/OpenZeppelin/cairo-contracts/tree/main/contracts)\\n* [Argent wallet Starknet contracts](https://github.com/argentlabs/argent-contracts-starknet/tree/main/contracts)\\n* [StarkNet OS](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/starknet/core/os): an example of a lot of Cairo code written by the real experts! This is the Cairo code that implements StarkNet itself. It handles things like invoking contracts, etc.\\n\\n## StarkNet/Cairo design patterns and language tricks\\n\\n### Boolean expressions\\n\\nCairo doesn't have built-in boolean expressions like `x && y` or `p || q`. But there are some tricks.\\n\\nLet's say you *know* that `x` and `y` are each either `0` or `1`. then...\\n\\n* `assert x || y` -> `assert (x - 1) * (y - 1) = 0`\\n* `assert !x || !y` -> `assert x * y = 0`\\n* `assert x && y` -> `assert x + y = 2`\\n* etc\\n\\nYou can use these little tricks in asserts (as in the examples), or in other expressions, predicates of `if` statements, etc.\\n\\n### You can store arrays\\n\\nYou can define a `storage_var` with a key and use it to store an array. For example:\\n\\n```ruby\\n@storage_var\\nfunc _my_array(i : felt) -> (res : felt):\\nend\\n\\n# ...\\n\\n_my_array.write(0, 123)\\n_my_array.write(1, 456)\\n_my_array.write(2, 789)\\n# ...\\n```\\n\\n### Struct enum pattern\\n\\nCairo doesn't have enums, but you can abuse a struct as an enum. For example, if you define this struct:\\n\\n```ruby\\nstruct DirectionEnum:\\n    member north: felt\\n    member south: felt\\n    member west: felt\\n    member east: felt\\nend\\n```\\n\\nYou'll discover that `DirectionEnum.north == 0`, `DirectionEnum.south == 1`, `DirectionEnum.west == 2`, and `DirectionEnum.east == 3`.\\n\\nThis works because `Struct.member_name` returns the memory offset of that member of the struct. Each felt has a size of one, so each subsequent member ends up with a unique incremented value.\\n\\n### Efficiently store optional data fields\\n\\nSometimes you have a bunch of data (e.g. a user's account) that you'd like to put in storage, of which some of the member fields are optional or don't need to be used immediately.\\n\\nFor example, let's say you're implementing ENS, and there's a lot of records you might want to store:\\n\\n* name\\n* url\\n* description\\n* avatar\\n* keywords\\n* twitter\\n* reddit\\n\\nNote that many of these fields are optional, and for many domains, might never be set.\\n\\n#### Expensive way\\n\\nOne approach is to create a struct and save the whole thing to storage. For example:\\n\\n```ruby\\nstruct Domain:\\n    member name: felt\\n    member url: felt\\n    # ...\\n    twitter: felt\\n    reddit: felt\\nend\\n\\n@storage_var\\nfunc _domains(addr: felt) -> (res : Domain)\\nend\\n\\n# ...\\n\\nlet domain = Domain(\\n    name=34523,\\n    url=234234,\\n    #...\\n    twitter=0,\\n    reddit=0,\\n)\\n_domains.write(addr, domain)\\n```\\n\\nThis is expensive because it requires writing a ton of storage slots, including slots like `twitter` and `reddit` which don't need to be set now (if ever).\\n\\n#### Cheap way: storage enum struct\\n\\nDefine an enum and storage var like this:\\n\\n```ruby\\nstruct DomainStorageEnum:\\n    member name: felt\\n    member url: felt\\n    # ...\\n    member twitter: felt\\n    member reddit: felt\\nend\\n\\n@storage_var\\nfunc _domains(addr: felt, storage_index : felt) -> (res : felt):\\nend\\n```\\n\\nAnd then you can write values piecemeal, like this:\\n\\n```\\n_domains.write(addr, DomainStorageEnum.name, 34523)\\n_domains.write(addr, DomainStorageEnum.url, 234234)\\n```\\n\\nThis requires a bit more computation (longer merkle paths need to be proven), but has the advantage of letting you leave a bunch of the values uninitialized if you want.\\n\\n### Function pointers\\n\\nYou can use `get_label_address` to obtain a pointer to a function, and then `invoke` to call the function. [Example](https://gist.github.com/fracek/846d3082f9803a7e65edc44292da9241#file-ownable-cairo-L15). (h/t Martriay)\\n\\n### Functions not marked @view or @external are internal helpers\\n\\nFunctions that aren't decorated cannot be called or invoked by transactions or other contracts — they're purely helper functions which are internal to your contract.\\n\\n### Account abstraction\\n\\n#### Account contracts\\n\\nOn Ethereum L1, there are built-in \\\"accounts\\\" that are based on public/private keypairs and are capable of verifying signatures, sending value, and calling contracts.\\n\\nStarkNet doesn't have anything like that built in. Instead, people create this functionality by explicitly deploying contracts to StarkNet that have the ability to verify signatures and call other contracts.\\n\\nFor example, someone might deploy an \\\"Account\\\" contract that looks like this:\\n\\n```ruby\\n%lang starknet\\n%builtins pedersen range_check ecdsa\\n\\nfrom starkware.cairo.common.hash import hash2\\nfrom starkware.cairo.common.registers import get_fp_and_pc\\nfrom starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin\\nfrom starkware.starknet.common.syscalls import call_contract, get_caller_address, get_tx_signature\\n\\n@storage_var\\nfunc _public_key() -> (res: felt):\\nend\\n\\n@constructor\\nfunc constructor(_public_key: felt):\\n    _public_key.write(_public_key)\\n    return ()\\nend\\n\\n@external\\nfunc execute{pedersen_ptr : HashBuiltin*, syscall_ptr : felt*, range_check_ptr}(\\n        to : felt, selector : felt, calldata_len : felt, calldata : felt*)\\n\\n    # 1. Verify that whoever invoked `execute` signed everything\\n    #    with the right private key\\n    let (hash) = hash_message(to, selector, calldata_len, calldata)\\n    let (signature_len, signature) = get_tx_signature()\\n    is_valid_signature(hash, signature_len, signature)\\n\\n    #2. Call the contract that the account owner wants to interact with\\n    call_contract(\\n        contract_address=to,\\n        function_selector=selector,\\n        calldata_size=calldata_len,\\n        calldata=calldata)\\nend\\n```\\n\\nWhen the account contract is deployed, a particular public key is included in the constructor. Whenever someone wants to call `execute`, they need to include a signature from the associated private key (or else their tx is rejected). In this way, it's possible to gate access by public/private keypairs — it's just like in Ethereum, except it's not built in — we did it ourselves with contract code.\\n\\n#### Concrete example of calling an account contract\\n\\nLet's say you have an account contract deployed on StarkNet, and that you want to use it to call an ERC20 contract's transfer function.\\n\\nThe ERC20's `transfer` function might look something like this:\\n\\n```ruby\\nfunc transfer(recipient: felt, amount: felt):\\n    let (caller_address) = get_caller_address()\\n    _balances.write(caller_address, ...)\\n    # ...\\nend\\n```\\n\\nWhat you're going to do is invoke your account contract's `execute` function, and instruct it to call the `transfer` function for you.\\n\\nNote that you're not directly calling `transfer`: instead, you're telling your account contract what to call on your behalf.\\n\\nHere's how you might invoke your account contract to get it to call the ERC20 contract's transfer function in order to transfer say `30` tokens to some recipient `0x567RecipientAddr89`:\\n\\n```\\nstarknet invoke \\\\\\n    --address 0x1234AccountAddress5678 \\\\\\n    --abi account_contract_abi.json \\\\\\n    --function execute \\\\\\n    --inputs \\\\\\n        0x12ERC20Address34 \\\\\\n        23267048542 \\\\\\n        2 \\\\\\n        0x567RecipientAddr89 \\\\\\n        30\\n```\\n\\nHere's what would happen:\\n\\n1. The account contract's `execute` function is invoked.\\n2. The `execute` method verifies the signature and then looks at the inputs it was passed to determine:\\n   1. which contract it should call: the `to` arg which is `0x12ERC20Address34`\\n   2. which function on that contract should be called: the `selector` arg which is `23267048542` in this case. (It's just a hash of the string `\\\"transfer\\\"`)\\n   3. how many args it should pass on: `calldata_len`, which is `2` in this case, because the `transfer` arg takes two arguments.\\n   4. the actual args it should pass on: the `calldata` arg which is set to \\\\[`0x567RecipientAddr89`, `30`\\\\] — the recipient and the amount being transferred.\\n3. The `transfer` function is called, which then uses `get_caller_address` to learn the address of the contract that called it (namely: the address of the account contract that you originally invoked)\\n\\nRather than: \\\"I call `transfer` with the args `0x567RecipientAddr89` and `30`\\\", it's \\\"I tell my account contract to call `transfer` with the args `0x567RecipientAddr89` and `30`\\\".\\n\\nIn short, the account contract receives args, verifies them, and then takes some of the args and passes them on to the indended contract.\\n\\nContracts that are called can always use `get_caller_address()` to see who called them, and in this way the address of your account contract can be a stable identifier, similar to an Ethereum public address.\\n\\nAccount abstraction can be kind of confusing, to put it lightly, so don't worry if you don't pick it up right away.\\n\\nFor more details, check out this [discussion about standard interface for account contracts](https://github.com/OpenZeppelin/cairo-contracts/discussions/41) and [OpenZepplin's example implementation](https://github.com/OpenZeppelin/cairo-contracts/blob/main/contracts/Account.cairo).\\n\\n## Pitfalls and current limitations\\n\\n### Ambiguity between uninitialized memory and the value `0`\\n\\nBy default, if you read a key from a `storage_var` that has never previously been written to, the value you get back will be `0`. So, zero can mean uninitialized storage space.\\n\\nDepending on the logic of your application, it could be possible to run into a scenario where you read a `0` out of storage and can't be sure whether the storage was (a) uninitialized, or (b) previously actually had the value `0` written to it.\\n\\nTo avoid this ambiguity, either rely on a different storage slot to tell you whether the one of interest is already initialized, or avoid writing the value `0`, thus leaving the `0` value an unambiguous marker of uninitialized storage.\\n\\n### Revoked references\\n\\nJumps and ifs can revoke references. You can generally solve this by making more things `local`. If you'd like to understand what's going on under the hood in these cases, it may be worth reading the more advanced [How Cairo Works guide](https://www.cairo-lang.org/docs/how_cairo_works/index.html), which has a section on revoked references.\\n\\n### Max size of a felt\\n\\nA felt safely fits 251 bits. That fits 31 bytes, *not* 32 bytes!\\n\\n### Functions marked @view can be invoked\\n\\nFunctions marked `@external` and functions marked `@view` behave the same way right now, i.e. it's possible to write an `@view` function that causes state changes, and someone could invoke it.\\n\\n### Multiple transactions can have the same hash\\n\\nIt's currently possible to submit the same tx more than once (although certain wallet contracts have a nonce that guards against this.)\\n\\nThe gateway will only reply about the *first* tx with a given hash.\\n\\nSo, for example:\\n\\n1. You submit tx A, which succeeds\\n2. You poll for the tx by its hash, and eventually get back PENDING (aka, success)\\n3. You submit an identical tx B, which fails\\n4. You poll for the tx by its hash, and get back PENDING (aka, success) — despite the fact that tx B failed!\\n\\nWhen you polled to learn about tx B, the gateway actually told you about tx A. In other words, there's no direct way to get the gateway to tell you about the fate of any duplicate tx.\\n\\nStarkware is planning on a protocol modification to prevent duplicate tx.\\n\\n### Rejected tx don't show up in the [Voyager block explorer](https://voyager.online/).\\n\\nThis may change at some point, but not very soon.\\n\\n### Getting symbolicated stacktraces is a bit tricky\\n\\nYou can request a stacktrace like this:\\n\\n```\\nstarknet tx_status \\\\\\n    --hash \\\"0xsometxhashgoeshere\\\" \\\\\\n    --contract starknet-artifacts/contract.cairo/contract.json\\n    --error_message\\n```\\n\\nThe only part of the stacktrace that will be symbolicated with human-readable names is the part that involves the compiled contract definition that you passed in via `--contract`.\\n\\nYou might need to pass in different compiled contracts to symbolicate different sections of the stacktrace.\\n\\n### You can't get back return data from using `invoke`\\n\\nHopefully this might change in the future! In the mean-time, you can first `invoke()` and then subsequently `call()` to get the data you need.\\n\\n### There isn't a syscall to get the current timestamp yet\\n\\nIt's high up on Starkware's TODO list, so hopefully this will change soon.\\n\\nIn the mean-time, you can simulate/stub by creating/reading/writing a timestamp `storage_var`.\\n\\nWhen the timestamp syscall is implemented, it will initially require trusting Starkware's sequencer. Eventually, timestamps returned by the syscall will be trust-minimized (e.g. somehow bounded by Ethereum's block timestamps).\\n\\n### Not everything is open source yet\\n\\nStarkware has committed to:\\n\\n* Open-sourcing and decentralizing the sequencer\\n* Making the prover source-available under a license that requires that proofs it generates be submitted to particular on-chain open-source verifier contracts.\\n\\nThe verifier is already open source.\\n\\n### Once on mainnet, sending an L1->L2 message might have \\\\~4 hrs of latency\\n\\nOnce StarkNet is operating at greater scale (and it's economical to have more frequent batches on-chain), this latency may come down some. (On the other hand, 4 hrs is already much less than the 7 days required by optimistic rollups.)\\n\\n### Important interfaces like IAccount, IERC20, etc are in flux\\n\\nStarkware and the community are generally working together to figure out what these should look like.\\n\\n### Ethereum signature verification is coming soon\\n\\nEthereum signature verification hasn't been implemented on StarkNet yet, but will be in the future. Once it's implemented, it'll be possible to make account contracts that are controlled directly by existing Ethereum pub/priv keypairs.\\n\\nStarkware may also make it possible to create StarkNet account contracts whose addresses match Ethereum L1 public addresses. This would allow for recovery of funds, etc.\\n\\n## Tooling\\n\\n* Argent has created an alpha [StarkNet wallet browser extension](https://github.com/argentlabs/argent-x) — thanks Argent!\\n* [starknet-hardhat-plugin](https://github.com/Shard-Labs/starknet-hardhat-plugin)\\n* [starknet-devnet](https://github.com/Shard-Labs/starknet-devnet/) — this lets you create a local devnet. Note that it doesn't support L1<-->L2 messages yet.\\n* Visual Studio Code has a `cairo` extension that can use `cairo-format` to format your code\\n\\n## Testing\\n\\nI'd recommend using `pytest` as described in StarkNet's documentation. Rationale:\\n\\n* It's stable as new versions of Cairo are released\\n* It's easy to see full stack traces\\n* It executes faster than tests run against `starknet-devnet` or directly against the `goerli` testnet.\\n* There are major opportunities for speeding it up (haven't had a chance to document these — ping me if you want to learn!):\\n  * caching fixtures using pytest's caching framework and [dill](https://pypi.org/project/dill/)\\n  * using the `StarknetState` `copy` method\\n  * parallelism with [pytest-xdist](https://pypi.org/project/pytest-xdist/)\\n\\n## Overall experience so far\\n\\n* The StarkNet team is quite supportive. They're also extremely talented and are moving quickly.\\n* People in the space are collaborative — folks discuss how things should work, contribute to open source projects that support the ecosystem, etc.\\n* Cairo isn't too hard to learn. If you've learned a bunch of languages before, it might take 1-2 weeks before you become really productive.\\n* StarkNet itself is early — the protocol itself is still evolving. There are plenty of rough edges both within StarkNet, the surrounding tooling, and the ecosystem/standards. Sometimes this is fun, sometimes it's frustrating.\\n* That said, StarkNet is the only place I know of that lets you write turing-complete code that will be proven on-chain (on a testnet for now) out of the box. Things are moving quickly, which is a positive early sign about the emergence of an ecosystem.\\n\\n\\n---\\n\\nThanks to community members who have been helping develop the ecosystem and answering each others' questions (e.g. Martriay, perama, Sean, janek, Julien, corbt, et al)\\n\\nAnd thanks to all the Starkware folks who have been answering questions / making improvements / being generally supportive (e.g. Tom, Uri, Eli, Lior, guthl, FeedTheFed, et al)\\n\\nAnd thanks to [Kyle](https://twitter.com/corbtt) for working with me + reviewing this document!\",\"timestamp\":1637608740,\"title\":\"Practical StarkNet lessons learned\"},\"digest\":\"HFdtkDSqDdwLanOGkubA-wcGPj46czy1S9rgKwTcjQE\",\"authorship\":{\"contributor\":\"0x10b4eA0e50d603e803F6982Ed57E9020b97A14e0\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"yoP98OPPEPeHnQqOmOfXcRBYJpO6Gw-RUZR2dAib-s0\\\",\\\"y\\\":\\\"szopN-UaRIhxFADAgDWkEleU2PDCZz4-kP7FT4uRm6Q\\\"}\",\"signature\":\"2FotCV0kBgtDjPqAhKvO1WJUyH4tLRYarTo5jDZbmNd8wuG9B1W4-3cYj3DW5SHkmAm5GINlNwWrxQswPT1f4w\",\"signingKeySignature\":\"0x8113cf020439211ac52127a535a56967ca8543182523ec11459a2421e356e532164bfad6d029b0ca39a2874da71fb054ebd0a363fd7f4f261f9499b3164010241b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"yoP98OPPEPeHnQqOmOfXcRBYJpO6Gw-RUZR2dAib-s0\\\",\\\"y\\\":\\\"szopN-UaRIhxFADAgDWkEleU2PDCZz4-kP7FT4uRm6Q\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"ZlYHubGQZIhsLvQLWvep4TdYqD51CA5PI4Cq33mt_yU\"}"