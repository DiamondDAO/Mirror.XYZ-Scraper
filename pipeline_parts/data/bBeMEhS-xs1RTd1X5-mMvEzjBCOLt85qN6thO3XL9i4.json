"{\"content\":{\"body\":\"# gin框架\\n\\n1、gin框架的路由是采用洋葱模型，中间件和具体接口采用同样的方式，提前放入handler，只是中间件方法中，有Next()方法，继续执行下一个，具体接口中则没有Next()方法，当然，中间件中也可以采用Abort()方法，终止程序继续往下执行。\\n\\n详细可以参考这篇文章：\\n\\n[https://blog.csdn.net/raoxiaoya/article/details/109444890](https://blog.csdn.net/raoxiaoya/article/details/109444890)\\n\\n# 基础\\n\\n## struct之间可以相互比较吗\\n\\n1、同一个类型的struct，且没有不可比较的类型（map,slice等），则可以进行比较。\\n\\n2、一旦struct中包含不可比较的类型，或者是两个结构体，则不可进行比较，即便两个struct有相同的类型也不可以，因为地址不一样。\\n\\n## select\\n\\n1、select和channel配合使用，用于等待一个或多个channel的输出。\\n\\n## golang在导入包的时候，”_”/”.”二者有什么区别\\n\\n1、”_”表示，导入的包仅适用里面的`init`函数，并不适用里面其他的函数。\\n\\n2、”.”表示导入的包，在使用里面的函数时，可以省略包名。\\n\\n## slice和数组的比较\\n\\n1、数组在传参的时候，是值传递，会对整个数组进行拷贝，会消耗大量的内存。\\n\\n2、slice传参是传递引用，不会消耗大量内存，但同时这又是一个风险点，会改变原值。\\n\\n## slice的底层实现\\n\\n1、slice是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象，因为基于数组实现，所以它的底层的内存分配是连续的，效率非常高，还可以通过索引获取数据，可以迭代及垃圾回收优化。\\n\\n切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。\\n\\n切片对象非常小，是因为它是只有三个字段的数据结构：\\n\\n* 指向底层的数组指针\\n* 切片的长度\\n* 切片的容量\\n\\n**这三个字段就是golang操作底层数组的元数据**\\n\\n![slice和array](https://images.mirror-media.xyz/publication-images/LECuZxi25z2lddgRCvq0g.png?height=334&width=916)\\n\\n# slice的扩容机制是什么，有什么注意点\\n\\n* 首先判断，如果新申请容量大于2倍的旧容量，最终容量就是新申请的容量\\n* 否则判断，如果旧切片的长度小于1024，则最终容量就是旧容量的两倍\\n* 否则判断，如果旧切片长度大于等于1024，则最终容量从旧容量开始循环增加原来的 1/4, 直到最终容量大于等于新申请的容量\\n* 如果最终容量计算值溢出，则最终容量就是新申请容量\\n\\n伪代码如下：\\n\\n```\\n\\tif cap > 2*oldCap {\\n\\t\\tnewCap = cap\\n\\t} else if cap < 1024 {\\n\\t\\tnewCap = 2*oldCap\\n\\t} else {\\n\\t\\tnewCap = oldCap\\n\\t\\twhile (newCap < cap && !overflow) {\\n\\t\\t\\tnewcap += newcap/4\\n\\t\\t}\\n\\t\\tif overflow {\\n\\t\\t\\tnewCap = cap\\n\\t\\t}\\n\\t}\\n```\\n\\n# 扩容前后的slice是否相同？\\n\\n分两种情况。\\n\\n**情况一：**\\n\\n> ```\\n> 原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的Slice。\\n> ```\\n\\n**情况二：**\\n\\n> 原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。\\n\\n**要复制一个Slice，最好使用Copy函数。**\\n\\n# golang的参数传递、引用类型\\n\\nGo语言中**所有的传参都是值传递**（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是**引用类型**（**指针、map、slice、chan**等这些），这样就可以修改原内容数据。\\n\\nGolang的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。（**这也是new和make的区别**）\\n\\n# golang map底层实现\\n\\nGolang中map的底层实现是一个散列表，因此实现map的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫hmap(a header for a go map)，一个叫bmap(a bucket for a Go map，通常叫其bucket)。hmap如下所示：\\n\\n![](https://images.mirror-media.xyz/publication-images/pbNV30rC-_lqWZ5m51IV2.png?height=1042&width=506)\\n\\n图中有很多字段，但是便于理解map的架构，你只需要关心的只有一个，就是标红的字段：buckets数组。Golang的map中用于存储的结构是bucket数组。而bucket(即bmap)的结构是怎样的呢？\\n\\nbucket：\\n\\n![](https://images.mirror-media.xyz/publication-images/Iynl2hg8__oy7ufzKDQ5w.png?height=550&width=412)\\n\\n相比于hmap，bucket的结构显得简单一些，标红的字段依然是“核心”，我们使用的map中的key和value就存储在这里。“高位哈希值”数组记录的是当前bucket中key相关的“索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的bucket的指针，使得bucket会形成一个链表结构。\\n\\n整体的结构应该是这样的：\\n\\n![](https://images.mirror-media.xyz/publication-images/ZLCktYVbDaDKUi9H7wjFo.png?height=1184&width=2020)\\n\\nGolang把求得的哈希值按照用途一分为二：高位和低位。低位用于寻找当前key属于hmap中的哪个bucket，而高位用于寻找bucket中的哪个key。\\n\\n需要特别指出的一点是：map中的key/value值都是存到同一个数组中的。这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。\\n\\n![](https://images.mirror-media.xyz/publication-images/v8HAeHaflJ9XXm3OTqhqh.png?height=230&width=1928)\\n\\nMap的扩容： 当Go的map长度增长到大于加载因子所需的map长度时，Go语言就会将产生一个新的bucket数组，然后把旧的bucket数组移到一个属性字段oldbucket中。 注意：并不是立刻把旧的数组中的元素转义到新的bucket当中，而是，只有当访问到具体的某个bucket的时候，会把bucket中的数据转移到新的bucket中。\\n\\n# golang接口接收规则\\n\\n* 实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口。\\n* 实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口\\n\\n# context包有什么用途\\n\\n非常详细的说明，可以查看：\\n\\n[https://studygolang.com/articles/9624](https://studygolang.com/articles/9624)\\n\\n* 程序超时\\n\\n  我们起一个本地的 http serice，名字叫\\\"lazy\\\"，这个 http server 会随机的发出一些慢请求，要等6秒以上才返回，我们使用这个程序来模拟我们的被调用方 hang 住的情况，代码如下：\\n\\n  ```\\n  package main\\n  \\n  import (\\n      \\\"net/http\\\"\\n      \\\"math/rand\\\"\\n      \\\"fmt\\\"\\n      \\\"time\\\"\\n  )\\n  \\n  \\n  func lazyHandler(w http.ResponseWriter, req *http.Request) {\\n      ranNum := rand.Intn(2)\\n      if ranNum == 0 {\\n          time.Sleep(6 * time.Second)\\n          fmt.Fprintf(w, \\\"slow response, %d\\\\n\\\", ranNum)\\n          fmt.Printf(\\\"slow response, %d\\\\n\\\", ranNum)\\n          return\\n      }\\n      fmt.Fprintf(w, \\\"quick response, %d\\\\n\\\", ranNum)\\n      fmt.Printf(\\\"quick response, %d\\\\n\\\", ranNum)\\n      return\\n  }\\n  \\n  func main() {\\n      http.HandleFunc(\\\"/\\\", lazyHandler)\\n      http.ListenAndServe(\\\":9200\\\", nil)\\n  }\\n  ```\\n\\n  然后我们写一个主动调用的 http service，他会调用我们刚才写的\\\"lazy\\\"，我们使用 context，来解决超过2秒的慢请求问题，如下代码：\\n\\n  ```\\n  package main\\n  \\n  import (\\n      \\\"context\\\"\\n      \\\"net/http\\\"\\n      \\\"fmt\\\"\\n      \\\"sync\\\"\\n      \\\"time\\\"\\n      \\\"io/ioutil\\\"\\n  )\\n  \\n  var (\\n      wg sync.WaitGroup\\n  )\\n  \\n  type ResPack struct {\\n      r *http.Response\\n      err error\\n  }\\n  \\n  func work(ctx context.Context) {\\n      tr := &http.Transport{}\\n      client := &http.Client{Transport: tr}\\n      defer wg.Done()\\n      c := make(chan ResPack, 1)\\n  \\n      req, _ := http.NewRequest(\\\"GET\\\", \\\"http://localhost:9200\\\", nil)\\n      go func() {\\n          resp, err := client.Do(req)\\n          pack := ResPack{r: resp, err: err}\\n          c <- pack\\n      }()\\n  \\n      select {\\n      case <-ctx.Done():\\n          tr.CancelRequest(req)\\n          <-c\\n          fmt.Println(\\\"Timeout!\\\")\\n      case res:= <-c:\\n          if res.err != nil {\\n              fmt.Println(res.err)\\n              return\\n          }\\n          defer res.r.Body.Close()\\n          out, _ := ioutil.ReadAll(res.r.Body)\\n          fmt.Printf(\\\"Server Response: %s\\\", out)\\n      }\\n      return\\n  }\\n  \\n  \\n  func main() {\\n      ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)\\n      defer cancel()\\n      wg.Add(1)\\n      go work(ctx)\\n      wg.Wait()\\n      fmt.Println(\\\"Finished\\\")\\n  }\\n  \\n  在 main 函数中，我们定义了一个超时时间为2秒的 context，传给真正做事的work()，work接收到这个 ctx 的时候，需要等待 ctx.Done() 返回，因为 channel 关闭的时候，ctx.Done() 会受到空值，当 ctx.Done()返回时，就意味着 context 已经超时结束，要做一些扫尾工作然后 return 即可。\\n  ```\\n* 生成Request ID中间件\\n\\n  在 Golang1.7 中，`\\\"net/http\\\"`原生支持将Context嵌入到 `*http.Request`中，并且提供了`http.Request.Conext()` 和 `http.Request.WithContext()`这两个函数来新建一个 context 和 将 context 加入到一个`http.Request`实例中。下面的程序演示了一下利用`WithValue()`创建一个可以储存 K-V 的 context，然后写一个中间件来自动获取 http头部的 \\\"X-Rquest-ID\\\"值，加入到 context 中，使业务函数可以直接取到该值，代码如下：\\n\\n  ```\\n  package main\\n  \\n  import (\\n      \\\"net/http\\\"\\n      \\\"context\\\"\\n      \\\"fmt\\\"\\n  )\\n  \\n  const requestIDKey = \\\"rid\\\"\\n  \\n  func newContextWithRequestID(ctx context.Context, req *http.Request) context.Context {\\n      reqID := req.Header.Get(\\\"X-Request-ID\\\")\\n      if reqID == \\\"\\\" {\\n          reqID = \\\"0\\\"\\n      }\\n      return context.WithValue(ctx, requestIDKey, reqID)\\n  }\\n  \\n  func requestIDFromContext(ctx context.Context) string {\\n      return ctx.Value(requestIDKey).(string)\\n  }\\n  \\n  func middleWare(next http.Handler) http.Handler {\\n      return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\\n          ctx := newContextWithRequestID(req.Context(), req)\\n          next.ServeHTTP(w, req.WithContext(ctx))\\n      })\\n  }\\n  \\n  func h(w http.ResponseWriter, req *http.Request) {\\n      reqID := requestIDFromContext(req.Context())\\n      fmt.Fprintln(w, \\\"Request ID: \\\", reqID)\\n      return\\n  }\\n  \\n  func main() {\\n      http.Handle(\\\"/\\\", middleWare(http.HandlerFunc(h)))\\n      http.ListenAndServe(\\\":9201\\\", nil)\\n  }\\n  ```\\n\\n## golang为什么高效\\n\\n1、goroutine是golang并行设计的核心。\\n\\n2、goroutine说到底就是协程，但是它比线程更小，几十个协程可能底层对应的就是五六个线程，golang内部帮你实现了这些协程之间的内存共享。\\n\\n3、执行协程，只需要极少的栈内存，大概是4\\\\~5kb，也正因为这样，在一台机器上可以开启成千上万个协程，只要内存足够即可。\\n\\n4、golang既支持通过共享内存进行通讯，也支持通过消息传递的方式进行通讯，后者是CSP的一个变种，效率更高，也是golang推荐的方式。\\n\\n**总结为：用户空间 避免了内核态和用户态的切换导致的成本、可以由语言和框架层进行调度、更小的栈空间允许创建大量的实例。**\\n\\n关于golang的CSP模型说明，可以查看这篇文章：\\n\\n[https://www.jianshu.com/p/36e246c6153d](https://www.jianshu.com/p/36e246c6153d)\\n\\n# 线程、进程、协程的区别\\n\\n* **进程**：拥有自己独立的堆和栈，既不共享堆，也不共享栈，进程由操作系统调度；\\n* **线程**：拥有自己独立的栈和共享的堆，共享堆，不共享栈，标准线程由操作系统调度；线程一般有固定的栈，有一个固定的大小，涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。\\n* **协程**：拥有自己独立的栈和共享的堆，共享堆，不共享栈，协程由程序员在协程的代码里显式调度，goroutines为了避免资源浪费（亦或是资源缺乏)，采用动态扩张收缩的策略：初始量为2k，最大可以扩张到1G，因为协程在用户态由协程调度器完成，不需要陷入内核，这代价就小了。所以goroutine：只有三个寄存器的值修改 - PC / SP / DX.\\n\\n### 每个线程都有一个id，在线程创建的时候就会被返回，所以我们可以通过线程的id来操纵线程。但是在golang中没有这个概念，因此我们在编码之初就要考虑协程的创建和释放问题。\\n\\n**goroutinue和协程的两个不同点**\\n\\n1. goroutinue可以实现并行，也就是说，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。\\n2. goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。\\n\\n[https://studygolang.com/articles/10112](https://studygolang.com/articles/10112)\\n\\n# 特别需要注意的代码执行题目\\n\\n1、以下程序输出什么\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc calc(index string, a, b int) int {\\n\\tret := a + b\\n\\tfmt.Println(index, a, b, ret)\\n\\treturn ret\\n}\\n\\nfunc main() {\\n\\ta := 1\\n\\tb := 2\\n\\tdefer calc(\\\"1\\\", a, calc(\\\"10\\\", a, b))\\n\\ta = 0\\n\\tdefer calc(\\\"2\\\", a, calc(\\\"20\\\", a, b))\\n\\tb = 1\\n\\t//time.Sleep(1000 * time.Second)\\n}\\n\\noutput:\\n10 1 2 3\\n20 0 2 2\\n2 0 2 2\\n1 1 3 4\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\ts := make([]int, 5)\\n\\ts = append(s, 1, 2, 3)\\n\\tfmt.Println(s)\\n}\\noutput:\\n[0 0 0 0 0 1 2 3]\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\ntype People interface {\\n\\tSpeak(string) string\\n}\\n\\ntype Stduent struct{}\\n\\nfunc (stu *Stduent) Speak(think string) (talk string) {\\n\\tif think == \\\"bitch\\\" {\\n\\t\\ttalk = \\\"You are a good boy\\\"\\n\\t} else {\\n\\t\\ttalk = \\\"hi\\\"\\n\\t}\\n\\treturn\\n}\\n\\nfunc main() {\\n\\tvar peo People = Stduent{}\\n\\tthink := \\\"bitch\\\"\\n\\tfmt.Println(peo.Speak(think))\\n}\\n\\n//编译不过去，需要修改一行代码：\\nvar peo People = Stduent{} 修改为 var peo People = &Stduent{}\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\ntype People interface {\\n\\tShow()\\n}\\n\\ntype Student struct{}\\n\\nfunc (stu *Student) Show() {\\n\\n}\\n\\nfunc live() People {\\n\\tvar stu *Student\\n\\treturn stu\\n}\\n\\nfunc main() {\\n\\tif live() == nil {\\n\\t\\tfmt.Println(\\\"AAAAAAA\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"BBBBBBB\\\")\\n\\t}\\n}\\n\\noutput:\\nBBBBBBB\\n原因：指针类型的地址和nil不一致，不相等\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tdefer_call()\\n}\\n\\nfunc defer_call() {\\n\\tdefer func() { fmt.Println(\\\"打印前\\\") }()\\n\\tdefer func() { fmt.Println(\\\"打印中\\\") }()\\n\\tdefer func() { fmt.Println(\\\"打印后\\\") }()\\n\\n\\tpanic(\\\"触发异常\\\")\\n}\\noutput:\\n打印后\\n打印中\\n打印前\\npanic: 触发异常\\n\\n原因：遇到panic，遍历本协程的defer链表，并按照先进后出的顺序执行\\n```\",\"timestamp\":1640152634,\"title\":\"golang面试题\"},\"digest\":\"JlcxsI10o1hX3P8ySZJU_gt1p2B3MQAz12Mbic0xWkQ\",\"authorship\":{\"contributor\":\"0x3593df8f329981B1C3E9066551dF17F2174ADdc5\",\"signingKey\":\"{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"radAaubne67thmoryTxpzSwR_0Ik7-bwqbpQiMA9XPc\\\",\\\"y\\\":\\\"ZOSzZYm_AAsnGpj8TQlc-a-nY8dmV86WRmGf_HnGW_o\\\"}\",\"signature\":\"K51RBO3GUziY_8IC9p7hcouV0DRwXKZXDGn7_QsQljhomMc9e_EvgLVu99jB34wQ6JioiSnEOHNLStXRJVlM2Q\",\"signingKeySignature\":\"0x5dd073eb2d98ef2911b4e30b0a4b2d9d090a718b4eca938f2dd71249f981dd715fad9c3d70dcbb2a88e3e321ee0514377a15ade4478408e95957362d85ca97f61b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"radAaubne67thmoryTxpzSwR_0Ik7-bwqbpQiMA9XPc\\\",\\\"y\\\":\\\"ZOSzZYm_AAsnGpj8TQlc-a-nY8dmV86WRmGf_HnGW_o\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"LEFQeon2SUK-49_g-J0ASzbTXO9XT1GuNs_l5EIPFR4\"}"