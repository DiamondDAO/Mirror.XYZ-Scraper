"{\"content\":{\"body\":\"I know. Yet another state management library.\\n\\nBut hey: I was in an abusive relationship with Redux / Mobx / Context / Recoil anyway, that kind of relationship where you hate it 20% of the times, but love it enough so you keep using it over and over. After all, who wants to rewrite the stores?\\n\\nRecently I got some green field projects to bootstrap and I decided to give this new kid on the block a chance to prove itself worthy of being another tool on the belt.\\n\\nAnd hell, I honestly threw away the other tools.\\n\\n### A minimal API\\n\\nYou need something to integrate nicely with react hooks? Prefer classes? Want to update the state outside hooks? Use it with react-native? First class typescript support?\\n\\nCheck, check, check.\\n\\n```\\n\\nimport { createState } from \\\"@hookstate/core\\\";\\n\\nconst state = createState({userId: 1});\\nstate.userId.set(2)\\nconsole.log(state.value) // 2\\nstate.merge({userId: 3})\\nconsole.log(state.value) // 3\\n```\\n\\nThe main API for reading and updating or creating data is essentially:\\n\\n* `createState()`: Creates a new state object\\n* `.value`: Gets the value of the state\\n* `.set()`: Sets the value of the state\\n* `.merge()`: Updates or adds value to an object state (more performant)\\n\\nHookstate provides this minimalistic way to set and get data without enforcing a data modeling architecture around it — that is your job dear reader!\\n\\n### Reacting to data changes\\n\\nHookstate exposes `useHookstate` to subscribe to changes on a model (or a part of a model - more on that later!).\\n\\n```\\n// Creating a model with a simple number inside\\nconst model = createState(1);\\n\\n// We can update the state outside hooks!\\nsetInterval(() => {\\n  model.set(current => current + 1);\\n}, 1000)\\n\\nfunction Body() {\\n  // Subscribe this component to changes on the model\\n  const { value, set } = useHookstate(model);\\n  return (\\n    <>\\n      <p>Current state: {value}</p>\\n      <button onClick={() => set((current) => current - 1)}>\\n        Decrement one\\n      </button>\\n    </>\\n  );\\n} \\n```\\n\\n### Usage tracking: Optimized rerendering for complex states\\n\\nA killer feature from hookstate is the ability to subscribe only to portions of a big state object — ignoring changes on the rest of the state tree. And this is automatic!\\n\\nOn the example below we have an object state with two properties but since our component only subscribe to one, it will only rerender when the the `name` changes:\\n\\n```\\n\\nconst userModel = createState({\\n  name: 'Archimedes of Syracuse',\\n  role: 'ENGINEER',\\n});\\n\\nfunction NameComponent() {\\n  const nameState = useHookstate(userModel);\\n\\n  return (\\n    <>\\n      <p>Name: {nameState.name.value}</p> {/* Because we only read the name... */}\\n      <button onClick={() => userModel.role.set('DESIGNER')}>\\n        Change role {/* Changing role won't cause this component to rerender! */}\\n      </button>\\n    </>\\n  );\\n}\\n```\\n\\n### Things to avoid to make “usage tracking” work\\n\\nNow, although usage tracking is automatic, in my experience there is some things that will make it stop working. Here’s some things to avoid while using hookstate to keep your application as performant as possible:\\n\\n* Subscribe to the root of your state, never to parts of it\\n\\n  ```\\n  \\n  const name = useHookstate(userModel.profile.name).value; // BAD!\\n  \\n  const name = useHookstate(userModel).profile.name.value; // GOOD\\n  ```\\n\\n\\n* The way you modify your state matters: there’s good documentation about this: <https://hookstate.js.org/docs/nested-state#updating-existing-property>\\n\\n  ```\\n  // We want to change the role inside the profile.role property...\\n  \\n  userModel.set({profile: {name: user.name, role: 'DESIGNER'}); // BAD\\n  \\n  userModel.profile.role.set('DESIGNER'); // GOOD\\n  // OR BETTER YET\\n  userModel.merge({profile: {role: 'DESIGNER'}}); // BEST\\n  ```\\n\\nAlways try to use the `.merge` method when updating or adding data. On the example above, if we called `userModel.profile.role.set('DESIGNER');` three times it would make all components dependent on the role three times, while merge only once.\\n\\n### Type safety\\n\\nLuckily, hookstate has types out of the box. the only thing we need to do is to pass the interface we want to save when calling `createState`\\n\\n```\\nconst numberState = createState<number>(1);\\nnumberState.set('a string'); // Compilation error!\\n\\nconst userState = createState<{userId: string; token?: string}>(\\n\\t{userId: '12345abc'}\\n)\\n```\\n\\n### Building your architecture\\n\\nNow with the building blocks, you can go ahead and create your own architectures around how you manipulate data on you application. I like to separate the states into what I call “stores” and create some helper functions and hooks for ease of access, like the following store for flags in the app:\\n\\n```\\nimport { createState, useHookstate } from '@hookstate/core';\\n\\nexport interface Flags {\\n  hasSeenOnboardingSlides: boolean;\\n\\thasSeenFeedbackModal: boolean;\\n}\\n\\nexport interface FlagsStore {\\n  flags: Flags;\\n}\\n\\nconst flagsStore = createState<FlagsStore>(\\n  PersistorWrapper({ flags: { hasSeenOnboardingSlides: false, hasSeenFeedbackModal: false } }),\\n);\\n\\nexport default flagsStore;\\n\\n/**\\n* Helper hooks\\n*/\\n\\nexport function useFlag(flag: keyof Flags) {\\n  const flags = useHookstate(flagsStore.flags).value;\\n\\n  return flags[flag];\\n}\\n\\nexport function setFlag(flag: keyof Flags, value: boolean) {\\n  flagsStore.flags[flag].set(value);\\n```\\n\\n### Conclusion\\n\\nThat cover the very basics of hookstate and some of the main use cases for using it. Let me know what would you like me to talk about in a future article:\\n\\n* Persist state on LocalStorage / AsyncStorage (React Native)\\n* Disadvantages using hookstate\\n* Collections/arrays of elements and how to subscribe a component to only one element in an array\\n* Developer tooling and debugging\",\"timestamp\":1640367840,\"title\":\"Hookstate: Flexible state management for React(Native)\"},\"digest\":\"AxPxC5jwqxVcohtbbU43Jo0vEpJkKv-6ot1gj8LCdAA\",\"authorship\":{\"contributor\":\"0x9617431456611493a9d0de953f051dD6aE6aA539\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"kTl5wPJJlvriysQFsogQ7Emcl5BnuFUGE8UUruyILPU\\\",\\\"y\\\":\\\"A7mfVPVxs9_G5bQEvnFnjX9mJ-7foXd_H3yEbFXfpZg\\\"}\",\"signature\":\"jEqT2RBjdM_u9sLW8yOLrBzOz5Ad_Ar5J1pDz1Vtz_VxhMudr-u9lZOHoXy5WdvsVLw-6jca772V6icaqHmTdg\",\"signingKeySignature\":\"0x9bed51efcef64f1f1d913e2baa3025e07b0a2d88663fb55513dc3bedba67cdf1061ad8b3580dd5ac3322ce4e1424b53658f98a43bcddc5a4f9146e83263f111c1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"kTl5wPJJlvriysQFsogQ7Emcl5BnuFUGE8UUruyILPU\\\",\\\"y\\\":\\\"A7mfVPVxs9_G5bQEvnFnjX9mJ-7foXd_H3yEbFXfpZg\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"AxPxC5jwqxVcohtbbU43Jo0vEpJkKv-6ot1gj8LCdAA\"}"