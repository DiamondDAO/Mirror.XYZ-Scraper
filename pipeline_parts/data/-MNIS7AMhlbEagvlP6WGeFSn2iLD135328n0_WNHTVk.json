"{\"content\":{\"body\":\"**Use a .dockerignore file**\\n\\nTo increase the build’s performance, you can exclude files and directories by adding a `.dockerignore` file .\\n\\n## **Minimize the number of layers / Consolidate instructions**\\n\\nEach instruction in the Dockerfile adds an extra layer to the docker image.The number of instructions and layers should be kept to a minimum as this ultimately affects build performance and time.\\n\\n## **Use COPY command instead of ADD**\\n\\n## **Avoid installing unnecessary packages**\\n\\n## **Take advantage of docker cache to reduce the build time**\\n\\nDocker creates a layer on top of existing layer for each instruction in docker file ,and caches it.When you re-run the docker build command it searches for the layer in the cache if its there it uses the cachedlayer otherwise cache is invalidated and all the layers after that are build again. As we build every-time after a code change layer after code copy will be invalidated ,\\\\*\\\\*build the dependencies first and then copy the code in Dockerfile \\\\*\\\\*so that cache can be leveraged.\\n\\nEg:\\n\\n***COPY code/ /usr/src/app***\\n\\n***RUN pip install requirement.txt***\\n\\nIn this case, every time you change code pip install will run increase in the build time.\\n\\n***COPY requirement.txt /usr/src/app***\\n\\n***RUN pip install requirement.txt***\\n\\n***COPY code/ /usr/src/app***\\n\\nIn this case pip install will not run if there are no changes in requirement.txt ,only COPY instruction will run reducing build time in total.\\n\\n## **ENTRYPOINT VS CMD VS RUN**\\n\\n**The recommendation is use CMD in your Dockerfile when you want the user of your image to have the flexibility to run whichever executable they choose when starting the container.**\\n\\nRUN executes command(s) in a new layer and creates a new image. E.g., it is often used for installing software packages.\\n\\nCMD sets default command and/or parameters, which can be overwritten from the command line when docker container runs.\\n\\nENTRYPOINT configures a container that will run as an executable.\\n\\n## **Shell vs. Exec form of ENTRYPOINT/CMD**\\n\\n**We should always run ENTRYPOINT or CMD in exec form as in exec form executable gets pid 1 and it can listen to SIGNALS.**\\n\\n**Shell form**\\n\\n`<instruction> <command>`\\n\\nExamples:\\n\\n***RUN apt-get install python3***\\n\\n***CMD echo “Hello world”***\\n\\n***ENTRYPOINT echo “Hello world”***\\n\\nWhen an instruction is executed in *shell* form it calls `/bin/sh -c <command>` under the hood and normal shell processing happens. For example, the following snippet in Dockerfile\\n\\n***ENV name John Dow***\\n\\n***ENTRYPOINT echo “Hello, $name”***\\n\\nwhen container runs as `docker run -it <image>` will produce output\\n\\n`Hello, John Dow`\\n\\nNote that variable *name* is replaced with its value.\\n\\n**Exec form**\\n\\nThis is the preferred form for CMD and ENTRYPOINT instructions.\\n\\n`<instruction> [\\\"executable\\\", \\\"param1\\\", \\\"param2\\\", ...]`\\n\\nExamples:\\n\\n***RUN \\\\[“apt-get”, “install”, “python3”\\\\]***\\n\\n***CMD \\\\[“/bin/echo”, “Hello world”\\\\]***\\n\\n***ENTRYPOINT \\\\[“/bin/echo”, “Hello world”\\\\]***\\n\\nWhen the instruction is executed in *exec* form it calls executable directly, and shell processing does not happen. For example, the following snippet in Dockerfile\\n\\n***ENV name John Dow***\\n\\n***ENTRYPOINT \\\\[“/bin/echo”, “Hello, $name”\\\\]***\\n\\nwhen container runs as `docker run -it <image>` will produce output\\n\\n`Hello, $name`\\n\\nNote that variable *name* is not substituted.\\n\\n## **Gracefully stopping docker container**\\n\\n`docker stop`\\\\*\\\\* \\\\*\\\\*command attempts to stop a running container first by sending a SIGTERM signal to the root process (PID 1) in the container. If the process hasn't exited within the timeout period a SIGKILL signal will be sent.`docker kill` command doesn't give the container process an opportunity to exit gracefully -- it simply issues a SIGKILL to terminate the container.\\n\\n**When you use** `docker stop` or `docker kill` to signal a container, that signal is sent only to the container process running as PID 1.\\n\\nSince in shell form */bin/sh* doesn’t forward signals to any child processes, the SIGTERM we sent never reaches our script/executable. Clearly, if we want our app to be able to receive signals from the host we need a way to run it as PID 1, we can acchive this by running the excutables in exce form discussed above.\\n\\n## \\\\*\\\\*Avoid `RUN apt-get upgrade` and \\\\*\\\\*`dist-upgrade`\\n\\nAs many of the “essential” packages from the parent images cannot upgrade inside an [unprivileged container](https://docs.docker.com/engine/reference/run/#security-configuration). If a package contained in the parent image is out-of-date, contact its maintainers. If you know there is a particular package, `foo`, that needs to be updated, use`apt-get install -y foo` to update automatically.\\n\\n## **Always combine** `RUN apt-get update` with `apt-get install` in the same `RUN` statement.\\n\\n```\\nRUN apt-get update && apt-get install -y \\\\\\n        package-bar \\\\\\n        package-baz \\\\\\n        package-foo\\n```\\n\\nUsing `apt-get update` alone in a `RUN` statement causes caching issues and subsequent `apt-get install` instructions fail. For example, say you have a Dockerfile:\\n\\n```\\nFROM ubuntu:14.04\\n    RUN apt-get update\\n    RUN apt-get install -y curl\\n```\\n\\nAfter building the image, all layers are in the Docker cache. Suppose you later modify `apt-get install`by adding extra package:\\n\\n```\\nFROM ubuntu:14.04\\n    RUN apt-get update\\n    RUN apt-get install -y curl nginx\\n```\\n\\nDocker sees the initial and modified instructions as identical and reuses the cache from previous steps. As a result the `apt-get update` is *not* executed because the build uses the cached version. Because the `apt-get update` is not run, your build can potentially get an outdated version of the `curl` and `nginx`packages.\\n\\nUsing `RUN apt-get update && apt-get install -y` ensures your Dockerfile installs the latest package versions with no further coding or manual intervention\\n\\n```\\nRefrences\\nhttps://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/\\nhttps://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/\\nhttps://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/#the-dockerfile-instructions\\nhttps://www.ctl.io/developers/blog/post/dockerfile-add-vs-copy/\\n```\",\"timestamp\":1636626089,\"title\":\"Docker Best Practices \"},\"digest\":\"ot2NIa3lfaAMXdpz3RYCaI6-QkSeNpzfr_hdQO00bz0\",\"authorship\":{\"contributor\":\"0xfC6bD76fe59278e112F5B81e0916C58599728043\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"EQSbUe2sJrN37JiHsp_k33xCITPE_Tv2wpeAqsTM68Q\\\",\\\"y\\\":\\\"U-aonj0Tw9C0HLPgIm3okvOwO12xmJMrriv1OuYDp18\\\"}\",\"signature\":\"Pz75sex6I3RTldDV6OpPKa6ipqbo_vaSsMW0dxho1cuNj0F7Fs9uNWbnHZ3p1Wo2pHNQehjkSJZgo0h9h7lhtA\",\"signingKeySignature\":\"0x421a877d7bf23dadff008b9f481f157cc1e17c1b34dcfd11275150ff72bb7bc04b85cb017fc82d580a9b36f7b16cf0ab30eb23bb126bedec826423dabf7f93f61b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"EQSbUe2sJrN37JiHsp_k33xCITPE_Tv2wpeAqsTM68Q\\\",\\\"y\\\":\\\"U-aonj0Tw9C0HLPgIm3okvOwO12xmJMrriv1OuYDp18\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"ot2NIa3lfaAMXdpz3RYCaI6-QkSeNpzfr_hdQO00bz0\"}"