"{\"content\":{\"body\":\"Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\\n\\nNFTs give us new tools to solve this problem — by representing previously infinitely-reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \\n\\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\\n\\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\\n\\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \\n\\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\\n\\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\\n\\nThis could signal the beginning of a movement towards journalist and artist DAOs.\\n\\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\\n\\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\\n\\n## Problems We're Solving\\n\\n- Writers want funding for a long-form piece of content before writing it\\n- Contributors want to fund their favorite writers, and receive some return on their investment\\n- Contributors want to be recognized as patrons of public goods\\n- Speculators want to invest in NFTs, including those that represent *written* works\\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\\n\\n## What Success Looks Like\\n\\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\\n- The work is represented by a tradable NFT\\n- The Creator can update the NFT's metadata once the work is finished\\n- The Creator can trade that NFT for a profit\\n- Contributors can trade their ownership stake on Uniswap\\n- Contributors can divest their stake for accumulated revenue\\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\\n\\n## Out of Scope\\n\\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\\n\\n## Implementation Summary\\n\\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\\n- The contract has a \\\"hard cap\\\", beyond which nobody else can join the crowdfund.\\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\\n    - The downside is that one person might just buy all of it, which is less fun.\\n\\n## Potential Downsides\\n\\n- It could have a vulnerability, and lose funds.\\n\\n## Implementation Details\\n\\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\\n\\n```js\\n//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {\\n    ReentrancyGuard\\n} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport {Decimal} from \\\"../Decimal.sol\\\";\\nimport {IMarket} from \\\"../interfaces/IMarket.sol\\\";\\nimport {IMedia} from \\\"../interfaces/IMedia.sol\\\";\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\n\\n/**\\n * @title Crowdfund\\n * @author MirrorXYZ\\n *\\n * Crowdfund the creation of NFTs by issuing ERC20 tokens that\\n * can be redeemed for the underlying value of the NFT once sold.\\n */\\ncontract Crowdfund is ERC20, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    // ============ Enums ============\\n\\n    enum Status {FUNDING, TRADING}\\n\\n    // ============ Constants ============\\n\\n    uint256 private constant funding_cap_eth = 10000000000000000000;\\n    uint256 private constant SCALING_FACTOR = 1e27;\\n\\n    // ============ Immutable Storage ============\\n\\n    address public operator;\\n    address public mediaAddress;\\n    address public WETH;\\n    uint256 public operatorEquityPercent;\\n\\n    // ============ Mutable Storage ============\\n\\n    // Represents the current state of the campaign.\\n    Status public status;\\n\\n    // ============ Events ============\\n\\n    event FundingOpened(\\n        address media,\\n        address creator,\\n        uint256 creatorEquityPercent\\n    );\\n    event Contribution(address contributor, uint256 amount);\\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\\n    event BidAccepted(uint256 amount);\\n    event Withdrawal(address contributor, uint256 amount);\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @dev Modifier to check whether the `msg.sender` is the operator.\\n     * If it is, it will run the function. Otherwise, it will revert.\\n     */\\n    modifier onlyOperator() {\\n        require(msg.sender == operator);\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(\\n        address operator_,\\n        address mediaAddress_,\\n        address WETH_,\\n        uint256 operatorEquityPercent_,\\n        IMedia.MediaData memory data,\\n        IMarket.BidShares memory bidShares\\n    ) public ERC20(\\\"Crowdfund\\\", \\\"CROWD\\\") {\\n        // Initialize immutable storage.\\n        mediaAddress = mediaAddress_;\\n        operator = operator_;\\n        operatorEquityPercent = operatorEquityPercent_;\\n        WETH = WETH_;\\n\\n        // Initialize mutable storage.\\n        status = Status.FUNDING;\\n\\n        // Mint an NFT token.\\n        IMedia(mediaAddress).mint(data, bidShares);\\n\\n        // Signal that funding has been opened.\\n        emit FundingOpened(mediaAddress, operator, operatorEquityPercent);\\n    }\\n\\n    // ============ Crowdfunding Methods ============\\n\\n    /**\\n     * @notice Mints tokens for the sender propotional to the\\n     *  amount of ETH sent in the transaction.\\n     * @dev Emits the Contribution event.\\n     */\\n    function contribute() external payable nonReentrant {\\n        require(status == Status.FUNDING, \\\"Funding must be open\\\");\\n\\n        require(\\n            msg.value.add(address(this).balance) <= funding_cap_eth,\\n            \\\"Total contributions would exceed funding cap\\\"\\n        );\\n\\n        // Mint equity for the contributor.\\n        _mint(msg.sender, msg.value);\\n\\n        emit Contribution(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @notice Burns the sender's tokens and redeems underlying ETH.\\n     * @dev Emits the Withdrawal event.\\n     */\\n    function withdraw(uint256 tokenAmount) external nonReentrant {\\n        require((balanceOf(msg.sender) >= tokenAmount), \\\"Insufficient balance\\\");\\n\\n        uint256 redeemable = redeemableFromTokens(tokenAmount);\\n\\n        _burn(msg.sender, tokenAmount);\\n\\n        msg.sender.transfer(redeemable);\\n\\n        emit Withdrawal(msg.sender, redeemable);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH that is redeemable for tokenAmount.\\n     */\\n    function redeemableFromTokens(uint256 tokenAmount)\\n        public\\n        view\\n        returns (uint256 redeemable)\\n    {\\n        uint256 stakeScaled =\\n            tokenAmount.mul(SCALING_FACTOR).div(totalSupply());\\n\\n        // Round up after scaling.\\n        redeemable = stakeScaled\\n            .mul(address(this).balance)\\n            .sub(1)\\n            .div(SCALING_FACTOR)\\n            .add(1);\\n    }\\n\\n    // ============ Operator Methods ============\\n\\n    /**\\n     * @notice Transfers all funds to operator, and mints tokens for the operator.\\n     *  Updates status to TRADING.\\n     * @dev Emits the FundingClosed event.\\n     */\\n    function closeFunding() external onlyOperator nonReentrant {\\n        require(status == Status.FUNDING, \\\"Funding must be open\\\");\\n\\n        // Transfer all funds to the operator.\\n        uint256 amountRaised = balanceOf(address(this));\\n        transfer(operator, amountRaised);\\n\\n        // Mint the operator a percent of the total supply.\\n        uint256 tokensForOperator =\\n            totalSupply().div(100).mul(operatorEquityPercent);\\n        _mint(operator, tokensForOperator);\\n\\n        // Close funding status, move to tradable.\\n        status = Status.TRADING;\\n\\n        emit FundingClosed(amountRaised, tokensForOperator);\\n    }\\n\\n    /**\\n     * @notice Accepts the given bid on the associated market and unwraps WETH.\\n     * @dev Emits the BidAccepted event.\\n     */\\n    function acceptNFTBid(IMarket.Bid calldata bid)\\n        external\\n        onlyOperator\\n        nonReentrant\\n    {\\n        require(status == Status.TRADING, \\\"Trading must be open\\\");\\n\\n        // This will work if the publication is the owner of the token\\n        IMedia(mediaAddress).acceptBid(0, bid);\\n        // Accepting the bid will transfer WETH into this contract.\\n        IWETH(WETH).withdraw(bid.amount);\\n\\n        emit BidAccepted(bid.amount);\\n    }\\n\\n    // Allows the operator to update metadata associated with the NFT.\\n    function updateTokenURI(string calldata tokenURI)\\n        external\\n        onlyOperator\\n        nonReentrant\\n    {\\n        IMedia(mediaAddress).updateTokenURI(0, tokenURI);\\n    }\\n\\n    // Allows the operator to update metadata associated with the NFT.\\n    function updateTokenMetadataURI(string calldata metadataURI)\\n        external\\n        onlyOperator\\n        nonReentrant\\n    {\\n        IMedia(mediaAddress).updateTokenMetadataURI(0, metadataURI);\\n    }\\n\\n    /**\\n     * @notice Prevents ETH from being sent directly to the contract, except\\n     *  from the WETH contract, during acceptBid.\\n     */\\n    receive() external payable {\\n        assert(msg.sender == WETH);\\n    }\\n}\\n```\\n\\nPlease comment with feedback on this thread:\\n\\n[](https://twitter.com/viamirror/status/1351989735191937027)\",\"timestamp\":1611348757,\"title\":\"Crowdfunding Writing with NFTs\",\"publication\":\"dev\"},\"digest\":\"KvLo4zDmg41yANjy3n-ZAu5JqqlrJs1OJCGUhKOcPGI\",\"authorship\":{\"contributor\":\"0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Y145rmpdL8brLnJOGKaRCFROF9SSGs9SiHJpOtj_X-Y\\\",\\\"y\\\":\\\"RiM0H9oyhhkqY4pTiosfP6eyxf6FR_NSSgBHj4R50vw\\\"}\",\"signature\":\"OxNEIBuQxH7aCldQSvQjpard4WsCwK2y7V7x7d319Bqq7FdlEWg6PVs4T_jZAt-wjNy24sHiy6dXt5gqHfPFEg\",\"signingKeySignature\":\"0xff61d93797c7ac900a8b9d8a86d64e62b629aac5e9ecf762e35ffbd602b24aab53c973eb77acaa229ad659c28ed46c80a7bc081e5ca475e004b81ed8c10c4b071c\",\"signingKeyMessage\":\"I authorize the publication of articles on dev.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"Y145rmpdL8brLnJOGKaRCFROF9SSGs9SiHJpOtj_X-Y\\\",\\\"y\\\":\\\"RiM0H9oyhhkqY4pTiosfP6eyxf6FR_NSSgBHj4R50vw\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"version\":\"12-21-2020\",\"originalDigest\":\"llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ\"}"