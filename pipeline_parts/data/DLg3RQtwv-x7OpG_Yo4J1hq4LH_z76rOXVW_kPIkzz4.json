"{\"content\":{\"body\":\"## 导读\\n\\n我们可以简单的将区块链公链理解为一套分布式存储的账本，每个节点在各自本地存储一份账本。这些节点为了保障全网的账本一致性，就需要进行共识。共识的过程需要网络的不同节点之间交换信息，所以导致执行记账和计算的效率不高。\\n\\n对于软件系统而言，描述其系统吞吐量一般用 TPS（ 每秒事务处理量 TransactionPerSecond ） 性能指标。具体来说，比特币系统每秒仅支持 7 笔交易，以太坊也仅支持每秒 15 笔左右的交易。这样的 TPS 显然无法满足大型商业应用的需求。\\n\\n在这种历史背景下，为区块链系统扩容被提上了日程。目前业内主要的扩容方案有两类 ：\\n\\n* 链上扩容 / Layer1 一层扩容\\n\\n  即对区块链本身进行改造，从而直接提升链上交易处理速度 ：直接增加链上区块内可以包含的交易数量（ 如隔离见证 、扩块）、直接改变区块链的链体结构（ 如分片 Sharding 、有向无环图 DAG ）、直接改变区块链的共识机制（ 如 EOS 的 DPoS 、Solana 的 PoH ）等方案。\\n* 链下扩容 / Layer2 二层扩容（ 以太坊实现扩容时将源代码文件夹命名为 Layer2 ）\\n\\n  即将链上的相当一部分工作量转移到链下来完成，从而间接提升链上交易处理速度 ：State Channel（ 状态通道 ）、Plasma 、Rollup。具体如下图所示 ：\\n\\n![](https://images.mirror-media.xyz/publication-images/VVj7Lb3K0968p2Px268ew.png?height=654&width=778)\\n\\nif(DAO) 希望通过本篇内容解释上图中 “ zkRollup ” 分支里基于 zk-SNARK 实现 Layer2 方案的基本工作原理。\\n\\nzk是零知识证明的缩写（ZKP ：Zero-Knowledge Proof），Rollup 字面意思是 “ 一卷 ” ，通俗讲就是将链下一大堆转账交易记录压缩为一个批量，然后将这个批量交易打包、压缩后上链验证并存储。\\n\\n> 上图中的 Groth 16 、PLONK 都属于 zk-SNARKs 协议族，他们的数学理论基础都是基于椭圆曲线的 ；STARK 是零知识证明的另外一种实现算法，数学理论基础是离散函数并且无需可信设置。\\n>\\n> 关于 ZKP 和 zk-SNARK 协议的演进过程和底层原理，可以详见 if(DAO) 之前的文章 ：\\n\\n[https://mirror.xyz/0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417/X3qSOjObTknXQ_iGhDBFYETibD0TVW0twz5QDIthjGI](https://mirror.xyz/0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417/X3qSOjObTknXQ_iGhDBFYETibD0TVW0twz5QDIthjGI)\\n\\n## Ethereum 的 “ 状态 ” 和 “ 历史 ”\\n\\n我们首先了解一下 Ethereum 公链的基本结构 ：\\n\\n![](https://images.mirror-media.xyz/publication-images/IRylSqFFFjyWDhdGZ2N3N.png?height=777&width=1919)\\n\\n1、Ethereum 的状态\\n\\n指的是 Ethereum 全量账本当前的样子 ：由所有以太坊账户构成的一棵**状态树**（ Merkle Patricia Tree 即上图中ABCD向上收敛形成的树 ），每个账户（树的叶子）的最主要结构是 ：\\n\\n（1）key = 账户的名字（状态树的叶子A、B、C、D）\\n\\n（2）balance = 每个账户的余额（10、20、30、0）\\n\\n2、Ethereum 的历史\\n\\n由当前区块包含所有交易构成的一颗**交易树**（上图中未画出交易树），每笔交易最主要结构是：\\n\\n（1）to = 交易将要发送到的账户地址（在 Block XXX 时，to = D）\\n\\n（2）value = 交易的转账金额（在 Block XXX+1 时，value = 10）\\n\\n（3）data = 交易输入的变量（比如将A和B的余额分别扣除10%的佣金给E）\\n\\n3、交易驱动状态的变化\\n\\n（1）根据交易的转账金额（value）计算目标账户（to）的新余额（balance），比如C给某人转账10 ETH后更新C的新余额为20 ETH。\\n\\n（2）如果交易是发送给一个智能合约，则将交易的 data 作为参数传递给目标账户（to）的智能合约，运行智能合约的业务逻辑，在运行中可能会修改任意账户的状态从而生成新的状态（比如E的账户余额更新为 = 原余额 + 10\\\\*10% + 20\\\\*10%）。\\n\\n（3）构造新的叶子存放新状态（D：20 / C：20），更新状态树，最终计算形成新的stateRoot并储存至新区块的 Header 中。\\n\\n4、不堪重负的 Layer1\\n\\n从上面的过程不难看出，当交易量增加时，节点的计算工作量（交易驱动状态的变化）也会增加。同时以太坊每个区块的大小不是无限大的，这就导致每个区块可以包含的交易数量是有限的。所以我们在平时使用以太坊网络时会经常感觉到网络拥堵、交易处理缓慢。\\n\\n## zkRollup 的基本原理\\n\\nzkRollup 的本质是将链上的用户状态（比如账户余额 、nonce）压缩存储在一棵 Merkle 树中，并将用户状态的变更转移到链下来，同时通过 zkSNARK 的证明来保证该链下用户状态变更过程的正确性。在链上直接处理用户状态的变更成本是比较高的，但是仅仅利用链上的智能合约来验证一个零知识证明的 PROOF 是否正确，成本是相对低很多的。另外必要的转账信息也会被和证明一起提交到合约，方便用户查账。\",\"timestamp\":1640971518,\"title\":\"zkRollup 原理\"},\"digest\":\"lm9ZxU7sBd02BJlsh8WKhwhvuke8bJU60yizELTIMEA\",\"authorship\":{\"contributor\":\"0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"signature\":\"z7d9nhDvxGMYHRIE7nkSScvlNKeQKmRI8XVLnu4agrgXYXLjbjeExS5V2d6YE5QfL42DcXOL1viTMMOOhexmog\",\"signingKeySignature\":\"0x37986d551641971cdf6ada5c4365b09fa1f1c9565275e4a2e69a6dfcc1435d3a3e15e6f1cbc1bd770fba430d41423a94c25d58507bcf912632c134b280faffdc1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"I7kuEKu4gaUkiU-mses8qxcUkzMKwdzLR7mlexEfCpw\"}"