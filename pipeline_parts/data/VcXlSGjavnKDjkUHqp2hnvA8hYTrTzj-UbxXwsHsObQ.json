"{\"content\":{\"body\":\"Two weeks ago we asked our community to help bring open source NFT reserve auction functionality to the world. Today, we’re auctioning off that code (with the code!) as a 1/1 NFT.\\n\\n[Token #1522](auction://0xabEFBc9fD2F806065b4f3C237d4b59D9A97Bcac7?network=mainnet&tokenId=1522)\\n\\nReserve Auctions are a mechanism for selling NFTs widely credited with creating more value for artists, but they have typically been limited to proprietary marketplaces. We wanted to bring a robust and completely permissionless version to anyone who wants to use it.\\n\\nBy open-sourcing this implementation of a reserve auction, we hope to directly empower creators by giving them the tools they need to freely sell their work, on their terms.\\n\\nIn just over an hour we raised 7 ETH from 40 backers, who in turn received $BOUNTY tokens representing their patronage of this community-focused initiative.\\n\\nWhat made this approach to crowdfunding even more unique is that the resulting smart contract code would be made open source, minted as an NFT and then auctioned off, with the value of the NFT flowing back to $BOUNTY holders. See all the details of $BOUNTY in the original crowdfund post.\\n\\n[](https://mint.mirror.xyz/mDws2xGmJCq55ehGDdcv8tGDCpSd_c_CfeqhexiKSqU)\\n\\nToday we’re excited to announce that **$BOUNTY: The First Tokenized, Crowdfunded Smart Contract** is officially minted and up for auction.\\n\\nImportantly, this NFT is being auctioned using the auction code embedded in the NFT itself. Cue inception memes\\n\\nAt the end of this post is the initial commit of the smart contract code. Since this post is minted as an NFT, this code is immortalized as part of it. Owning this NFT means owning a 1/1 collectible representing the initial commit of the open-source implementation of reserve auctions, which will live on Mint Fund’s [GitHub repo](https://github.com/mintfund/reserve-auction/blob/main/contracts/ReserveAuctionV3.sol).\\n\\n## **The Process**\\n\\nInitially Mint Fund created a bounty via a Mirror crowdfund to fund the development of an open source version of reserve auction smart contract, which was [fulfilled](https://github.com/okwme/core/blob/master/contracts/ReserveAuction.sol) by Solidity developer [Billy Rennekamp](https://twitter.com/billyrennekamp).\\n\\nThe Mirror team took this code and improved on it until it was production ready. The [final version](https://github.com/mintfund/reserve-auction/blob/main/contracts/ReserveAuctionV3.sol) (included at the bottom of this post) was used to auction off two NFTs on April 1st, 2021 for a combined value of 26.1 ETH.\\n\\nIn a testament to open source collaboration and smart contract composability, this auction code builds on top of the open Zora NFT protocol and honors the creator share of zNFTs.\\n\\nFurthermore, it also supports specifying a curator fee for facilitating the auction. This enables organizations like Mint Fund or other galleries a potential business model to sustain their operations .\\n\\n*We’d like to credit projects that have pioneered and improved on the reserve auction mechanism and experience, such as SuperRare and Foundation.*\\n\\n## Next Steps\\n\\nThe [Zora](https://zora.co/) team is working on adding functionality to the reserve auction code that more fully utilizes the power of the Zora Protocol. Zora's update will support bidding in any ERC20 token, and honoring the sell-on-share fee that users will know from the Zora interface.\\n\\n## **What $BOUNTY holders get.**\\n\\nFollowing the initial crowdfund, $BOUNTY tokens were distributed to all backers. 25% of $BOUNTY tokens were retained by MintFund, with 5% allocated to the developer implementing the bounty. The remaining 70% were distributed to the $BOUNTY crowdfund backers.\\n\\n$BOUNTY represents the shared value created through the crowdfunding, development and auction of the NFT. If the $BOUNTY NFT sells, the proceeds will go to the crowdfund and thereby the $BOUNTY backers. Holding $BOUNTY tokens also grant one access to a private channel on the Mint Fund discord only accessible by those holding at least 15 $BOUNTY.\\n\\n## The future of public goods funding\\n\\nAs far as we know, this has been the first experiment to combine crypto-native crowdfunding with public works minted as an NFT. Recently, Vitalik [wrote](https://vitalik.ca/general/2021/03/23/legitimacy.html) about the potential to use token incentives, NFTs, and decentralized governance to fund public goods like scientific research, local journalism, and poverty relief.\\n\\nWe believe this new model has the opportunity to create win-win scenarios for all parties involved: backers, creators, developers, collectors, and end-consumers of these funded projects.\\n\\nMintFund hopes to see others experiment with this model and push the boundaries of how creative work is financed, produced, and owned using the internet and crypto-native tools.\\n\\n## **The Code**\\n\\n```solidity\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n// OpenZeppelin library for performing math operations without overflows.\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n// OpenZeppelin security library for preventing reentrancy attacks.\\nimport {\\n    ReentrancyGuard\\n} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n// For interacting with Zora's Market contract.\\nimport {IMarket} from \\\"./interfaces/IMarket.sol\\\";\\n// For checking `supportsInterface`.\\nimport {IERC165} from \\\"@openzeppelin/contracts/introspection/IERC165.sol\\\";\\n// For interacting with NFT tokens.\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ncontract IMediaModified {\\n    mapping(uint256 => address) public tokenCreators;\\n    address public marketContract;\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ncontract ReserveAuctionV3 is ReentrancyGuard {\\n    // Use OpenZeppelin's SafeMath library to prevent overflows.\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    // The minimum amount of time left in an auction after a new bid is created; 15 min.\\n    uint16 public constant TIME_BUFFER = 900;\\n    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\\n    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\\n    // Interface constant for ERC721, to check values in constructor.\\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n    // Allows external read `getVersion()` to return a version for the auction.\\n    uint256 private constant RESERVE_AUCTION_VERSION = 1;\\n\\n    // ============ Immutable Storage ============\\n\\n    // The address of the ERC721 contract for tokens auctioned via this contract.\\n    address public immutable nftContract;\\n    // The address of the WETH contract, so that ETH can be transferred via\\n    // WETH if native ETH transfers fail.\\n    address public immutable wethAddress;\\n    // The address that initially is able to recover assets.\\n    address public immutable adminRecoveryAddress;\\n\\n    // ============ Mutable Storage ============\\n\\n    /**\\n     * To start, there will be an admin account that can recover funds\\n     * if anything goes wrong. Later, this public flag will be irrevocably\\n     * set to false, removing any admin privileges forever.\\n     *\\n     * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\\n     */\\n    bool private _adminRecoveryEnabled;\\n    /**\\n     * The account `adminRecoveryAddress` can also pause the contracts\\n     * while _adminRecoveryEnabled is enabled. This prevents people from using\\n     * the contract if there is a known problem with it.\\n     */\\n    bool private _paused;\\n\\n    // A mapping of all of the auctions currently running.\\n    mapping(uint256 => Auction) public auctions;\\n\\n    // ============ Structs ============\\n\\n    struct Auction {\\n        // The value of the current highest bid.\\n        uint256 amount;\\n        // The amount of time that the auction should run for,\\n        // after the first bid was made.\\n        uint256 duration;\\n        // The time of the first bid.\\n        uint256 firstBidTime;\\n        // The minimum price of the first bid.\\n        uint256 reservePrice;\\n        uint8 curatorFeePercent;\\n        // The address of the auction's curator. The curator\\n        // can cancel the auction if it hasn't had a bid yet.\\n        address curator;\\n        // The address of the current highest bid.\\n        address payable bidder;\\n        // The address that should receive funds once the NFT is sold.\\n        address payable fundsRecipient;\\n    }\\n\\n    // ============ Events ============\\n\\n    // All of the details of a new auction,\\n    // with an index created for the tokenId.\\n    event AuctionCreated(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address fundsRecipient\\n    );\\n\\n    // All of the details of a new bid,\\n    // with an index created for the tokenId.\\n    event AuctionBid(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address sender,\\n        uint256 value\\n    );\\n\\n    // All of the details of an auction's cancelation,\\n    // with an index created for the tokenId.\\n    event AuctionCanceled(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator\\n    );\\n\\n    // All of the details of an auction's close,\\n    // with an index created for the tokenId.\\n    event AuctionEnded(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator,\\n        address winner,\\n        uint256 amount,\\n        address nftCreator,\\n        address payable fundsRecipient\\n    );\\n\\n    // When the curator recevies fees, emit the details including the amount,\\n    // with an index created for the tokenId.\\n    event CuratorFeePercentTransfer(\\n        uint256 indexed tokenId,\\n        address curator,\\n        uint256 amount\\n    );\\n\\n    // Emitted in the case that the contract is paused.\\n    event Paused(address account);\\n    // Emitted when the contract is unpaused.\\n    event Unpaused(address account);\\n\\n    // ============ Modifiers ============\\n\\n    // Reverts if the sender is not admin, or admin\\n    // functionality has been turned off.\\n    modifier onlyAdminRecovery() {\\n        require(\\n            // The sender must be the admin address, and\\n            // adminRecovery must be set to true.\\n            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\\n            \\\"Caller does not have admin privileges\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the sender is not the auction's curator.\\n    modifier onlyCurator(uint256 tokenId) {\\n        require(\\n            auctions[tokenId].curator == msg.sender,\\n            \\\"Can only be called by auction curator\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the contract is paused.\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction does not exist.\\n    modifier auctionExists(uint256 tokenId) {\\n        // The auction exists if the curator is not null.\\n        require(!auctionCuratorIsNull(tokenId), \\\"Auction doesn't exist\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction exists.\\n    modifier auctionNonExistant(uint256 tokenId) {\\n        // The auction does not exist if the curator is null.\\n        require(auctionCuratorIsNull(tokenId), \\\"Auction already exists\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction is expired.\\n    modifier auctionNotExpired(uint256 tokenId) {\\n        require(\\n            // Auction is not expired if there's never been a bid, or if the\\n            // current time is less than the time at which the auction ends.\\n            auctions[tokenId].firstBidTime == 0 ||\\n                block.timestamp < auctionEnds(tokenId),\\n            \\\"Auction expired\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the auction is not complete.\\n    // Auction is complete if there was a bid, and the time has run out.\\n    modifier auctionComplete(uint256 tokenId) {\\n        require(\\n            // Auction is complete if there has been a bid, and the current time\\n            // is greater than the auction's end time.\\n            auctions[tokenId].firstBidTime > 0 &&\\n                block.timestamp >= auctionEnds(tokenId),\\n            \\\"Auction hasn't completed\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(\\n        address nftContract_,\\n        address wethAddress_,\\n        address adminRecoveryAddress_\\n    ) public {\\n        require(\\n            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\\n            \\\"Contract at nftContract_ address does not support NFT interface\\\"\\n        );\\n        // Initialize immutable memory.\\n        nftContract = nftContract_;\\n        wethAddress = wethAddress_;\\n        adminRecoveryAddress = adminRecoveryAddress_;\\n        // Initialize mutable memory.\\n        _paused = false;\\n        _adminRecoveryEnabled = true;\\n    }\\n\\n    // ============ Create Auction ============\\n\\n    function createAuction(\\n        uint256 tokenId,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address payable fundsRecipient\\n    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\\n        // Check basic input requirements are reasonable.\\n        require(curator != address(0));\\n        require(fundsRecipient != address(0));\\n        require(curatorFeePercent < 100, \\\"Curator fee should be < 100\\\");\\n        // Initialize the auction details, including null values.\\n        auctions[tokenId] = Auction({\\n            duration: duration,\\n            reservePrice: reservePrice,\\n            curatorFeePercent: curatorFeePercent,\\n            curator: curator,\\n            fundsRecipient: fundsRecipient,\\n            amount: 0,\\n            firstBidTime: 0,\\n            bidder: address(0)\\n        });\\n        // Transfer the NFT into this auction contract, from whoever owns it.\\n        IERC721(nftContract).transferFrom(\\n            IERC721(nftContract).ownerOf(tokenId),\\n            address(this),\\n            tokenId\\n        );\\n        // Emit an event describing the new auction.\\n        emit AuctionCreated(\\n            tokenId,\\n            nftContract,\\n            duration,\\n            reservePrice,\\n            curatorFeePercent,\\n            curator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    // ============ Create Bid ============\\n\\n    function createBid(uint256 tokenId, uint256 amount)\\n        externalpayablenonReentrant\\n        whenNotPaused\\n        auctionExists(tokenId)\\n        auctionNotExpired(tokenId)\\n    {\\n        // Validate that the user's expected bid value matches the ETH deposit.\\n        require(amount == msg.value, \\\"Amount doesn't equal msg.value\\\");\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        // Check if the current bid amount is 0.\\n        if (auctions[tokenId].amount == 0) {\\n            // If so, it is the first bid.\\n            auctions[tokenId].firstBidTime = block.timestamp;\\n            // We only need to check if the bid matches reserve bid for the first bid,\\n            // since future checks will need to be higher than any previous bid.\\n            require(\\n                amount >= auctions[tokenId].reservePrice,\\n                \\\"Must bid reservePrice or more\\\"\\n            );\\n        } else {\\n            // Check that the new bid is sufficiently higher than the previous bid, by\\n            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\\n            require(\\n                amount >=\\n                    auctions[tokenId].amount.add(\\n                        // Add 10% of the current bid to the current bid.\\n                        auctions[tokenId]\\n                            .amount\\n                            .mul(MIN_BID_INCREMENT_PERCENT)\\n                            .div(100)\\n                    ),\\n                \\\"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\\\"\\n            );\\n\\n            // Refund the previous bidder.\\n            transferETHOrWETH(\\n                auctions[tokenId].bidder,\\n                auctions[tokenId].amount\\n            );\\n        }\\n        // Update the current auction.\\n        auctions[tokenId].amount = amount;\\n        auctions[tokenId].bidder = msg.sender;\\n        // Compare the auction's end time with the current time plus the 15 minute extension,\\n        // to see whether we're near the auctions end and should extend the auction.\\n        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\\n            // We add onto the duration whenever time increment is required, so\\n            // that the auctionEnds at the current time plus the buffer.\\n            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\\n                auctionEnds(tokenId)\\n            );\\n        }\\n        // Emit the event that a bid has been made.\\n        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\\n    }\\n\\n    // ============ End Auction ============\\n\\n    function endAuction(uint256 tokenId)\\n        externalnonReentrant\\n        whenNotPaused\\n        auctionComplete(tokenId)\\n    {\\n        // Store relevant auction data in memory for the life of this function.\\n        address winner = auctions[tokenId].bidder;\\n        uint256 amount = auctions[tokenId].amount;\\n        address curator = auctions[tokenId].curator;\\n        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\\n        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\\n        // Remove all auction data for this token from storage.\\n        delete auctions[tokenId];\\n        // We don't use safeTransferFrom, to prevent reverts at this point,\\n        // which would break the auction.\\n        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\\n        // First handle the curator's fee.\\n        if (curatorFeePercent > 0) {\\n            // Determine the curator amount, which is some percent of the total.\\n            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\\n            // Send it to the curator.\\n            transferETHOrWETH(curator, curatorAmount);\\n            // Subtract the curator amount from the total funds available\\n            // to send to the funds recipient and original NFT creator.\\n            amount = amount.sub(curatorAmount);\\n            // Emit the details of the transfer as an event.\\n            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\\n        }\\n        // Get the address of the original creator, so that we can split shares\\n        // if appropriate.\\n        address payable nftCreator =\\n            payable(\\n                address(IMediaModified(nftContract).tokenCreators(tokenId))\\n            );\\n        // If the creator and the recipient of the funds are the same\\n        // (and we expect this to be common), we can just do one transaction.\\n        if (nftCreator == fundsRecipient) {\\n            transferETHOrWETH(nftCreator, amount);\\n        } else {\\n            // Otherwise, we should determine the percent that goes to the creator.\\n            // Collect share data from Zora.\\n            uint256 creatorAmount =\\n                // Call the splitShare function on the market contract, which\\n                // takes in a Decimal and an amount.\\n                IMarket(IMediaModified(nftContract).marketContract())\\n                    .splitShare(\\n                    // Fetch the decimal from the BidShares data on the market.\\n                    IMarket(IMediaModified(nftContract).marketContract())\\n                        .bidSharesForToken(tokenId)\\n                        .creator,\\n                    // Specify the amount.\\n                    amount\\n                );\\n            // Send the creator's share to the creator.\\n            transferETHOrWETH(nftCreator, creatorAmount);\\n            // Send the remainder of the amount to the funds recipient.\\n            transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount));\\n        }\\n        // Emit an event describing the end of the auction.\\n        emit AuctionEnded(\\n            tokenId,\\n            nftContract,\\n            curator,\\n            winner,\\n            amount,\\n            nftCreator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    // ============ Cancel Auction ============\\n\\n    function cancelAuction(uint256 tokenId)\\n        externalnonReentrant\\n        auctionExists(tokenId)\\n        onlyCurator(tokenId)\\n    {\\n        // Check that there hasn't already been a bid for this NFT.\\n        require(\\n            uint256(auctions[tokenId].firstBidTime) == 0,\\n            \\\"Auction already started\\\"\\n        );\\n        // Pull the creator address before removing the auction.\\n        address curator = auctions[tokenId].curator;\\n        // Remove all data about the auction.\\n        delete auctions[tokenId];\\n        // Transfer the NFT back to the curator.\\n        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\\n        // Emit an event describing that the auction has been canceled.\\n        emit AuctionCanceled(tokenId, nftContract, curator);\\n    }\\n\\n    // ============ Admin Functions ============\\n\\n    // Irrevocably turns off admin recovery.\\n    function turnOffAdminRecovery() external onlyAdminRecovery {\\n        _adminRecoveryEnabled = false;\\n    }\\n\\n    function pauseContract() external onlyAdminRecovery {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function unpauseContract() external onlyAdminRecovery {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    // Allows the admin to transfer any NFT from this contract\\n    // to the recovery address.\\n    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\\n        IERC721(nftContract).transferFrom(\\n            // From the auction contract.\\n            address(this),\\n            // To the recovery account.\\n            adminRecoveryAddress,\\n            // For the specified token.\\n            tokenId\\n        );\\n    }\\n\\n    // Allows the admin to transfer any ETH from this contract to the recovery address.\\n    function recoverETH(uint256 amount)\\n        externalonlyAdminRecovery\\n        returns (bool success)\\n    {\\n        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\\n        success = attemptETHTransfer(adminRecoveryAddress, amount);\\n    }\\n\\n    // ============ Miscellaneous Public and External ============\\n\\n    // Returns true if the contract is paused.\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    // Returns true if admin recovery is enabled.\\n    function adminRecoveryEnabled() public view returns (bool) {\\n        return _adminRecoveryEnabled;\\n    }\\n\\n    // Returns the version of the deployed contract.\\n    function getVersion() external pure returns (uint256 version) {\\n        version = RESERVE_AUCTION_VERSION;\\n    }\\n\\n    // ============ Private Functions ============\\n\\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\\n    function transferETHOrWETH(address to, uint256 value) private {\\n        // Try to transfer ETH to the given recipient.\\n        if (!attemptETHTransfer(to, value)) {\\n            // If the transfer fails, wrap and send as WETH, so that\\n            // the auction is not impeded and the recipient still\\n            // can claim ETH via the WETH contract (similar to escrow).\\n            IWETH(wethAddress).deposit{value: value}();\\n            IWETH(wethAddress).transfer(to, value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\\n    // it fails. For example, a contract can block ETH transfer, or might use\\n    // an excessive amount of gas, thereby griefing a new bidder.\\n    // We should limit the gas used in transfers, and handle failure cases.\\n    function attemptETHTransfer(address to, uint256 value)\\n        privatereturns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = to.call{value: value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n\\n    // Returns true if the auction's curator is set to the null address.\\n    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\\n        // The auction does not exist if the curator is the null address,\\n        // since the NFT would not have been transferred in `createAuction`.\\n        return auctions[tokenId].curator == address(0);\\n    }\\n\\n    // Returns the timestamp at which an auction will finish.\\n    function auctionEnds(uint256 tokenId) private view returns (uint256) {\\n        // Derived by adding the auction's duration to the time of the first bid.\\n        // NOTE: duration can be extended conditionally after each new bid is added.\\n        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\\n    }\\n}\\n```\",\"timestamp\":1617989624,\"title\":\"The Auction: $BOUNTY Permissionless Reserve Auctions for NFTs\",\"publication\":\"mint\"},\"digest\":\"H8Wm5qbEY0u06iBggOojvxUgtq0brMdEn5MmxBAEmlU\",\"authorship\":{\"contributor\":\"0x662d5d79849113A5403Af776210307a7c82a5267\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"LCvJfcoCpkeUvAuPVc3C8X4b8-NjQjmvQBRJ_W-ytUk\\\",\\\"y\\\":\\\"bdxpLpF9kAsZ1NxULeDNJlpoKiGYoqF7rYZ-UmRpY9s\\\"}\",\"signature\":\"UEnTIg8J9HTasZIbHCl8rSzn3EQVU70SVNhsIIHBWKMr6snnufI5n5MOSPjaE0KSDJCSZQQIso6ztJLj-yOdWw\",\"signingKeySignature\":\"0x7a2771c8166f87f9c23e9860f659f9e1d3cf18c421b4f0a6bded9a916823361b0c22c448e33b7332b06b64bf3916ebbe3e2fe952504be44145dd0fe67875bdbf1c\",\"signingKeyMessage\":\"I authorize the publication of articles on mint.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"LCvJfcoCpkeUvAuPVc3C8X4b8-NjQjmvQBRJ_W-ytUk\\\",\\\"y\\\":\\\"bdxpLpF9kAsZ1NxULeDNJlpoKiGYoqF7rYZ-UmRpY9s\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"6tD-QHgfCWvfKTjZgMoDd-8Gwdx3oibYuaGvg715Xco\"}"