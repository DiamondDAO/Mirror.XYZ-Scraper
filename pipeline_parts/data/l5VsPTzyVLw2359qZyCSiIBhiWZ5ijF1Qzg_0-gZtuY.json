"{\"content\":{\"body\":\"**By yush_g and nulven, with special kudos to [0xPARC](https://0xparc.org/), gubsheep, Austin Griffith, Veronica Zheng, Kobi Gurkan, and Wei Jie Koh for helping + reviewing!**   \\n\\nArticle estimated reading time: 1-2 hours (also can watch a simplified \\\\~30 minute recording on [YouTube](https://www.youtube.com/watch?v=J3UlqJk3Kl0&list=PLn8ovY5k8alB3C8cIZn6-NxzAGKw-qreC&index=8)). [Let me know](https://twitter.com/yush_g/) if it took you less/more time :) \\n\\n## Motivation: Why ZK\\n\\nZero knowledge proofs are a [powerful cryptographic primitive](https://twitter.com/VitalikButerin/status/1433228277263462401), often used for proving pre-images of hashes (see [zkga.me](http://zkga.me)) or anonymizing transactions (see [zcash](http://z.cash)). We envision (and will interactively lead you through) an on-chain application that allows anyone to feel safe expressing their truth. Imagine an application where they could anonymously post on behalf of a verified group, without revealing who they are -- whether journalists are reporting without censorship, students of a university posting anonymous quips, congress members voting anonymously, or employees of a company are reporting harassment. This type of social media is [ripe for crypto](https://youtu.be/oLsb7clrXMQ?t=1141) innovation, and this is a great start!\\n\\nFor this to happen in a credibly neutral way (see [Vitalik’s definition](https://nakamoto.com/credible-neutrality/)), crypto-native code is a natural method by which all the code can be public and a member can feel completely safe in their anonymity. ZK-snarks (and starks, and newer gadgets) allow zero knowledge proofs that prove anonymity, to verify in solidity on chain. For this construction, we need to engineer two functions: to prove group membership on chain, and to post on behalf of that group. We’ll give a naive construction, and then attack each one’s security individually -- showing why ZK is needed, and how one could properly execute such a scheme. The hope of this post is to inspire you all to engineer your own ZK protocols, by thinking like a true snarkoor.\\n\\n# The First Construction\\n\\nLet’s assume there is an off-chain group we want to anonymously replicate on chain. Companies or groups can share a password between them, but have no public connection from that to their identities or wallets. We present a simple scheme, the most naive such implementation that minimally implements both steps on chain without any anonymity or security.\\n\\n**Join**: A smart contract stores the hash(hash(password)). You send the hash(password), with a public key. That public key is added to an allowlist for message sending.\\n**Send**: In future, can send a signed message with any allowlisted public key.\\n\\nI recommend pausing for a moment and trying to think of all the security properties this breaks, before reading the three answers. In general, this will be a good way to read the post and fully convince yourself of the need for each building block of machinery.\\n\\n.\\n\\n.\\n\\n.\\n\\nAnyone can frontrun or resend a previously sent hash(password) with their own public key, and join a group.\\n\\nThis reveals the public key of the sender: when joining the group, when sending each transaction, and when verifying the signature on the message! \\n\\nThe first few messages sent have a small anonymity set on chain, even if the whole group is large.\\n\\n.\\n\\n.\\n\\n.\\n\\nTraditionally in crypto, revealing a public key has been desirable -- however, here we prioritize privacy and want anonymity for more general functions than just sending money.\\n\\nTo make explicit our goals, we define these properties:\\n\\n**Actions**: Users can create groups, join them, and post from them.\\n\\n**Security properties**: Groups are permissioned by password, users anonymously join, messages cannot be traced back to a user, and messages cannot be forged.\\n\\n### The Plan to Prove Group Membership On Chain\\n\\nHow do you properly show that your private/public key belongs to a group? Let’s try a natural extension of our original idea, each time attempting to fix one of the issues. At the end, we will have the needed complexity (fans of Gall’s law will recognize this, where we build the minimally complex system from simpler systems that don’t fully work).\\n\\nLet’s start with the simple contract idea, and discuss how to verify the password to allow users to join an allowlist.\\n\\n# Password security\\n\\n**Password idea 1:** Recall our naive construction, a smart contract where you send the hash(password) and your public key, to be added to an allowlist on-chain.\\n\\nCheck if you remember the problems with only this part before moving on! \\n\\n.\\n\\n.\\n\\n.\\n\\nYou prove you have the password and are part of the group, but you lose the uniqueness (anyone can send the hash(password)) and the privacy. Oof. \\n\\n.\\n\\n.\\n\\n.\\n\\nLet’s focus on the reusable password problem first, then we can handle the public keys. If the problem is reuse, maybe we can solve it with many one-time-use passwords?\\n\\n**Password Idea 2**: Additionally send a nonce -- in this case, a unique password per user. As before, send hash(password). Smart contract verifies it matches anyone in the preset list of hash(hash(password))s, then adds your public key to the allowlist as before.\\n\\nThis is almost exactly what we want, and we made our implementation with this, but there are a few subtle improvements still.\\n\\n.\\n\\n.\\n\\n. \\n\\nThis adds an inherent max group size (because there is a finite number of passwords), which in some cases may be the desired design. When there are few allowlisted users, users who send a second message can be associated with their past messages (recall that messages are sent with allowlisted public keys only)! This can be desirable (and is why we implement our [actual GitHub repo](https://github.com/nulven/zk-message-board) off of this), but in case we want complete dissociation from the start, let’s search a little more. \\n\\n.\\n\\n.\\n\\n.\\n\\nAn astute blockchain enthusiast may have noticed this unique nonce can still be frontrun. The standard commit reveal with this scheme avoids frontrunning -- this is the same scheme ENS uses. Basically, you publish the hash of this transaction x blocks in advance, and then their actual message will only go through if there is a commit to it already at least x blocks beforehand. As long as the transaction doesn’t linger in the mempool too long, this will mean attackers have to wait for x blocks. \\n\\nTurns out if you couple the join and post steps cleverly, we don’t actually need this! We’ll elaborate more on that solution later.\\n\\nAssuming this is resolved as mentioned, let’s address the multiple password issue first.\\n\\n**Password idea 3**: Back to one group password. Each user concatenates a nonce (message number, corresponding to the number of messages sent by anyone in that group prior), and proves it is part of a merkle tree of say 1M hash(password | nonce)s (by sending \\\\~13 hashes in total), which the smart contract verifies with the root. We will redo this for each message sent. \\\\[Note that | means concatenation\\\\]\\n\\nNote this merkle tree limits the number of total messages, but since merkle tree widths vary exponentially with heights, we can easily add a few more 0s to the number of possible nonces. There’s a particularly devious problem with this solution, relating to the merkle proofs.\\n\\n.\\n\\n.\\n\\n.\\n\\nIf the nonces are consecutive, you might give away the next nonce’s hash in the process of proving the previous message! This is because proving a route up a merkle tree involves showing you know the hash of all the neighbors at each level. Users need to prove they knew the pre-image of the hash... \\\\*\\\\* (detail addressed at bottom) \\n\\n.\\n\\n.\\n\\n.\\n\\nFolks familiar with ZK will realize the problem of proving a pre-image is canonical, and we try exactly that.\\n\\n**Password idea 4**: One group password. Each user concatenates a nonce (message number), and a merkle path of a merkle tree of say 1M hash(password | nonce)s (by sending \\\\~20 hashes in total). They also send a zk proof that they know the pre-image of the hash.\\n\\nThis works! The group on creation starts with the merkle root of the hash(password | nonce)s.\\n\\nWe can do a bit better though (probably not worth implementing, but an interesting theoretical exercise) -- this has one point of failure: the entire system depending on one shared password that might get leaked. Can we have a system of individual passwords that allows reuse, without replay attacks?\\n\\n**Password idea 5:** Individual passwords. The contract has all the merkle roots of each hash(password | nonce) for each password and nonce. We send a message nonce based on the number of messages sent from each user so far, and a zk-proof that we know the pre-image, and the merkle root of a claimed merkle path of (password | nonce) is one of the allowed merkle roots in the contract.\\n\\nOne might ask what such a zk proof would look like. Let’s assume there are 26 allowlisted merkle root a...z as public inputs to the circuit, we can send a proof that our generated merkle root, say x, satisfies (a-x)(b-x)(c-x)... == 0. One of these will be (x-x), and the proof will pass.\\n\\nMultiple points of failure might encourage anonymous password leaking -- we discuss at the bottom how this can be discouraged with staking.\\\\*\\\\*\\\\*\\n\\n## Public key security\\n\\nNow that we’ve resolved the password leaking issues, we still have the public key leaking issues to fix. We assume using password idea 2 (unique passwords per user) in the following experiments to simplify the logic.\\n\\n**Public key idea 1:** Recall this from our original idea. On authentication, a smart contract stores all the public keys, where you send the transaction from that public key.\\n\\nRecall the issues mentioned before.\\n\\n.\\n\\n.\\n\\n.\\n\\nWell this defeats the purpose, you don't want to share your public key. It gets compromised twice here, in the contract and the sending address. Three times if you seed the contract with the public keys, since then the contract creator also knows them.\\n\\n.\\n\\n.\\n\\n.\\n\\nLet’s focus on the contract address verification step first.\\n\\n**Public key idea 2:** A smart contract stores hashes of all the allowlisted public keys. A message sender sends a zk proof that they know the preimage of any public key.\\n\\n.\\n\\n.\\n\\n.\\n\\nIt is actually possible to find the preimages of the public key hashes; the anonymity set of all eth public keys is only 345M. As a result, making hashes public can be reverse engineered. \\n\\n.\\n\\n.\\n\\n.\\n\\nOne could imagine using random keypairs and not ETH addresses, but there are desirable properties to using an ETH address, such as checking if they own some NFT as a gate to joining the group. Also, we want to be antifragile to client choices such as key reuse.\\n\\n**Public key idea 3:** A smart contract with all hash(public keys | salt), and prove you know a preimage of the public key and some salt.\\n\\n.\\n\\n.\\n\\n.\\n\\nContract anonymity fixed, but we are still sending as that public key! Let’s focus on that, and forget the message for a moment.\\n\\n.\\n\\n.\\n\\n.\\n\\n**Public key idea 4:** A smart contract with a list of all of the hash(public key | salt)s, sent via a relayer with zk proof of a preimage of the public key and some salt.\\n\\nFor a relayer, we can use [Gas Station Network](https://docs.opengsn.org/#architecture), optionally with [tornado.cash](https://tornado.cash)/[zcash](https://z.cash)! But there is an unintended consequence...\\n\\n.\\n\\n.\\n\\n.\\n\\nThe issue is that you could choose any public key that’s not yours then, and add them to the group. While this would still require them knowing the password to utilize, it still seems like an undesirable property. One could imagine signing with a private key instead, but we don’t want to reveal the public key to verify it.\\n\\n.\\n\\n.\\n\\n.\\n\\n**Public key idea 5:** A smart contract with a list of all of the hash(public key | salt), sent via a relayer with zk proof of a preimage of the public key and some salt, that ALSO proves the private key generates the public key. Attach message.\\n\\nSolves anonymity of the sender! One issue...\\n\\n.\\n\\n.\\n\\n.\\n\\nThe message can be frontrun + forged. We can’t directly sign the message, but we have one last zk trick up our sleeves...\\n\\n.\\n\\n.\\n\\n.\\n\\n**Public key idea 6**: Send hash(public key | salt) but add one ZK proof that you know the public key, and some salt, that hash to any allowlisted value, AND verify a sign(message) from your private key. As before, sent via a relayer.\\n\\nThis works! This can be used to link messages across one anonymous user if desired. The group on creation now has a bunch of hash(public key | password)s stored (or we can send password verification schemes with each message), kind of like an invite key system.\\n\\n## Full Constructions\\n\\nWe’ve done all the dirty work. Now, we just have to put it all together!\\n\\n### Full construction 1:\\n\\n**Create step:** The group creator adds a bunch of hash(hash(password))s to a contract.\\n\\n**Join step:** Use a zk proof with the password scheme to verify a password, and add hash(public key | salt) to an allowlist.\\n\\n**Post step:** A ZK proof shows that you know a public key (and some salt) that hashes to a value on the allowlist, AND verify sign(message) from your private key. Also, attach the message. As before, sent via a relayer.\\n\\nThe exact zk proof input and outputs are in the next top level header, for more details! This protocol means a user must have a new password for each message, but can opt to link their message to a previous instance of a user. We implement this password scheme idea in our repository. To resolve frontrunning, a production instance could simply add commit-reveal, or verify the salt is a password.\\n\\n### Full construction 2:\\n\\n**Create step:** The group creator adds a bunch of merkle roots of hash(password | nonce)s.\\n\\n**Join step:** Send a zk proof with the password scheme that proves a merkle root, and hash(public key | password salt) uses the same password. The hash(public key | password salt) added to an allowlist.\\n\\n**Post step:** A ZK proof shows that you know the public key (and the password salt) that hash to any one allowlisted value, AND verify sign(message) from your private key. Also attach message. As before, sent via a relayer.\\n\\nThis works even better, removing the need for unique passwords and making frontrunning impossible, since the original password is never revealed but needs to be known. This also enables linking to past messages, if one opts to make hash(public key | password salt) a public input to the circuit instead.\\n\\n# Protocol\\n\\nTo prove this could actually be done, we build a general purpose client and set of circom circuits/solidity contracts that implements all the logic from the first construction, and proves in a couple of seconds on chain. It is at <https://github.com/nulven/zk-message-board>.\\n\\nThis is what our primary joining zk proof looks like:\\n\\n**Private inputs**\\n\\n* Password (= salt)\\n* Private key\\n\\n**Public inputs**\\n\\n* Our hash(public key | salt)\\n\\n**Main proof constraints**\\n\\n* Private key generates public key \\n* Hash of public key and salt generates the public hash\\n\\nThis is what our primary message zk proof looks like:\\n\\n**Private inputs**\\n\\n* Password (= salt)\\n* Private key \\n* Public key | salt \\n* sign(message, public key)\\n\\n**Public inputs**\\n\\n* Message nonce \\n* Message \\n* All allowed hash(public key | salts)\\n\\n**Main proof constraints**\\n\\n* sign(message) is correct \\n* public key | salt allowed\\n\\nIf trying to avoid front running, one would tack on ‘verify password is valid’ to the last proof’s constraints.\\n\\n# Extensions\\n\\nNote that after this implementation, there were some great new off-chain constructions like [zkmessage.xyz](http://zkmessage.xyz) that provide some pretty cool new features (it’s a very [elegant construction](https://github.com/0xPARC/zkmessage.xyz) as well!) -- feel free to reach out to them/me for more info!\\n\\nWIth this in place, one could extend the given constructions for several more situations. Want to recreate Signal, but where the data, server, and client layers are permissionless and public? Just encrypt each message one more time with a group’s “password” -- now you have private group chats! Want to remove the need for passwords in the first place? Any mathematically verifiable function will do in place of it (say, a specific property of a specially generated API key). Want connections from web2 groups to these? Using [InterRep](https://jaygraber.medium.com/introducing-interrep-255d3f56682) for early proof of concepts like verified Twitter badges is also an exciting way to move group communications onto web3. Worried about gas? Deploy proof of concepts on the [xdai sidechain](https://newsletter.banklesshq.com/p/an-intro-to-xdai-ethereums-sister) or an EVM-compatible rollup/L2 until fees are low. We’re excited to help anyone who wants to build such an extension -- we think these are particularly interesting constructions.\\n\\n# Implications\\n\\nPrivacy is a difficult topic to meander -- any solution that shields users from government backdoors enables scammers, criminals, and covert communication. Given that end to end secure messaging already exists, we are not worried about the additional implications of releasing this technology; this is simply a credibly neutral version of tech already provided by trusted third parties.\\n\\n\\\\*\\\\* Password Idea 3: Note that one could alternatively just block off every alternate node in the merkle tree, and make the even nonces necessary in proofs but invalid for messages. This works, but still boils down to proving the pre-image of a hash (in this case by just sending it).\\n\\n\\\\*\\\\*\\\\* Staking: To discourage password leaking, we can have each password user stake money, and if an attacker knows a leaked password, they can tell the contract and receive the stake in exchange for deleting that merkle root. Assuming this amount is more than the value an attacker gains from an unfavorable post, this system is incentivized to be more secure against password leaks (on the social layer, not tech layer).\",\"timestamp\":1641971527,\"title\":\"Thinking in Zero Knowledge\"},\"digest\":\"KrCvN0sxZB6lO8_QtR2scXK18wGpba1_5L2L5pWOd9k\",\"authorship\":{\"contributor\":\"0x3FD6f213ae1B8a7B6bd8f14BE9BF316a5e5A5d28\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"BPW1ymPgogBJ1lEKImjimSD9HfaKAz63_czMbIR3-u0\\\",\\\"y\\\":\\\"WnRaANPAHgW9Ic2tQiXdAVCVw80mxzfgNJnDniUZNRE\\\"}\",\"signature\":\"vaDJZi00NHH_n1VA4PpyJxxnKTb948RxA9ienb6CkKO1_tIOZMqhS5MfYjLwoYInBwphXVIGR-MlN2Y6DgKeyg\",\"signingKeySignature\":\"0x1e4c4f9c3592ca499ac50cf63116a4d798962420d9e9fdc531c19fd5a088929514b39477fb3ed843211e7751408098e168d0fbe9ba1844cdf13b2f843ab410bb1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"BPW1ymPgogBJ1lEKImjimSD9HfaKAz63_czMbIR3-u0\\\",\\\"y\\\":\\\"WnRaANPAHgW9Ic2tQiXdAVCVw80mxzfgNJnDniUZNRE\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"VTGpmEYLKIslUPf66VQzHUneB0R7EhMpJJ_mGrMvTwY\"}"