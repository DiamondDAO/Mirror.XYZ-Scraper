"{\"content\":{\"body\":\"## 导读\\n\\nif(DAO) 试图用非技术语言和少量数学及密码学知识，向一般读者解释：\\n\\n（1）zk-SNARK 是什么。\\n\\n（2）zk-SNARK 有什么用。\\n\\n（3）通过 zk-SNARK 的协议一步步进化过程弄清零知识的底层原理。\\n\\n（4）通过 Proving Key 、Verifying Key 是什么；Proof 包含的内容有哪些；为什么通过 Proving Key 可以得到 Proof ；为什么通过 Verifying Key 可以验证 Proof 等问题，理解 zk-SNARK 是如何具体落地应用的 。\\n\\n关于zk-SNARK的学术论文包含严谨的数学公式和论证过程；关于zk-SNARK的应用程序代码也有一些成熟的 lib 可供使用。但这些应该是数学家、密码学家和程序员感兴趣的内容，而不是一般读者。所以本文更侧重于如何将zk-SNARK的理论和实践 “联系” 起来。\\n\\n文中如有错误之处还请指正。下面进入正文：\\n\\n## 故事背景\\n\\n1、什么是零知识证明\\n\\n零知识可以简单理解为：我有一个秘密，在不向我朋友阿文透露秘密的情况下，让阿文相信我知道这个秘密。我们将证明的过程/方法称做 “ 零知识证明 ”。\\n\\n2、零知识证明和 zk-SNARK\\n\\n零知识证明包含很多种证明方法，其中的一个证明方法叫做：zk-SNARK （除此之外还有 zk-STARK、BulletProof、zkCNN 等等）。\\n\\n3、zk-SNARK\\n\\nzk-SNARK = zero knowledge Succinct Non-interactive ARgument of Knowledge（非交互式简洁零知识论证）\\n\\n（1）zero knowledge：零知识，即在证明的过程中不透露任何内情。\\n\\n（2）Succinct：简洁的，主要是指验证过程不涉及大量数据传输以及验证算法简单。\\n\\n（3）Non-interactive：无交互，即 Prover 和 Verifier 之间不需要进行交互即可验证命题的真伪。\\n\\n（4）ARgument of Knowledge：知识论证，证明是严谨的，而论证是基于概率的，因而使用论证二字。\\n\\n4、zk-SNARK中的几个基础概念\\n\\n（1）零知识 = 我的秘密。\\n\\n（2）Prover = 证明者，即上面例子中的“我”。\\n\\n（3）Verifier = 验证者，即上面例子中的“阿文”。\\n\\n（4）Proof = 我拿着这个证明（Proof）给阿文，阿文就可以验证我是否知道秘密。\\n\\n（5）Proving Key = 我通过 Proving Key 才能生成 Proof。\\n\\n（6）Verifying Key = 阿文通过 Verifying Key 可以验证我的 Proof 是否为真。\\n\\n5、zk-SNARK 有什么用\\n\\nzk-SNARK 目前在诸多应用场景上均有实现，在此举2个例子抛砖引玉：\\n\\n* 数据隐私\\n\\n我们正处在从 Web2.0 迈向 Web3.0 的时代，未来人们会对隐私有着更高的要求。\\n\\n在 Web2.0 时代，如果我想向银行贷款，我需要出具各种资产证明（抵质押）或交易流水信息（信用），这些信息本来是属于我的个人数据资产，但却必须要赤裸裸的暴露在银行的审核部门之下。\\n\\n在 Web3.0 时代，如果我想向银行贷款，zk-SNARK 可以提供更好的隐私解决方案：\\n\\n零知识是我的资产情况，它可以转化为满足m个约束条件的n个多项式（下文会着重介绍如何对多项式进行零知识论证）。我在不暴露多项式的情况下，通过 Proving Key 生成一个 Proof ，该 Proof 向银行证明我具有贷款资质，而不用暴露我的实际资产信息；银行可以通过 Verifying Key 验证我的资产情况是否满足贷款资质，而无需知道我的实际资产情况。\\n\\n* 数据计算和存储\\n\\n绝大部分区块链网络共识的时候，所有节点做同样的计算才能达成共识，通过 zk-SNARK 可以改进为只需一方计算，其它节点进行简单验证即可，节省了大量的计算资源。\\n\\n以 [Mina Protocol](https://minaprotocol.com/) 为例：Mina 网络将 Merkle Path（当前全网账户状态）转换为n个多项式，从而生成（递归的）zk-SNARK 证明，网络上的其他节点验证证明即可认为当前状态是正确的。当前全局账户状态中又包含上一个区块的账户状态（递归），当前正确，上一个就正确。往前以此类推。\\n\\n对于 Mina 而言，一个递归生成的zk-SNARK证明只有 1kB 左右，即便加上当前区块的 Merkle Path（20kB），无论链体再长，其大小也不会超过 22 kB。这与其他区块链动辄几百G的体积相比几乎可以忽略不计。\\n\\n## 协议背景\\n\\n协议中的零知识（即不能让他人知道的知识）：多项式 P(x) = x^3−3x^2+2x。\\n\\n协议中有2个角色：证明者和验证者。证明者自称知道 P(x)，验证者不知道 P(x)。\\n\\n证明的方式：证明者通过 Proving Key 生成 Proof 并发送给验证者，验证者通过 Verifying Key 验证 Proof 的正确性。整个过程中，验证者在不知道 P(x)的情况下验证了证明者是否知道 P(x)。\\n\\n## 协议一（ zk-SNARK 最原始版本 ）\\n\\n1、证明者\\n\\n首先将 P(x) = x^3−3x^2+2x 因式分解为 P(x) =(x−0)(x−1)(x−2)。\\n\\n2、证明者\\n\\n随机选择因式中的一部分 t(x) = (x−1)(x−2)，并 Public 出去。\\n\\n3、证明者\\n\\n证明者根据 P(x) = t(x) \\\\* h(x) 计算出 h(x) = P(x) /t(x) = (x-0) = x。\\n\\n注：在最终版 zk-SNARK 中会逐步对每一步的动作进行改进，所以在此将证明者的动作拆分为1、2、3步。\\n\\n4、验证者\\n\\n随机取值 s，然后代入多项式计算 t(s) ，并将 s 发送给证明者。\\n\\n5、证明者\\n\\n根据验证者发来的 s ，计算P(s) 和 h(s)，并将计算结果发送给验证者。\\n\\n6、验证者\\n\\n使用第4步计算出的 t(s) 和第5步证明者发来的 P(s) 和 h(s)，验证 t(s) = P(s) / h(s) 是否成立。\\n\\n在这个最原始版本的协议中，我们回顾一下是如何实现证明的：证明者想向验证者证明他知道多项式 P(x)，但又不想暴露知识 P(x)。于是证明者通过 Proving Key = s 计算得到 Proof = P(s) 和 h(s)， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性，即验证者将证明者计算后发来的 t(s) 代入 P(x) = t(x) \\\\* h(x) ，如果等式成立则验证通过。\\n\\n验证的整个过程中，验证者并不知道 P(x) 是什么，却通过 Verifying Key 验证出证明者“可能”知道 P(x)。当验证者随机取值 s0 …… s1 足够多的时候，验证者就可以大概率确认证明者知道 P(x)。\\n\\nProving Key 是什么？Verifying Key 是什么？Proof 包含的内容有哪些？为什么通过 Proving Key 可以得到 Proof ？为什么通过 Verifying Key 可以验证 Proof ？读到这里， if(DAO) 相信各位已经对传说中的 zk-SNARK 有一点感觉了。\\n\\n## 协议二（ 解决证明者用构造方式作弊的问题 ）\\n\\n在协议一的证明者第5步有一个明显的问题：验证者把 s 直接发给了证明者，由于 t(x) 是公开信息，所以证明者可以通过 s 计算出 t(s)的结果，比如 t(s)=5。进而证明者可以随意构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4，将结果发送给验证者进行作弊。\\n\\n为了解决这个问题，在协议二版本的 zk-SNARK 中，验证者不能把s直接发送给证明者，而是把经过隐藏之后的 s 发送给证明者。那么如何隐藏 s 呢，这需要用到一些密码学知识：同态加密。\\n\\n同态加密的具体做法是：验证者生成一个只有他自己知道的G，并将随机数 s 构造成 E(s) = G^s (mod N)的形式，以达到隐藏s的目的。即验证者不希望证明者通过 s 计算P(s)和 h(s)，而是让证明者通过 E(s) 计算 E(P(s)) 和 E(h(s)) 。这里有点绕，下面会解释具体的计算过程。\\n\\n注：mod 计算的顺序是不影响计算结果的，也就是说先计算 mod 在进行加减乘除和先���行加减乘除再分别取 mod 的计算结果一样，所以下面的公式为了看起来简洁统一省略了 mod。\\n\\n1、2、3、证明者\\n\\n同上。\\n\\n4、验证者\\n\\n随机产生 s（不能直接发送给证明者），然后构造\\n\\nE(s^3) = (G^(s^3))\\n\\nE(s^2) = (G^(s^2))\\n\\nE(s) = (G^s)\\n\\n目的（1）：隐藏s，不让证明者通过s计算t(s)，所以就不能构造P(s) =15，h(s)=3 或者 P(s) =20，h(s)=4。\\n\\n目的（2）：隐藏了多项式的系数，因为知道了多项式的系数就等于知道了多项式，从而泄露了知识。\\n\\n最后将构造的 E(s^3)、E(s^2) 、E(s) 发给证明者。\\n\\n5、证明者\\n\\n通过E(s^3) 、E(s^2) 、E(s) 计算 E(P(s)) ，计算过程如下：\\n\\nE(P(s)) = G ^ P(s) = G ^ (s^3−3s^2+2s) = 图1最右侧 = 图1最左侧。\\n\\n![图1](https://images.mirror-media.xyz/publication-images/t0olzObG_C3qxM4N8yMi2.png?height=110&width=1476)\\n\\n证明者把验证者发过来的 E(s^3) 、E(s^2) 、E(s) 代入最左边的方程即可求解出E(P(s)) 。\\n\\n然后证明者通过 h(x) = P(x) / t(x) 计算得到 E(h(s))。\\n\\n最后把 E(P(s)) 和 E(h(s)) 发送给验证者。\\n\\n6、验证者\\n\\n最后验证者通过 t(s) 验证：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n这是因为协议一中验证者验证 “ P(s)是否 = h(s) \\\\* t(s) ”  等价于 “ G ^ P(s) 是否 = (G ^ h(s)) ^ t(s) ”，即E(P(s)) 是否= E(h(s)) ^ t(s) 。\\n\\n在这个改进版的协议二，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 计算得到 Proof = \\\\[ E(P(s)) 、E(h(s)) \\\\] ， 并发送给验证者。验证者通过 Verifying Key = t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n## 协议三（ 用 KEA 解决证明者必须用验证者发来的参数计算 E(P(x)) 的问题 ）\\n\\n在协议二的证明者第6步存在一个证明者的问题：\\n\\n验证者要验证的G ^ P(s) = (G ^ h(s)) ^ t(s) 等价于 G ^ P(S) = (G ^ t(s)) ^ h(s)，证明者可以通过 E(s^3) = (G^(s^3))、E(s^2) = (G^(s^2))、E(s) =(G^s) 计算出来G^t(s) = E(t(s))。\\n\\n这是因为t(s)是公开的，E(t(s)) = 图1最左侧 = 图1最右侧，而E(s^3)、E(s^2) 、E(s)证明者又是知道的。这时证明者可以根据E(t(s))，指定一个h(s)，并构造E(P(s)) ，从而满足E(P(s)) = E(t(s)) ^ h(s) 。\\n\\n所以产生了问题：证明者给验证者的 E(P(x)) 不是用验证者提供的题干： (G^(s^3))， (G^(s^2))，(G^s)计算出来的，即证明者不知道 P(x) 却通过 h(s) 构造了一个满足 E(P(s)) = E(t(s)) ^ h(s)约束的假 E(P(s))，从而骗过了验证者。\\n\\n解决思路：验证者再发送一个新的参数，该参数验证 E(P(x)) 必须用 (G^(s^3))， (G^(s^2))，(G^s) 计算出来。这个方法叫 KEA：Knowledge-of-Exponent Assumption 指数知识假设。\\n\\n4、验证者\\n\\n随机产生 s 并同态加密，然后随机产生 α（阿尔法不方便打字，请允许我用 a 代替偷懒）\\n\\n然后构造 (G^(s^3))， (G^(s^2))，(G^s) ，构造 (G^((a \\\\* s^3))， (G^(a \\\\* s^2))，(G^(a \\\\* s))\\n\\n最后将 G^P(s)，G^P(a \\\\* s) 和 G^h(s) 发给证明者。\\n\\n5、证明者\\n\\n通过 \\\\[ (G^(s^3))， (G^(s^2))，(G^s) \\\\]，\\\\[ (G^((a \\\\* s^3))，(G^(a \\\\* s^2))，(G^(a \\\\* s)) \\\\]计算得出 G^P(s)，G^P(a \\\\* s)，连同证明者第3步已知的 G^h(s) 一并发给验证者。\\n\\n6、验证者\\n\\n（1）最后验证：G^P(s) 是否= (G^h(s)) ^ t(s) （验证零知识：多项式 p(x) 有根 t(x)）；\\n\\n（2）还需要验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) （用来校验证明者是否使用了指定的多项式）。\\n\\n这是因为随机数 a 是验证者产生的，证明者并不知道。验证者拿到证明者计算出来的 G^P(s)和 G^(P(a \\\\* s))，通过a进行验证即可。证明者如果通过构造 G^t(s)，指定一个h(s)，从而形成 (G^h(s)) ^ t(s) = (G^t(s)) ^ h(s) 的形式，然后计算出 G^P(s)，是无法满足 G^P(s) 的a次幂刚好等于G^(P(a \\\\* s)) 的。\\n\\n经过上面的分析，协议三的4、5、6步形如图2：\\n\\n![图2](https://images.mirror-media.xyz/publication-images/142Ixtm7zd5HbfLCEGuDG.png?height=882&width=1364)\\n\\n在这个改进版的协议三，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 和 \\\\[ E(a \\\\* s^3)\\\\*、E( a \\\\* s^2) \\\\*、E(a \\\\* s) \\\\] ，计算得到 Proof = \\\\[ g^p = G^P(s) ，g^p’ = G^P(a\\\\*s) ，以及证明者第3步计算出的G^h(s) \\\\] ， 并发送给验证者。\\n\\n（0）验证者的 Verifying Key = \\\\[  t(s) ，a \\\\]。\\n\\n（1）验证者通过 t(s)  验证 Proof 的正确性：E(P(s)) 是否= E(h(s)) ^ t(s)。\\n\\n（2）验证者通过 a 验证 (G^P(s))^a 是否= G^(P(a \\\\* s)) ，即证明者提供的 g^P 是用验证者提供的 (G^(s^3))， (G^(s^2))，(G^s)计算出来的。\\n\\n## 协议四（ 证明者为了防止验证者暴力破解出多项式使用无成本的零知识 ）\\n\\n在协议三的第5步存在验证者的问题：\\n\\n验证者有可能从证明者发来的信息中推导出多项式，从而导致零知识泄露。当多项式相对简单的时候，比如：b \\\\* x + c，验证者可以通过暴力破解的方式破解系数，然后验证者再按照证明者计算的内容将多项式计算出来。\\n\\n所以证明者需要随机生成 δ 对返回值进行同态加密，将发送数据隐藏后再发送给验证者。证明者发送给验证者的值也进行同态加密，这个过程通常被称为：无成本的零知识。\\n\\n5、证明者随机生成δ，并构造\\n\\n(G^P(s))^δ、(G^h(s))^δ 和 (G^P(a \\\\* s))^δ 发送给验证者。\\n\\n所以协议三的5、6步改进为图3：\\n\\n![图3](https://images.mirror-media.xyz/publication-images/KgYIIsBrbHvaQ955wqcd-.png?height=808&width=1218)\\n\\n在这个改进版的协议四，我们回顾一下是如何实现证明的：证明者通过同态加密后的 Proving Key = \\\\[ E(s^3)、E(s^2) 、E(s) \\\\] 和 \\\\[ E(a \\\\* s^3)\\\\*、E( a \\\\* s^2) \\\\*、E(a \\\\* s) \\\\] ，计算得到 Proof = \\\\[ g^p = G^P(s) ，g^p’ = G^P(a\\\\*s) \\\\] ， 将 Proof 再进行一次同态加密：Proof = \\\\[ (G^P(s))^δ、(G^P(a \\\\* s))^δ、以及证明者第3步计算出的G^h(x)的加密值：(G^h(s))^δ \\\\]，最后将 Proof 返回给验证者。\\n\\n（0）验证者的 Verifying Key = \\\\[  t(s) ，a \\\\]。\\n\\n（1）验证者通过 t(s)  验证 Proof 的正确性：(G^P(s))^δ 是否= \\\\[ (G^h(s))^δ \\\\]^ t(s)。\\n\\n等价于 G^(P(s) \\\\* δ) 是否=  G^( h(s) \\\\* δ \\\\* t(s) ) 等价于 G^(δ \\\\* p) 是否= G^(δ \\\\* h(s) \\\\*  t(s) )。\\n\\n（2）验证者通过 a 验证 \\\\[ (G^P(s))^δ \\\\]^a 是否= \\\\[ (G^P(a \\\\* s))^δ \\\\] 。\\n\\n## “ 交互式 ” 零知识论证\\n\\n至此，我们一起把协议一升级到了协议四。细心的读者可能已经发现，协议四中仍然需要 “ 验证者先生成一些信息，把信息提供给证明者，证明者根据这些信息计算一些结果，再返回给验证者 ”，这分明就是在 “ 交互 ”，和我们的主题 zk-SNARK “ 非交互式 ” 零知识论证 不符。\\n\\n虽然是 “ 交互式 ” ，但协议执行的过程中还是很完美的实现了我的既定目标：验证者在全程零知识的情况下验证了证明者的论述。那我们为什么还需要 “ 非交互式 ” 呢？\\n\\n这是因为交互式零知识论证有着2个明显的硬伤：\\n\\n1、因为需要交互，所以要求每个证明者和验证者必须同时在线。\\n\\n2、每一个验证者都会随机选出 s 和 a，证明者需要计算n次，效率低下（n个节点）。\\n\\n所以下面我们的主要工作将致力于将 “ 交互式 ” 改进为 “ 非交互式 ” 。\\n\\n## 协议五（ 为了避免证明者和验证者直接交互，引入第三方，同时使用椭圆曲线双线性映射工具解决“交互式”零知识协议四中验证者无法用G^t(s)验证E(P(s)) = E(h(s)) ^ t(s)的问题 ）\\n\\n从交互式改为非交互式，即验证者和证明者之间不交互，我们面临的第一个严峻的问题是：\\n\\n当 s 和 a 不能由验证者随机产生时，由于验证者和证明者之间不交互，证明者就不知道 t(s) 和 a，所以没法进行第6步的验证工作。\\n\\n当 s 和 a 由第三方随机产生时，然后计算 t(s) 和 a，如果直接发送给验证者，且验证者和证明者串谋时，证明者依然可以通过 t(s) 指定一个h(s)从而构建P(s)。\\n\\n当 s 和 a 由第三方随机产生时，然后计算 t(s) 和 a，加密后将 g^t(s) 和 g^a 发送给验证者，虽然解决了验证者和证明者串谋问题，但此时验证者得到的 Verifying Key = \\\\[ g^t(s)，g^a \\\\]，是无法代入验证(G^P(s))^δ 是否= \\\\[ (G^h(s))^δ \\\\]^ t(s)的（此时验证者知道g^t(s)却不知道t(s) ）。\\n\\n所以此时我们要引入一个新的工具来解决验证者不知道t(s)只知道g^t(s)，无法代入验证(G^P(s))^δ 是否= \\\\[ (G^h(s))^δ \\\\]^ t(s)的问题。这个新的工具就是椭圆曲线双线性映射。\\n\\n配对操作（双线性映射）是一个数学结构，表示为函数 *e(g,g)*，它给定一个数据集中的两个加密的输入（即 g^a, g^b ），可以将他们确定性地映射到另一组不同的输出数据集上的它们的乘积，即 e(g^a, g^b) = e(g, g)^(ab)。如图4所示：\\n\\n![图4](https://images.mirror-media.xyz/publication-images/V8J4d6OBogHDqrRv12k1S.png?height=612&width=1380)\\n\\n已知椭圆曲线满足的性质：e(g^a, g^b) = g^(ab)。（ 知道踩油门就可以开车，无需把发动机拆开才可以开车，Right？）\\n\\n所以验证者验证 (G^P(s))^δ 是否= \\\\[ (G^h(s))^δ \\\\]^ **t(s)** 的问题转化为：\\n\\n验证者验证 e ( g^(P(s) \\\\* δ)，g^1 ) 是否= e ( **g^t(s)** ，g^(h(s)\\\\*δ) )\\n\\n这是因为：\\n\\n左侧 = g^(P(s) \\\\* δ) \\\\* 1 = e ( g^(P(s) \\\\* δ)，g^1 )\\n\\n右侧 = g^( t(s) \\\\* h(s) \\\\* δ ) = e ( g^t(s),  g^(h(s)\\\\*δ) )\\n\\n同理 \\\\[ (g^p(s))^δ \\\\]^a = \\\\[ (g^p(a\\\\*s))^δ \\\\] 等价于 e ( (g^p(s))^δ，g^a ) = e (  (g^p(a\\\\*s))^δ，g^1 )\\n\\n所以协议五最终的形式如图5所示：\\n\\n![图5](https://images.mirror-media.xyz/publication-images/CSSv7eAoMVy20txvNO07a.png?height=1294&width=1502)\\n\\n第三方将 g^t(s) 和 g^a 发送给验证者，即Verification Key。\\n\\n同时将 g^si 和 g^(a\\\\*si) 发送给证明者，即Prover Key。\\n\\n证明者生成的 g^p(s)、g^h(s)、g^p'(s) = g^p(a\\\\*s)，即Proof。\\n\\n在这个改进版的协议五中，我们回顾一下是如何实现证明的：\\n\\n4、第三方\\n\\n随机生成 s 和 a，然后计算出 t(s)，然后\\n\\n（1）将 g^t(s) 和 g^a 发送给验证者，即Verifying Key。\\n\\n（2）将 g^si 和 g^(a\\\\*si) 发送给证明者，即Prover Key。\\n\\n5、证明者\\n\\n根据g^si 和 g^(a\\\\*si) 计算出g^p(s)、g^p'(s) = g^p(a\\\\*s) \\\\*，\\\\*根据 P(x)=t(s) \\\\* h(s)计算出h(s)并构造出 g^h(s)，然后再通过 δ 加密，即 Proof = \\\\[ (g^p(s))^δ、(g^p(a\\\\*s))^δ、(g^h(s))^δ \\\\]，最后把 Proof 发送给验证者。\\n\\n6、验证者\\n\\n（1）通过 g^t(s)  验证 Proof 的正确性：e ( g^(P(s) \\\\* δ) ，g^1 ) = e ( g^t(s) ，g^(h(s)\\\\*δ) )\\n\\n（2）通过 g^a 验证 e ( (g^p(s))^δ ，g^a ) = e (  (g^p(a\\\\*s))^δ ，g^1 )。\\n\\n## 协议六（ 通过CRS去掉第三方 ）\\n\\n协议五中有一个明显的问题：生成随机 t(s) 和 a 的第三方是未必可信的，就如同无数中心化机构舞弊的案例。\\n\\n其中的一个解决方案是把全网所有的参与方拉下水，大家共同参与生成随机 t(s) 和 a 的过程。用到的工具是CRS（Common Reference String，公共参考串）。\\n\\n多方参与生成CRS，如图6所示：\\n\\n![图6](https://images.mirror-media.xyz/publication-images/qqO093dbZALSEo8En1rH1.png?height=1302&width=1386)\\n\\n## 协议七：zk-SNARKOP 协议（ 相对完善的4、5、6步 ）\\n\\n在协议六中多方参与生成CRS的问题：参与者生成 CRS 的过程并没有强制后一个参与者（图6中的 Bob 和 Carol）都要使用前面已经公开的 CRS。如果一个攻击者是链上的最后一个参与者，他可以像链上的第一个参与者一样忽略前面的 CRS 随便构造一个有效的 CRS，这样他就变成了唯一一个知道秘密 *s* 和 *α* 的人。\\n\\n为了解决这个问题，我们可以额外再要求除了第一个（可信的）以外的每一个参与者去加密然后公开他的参数。\\n\\n这样我们得到了一个完整的 **zk-SNARKOP** 协议，如图7所示：\\n\\n![图7](https://images.mirror-media.xyz/publication-images/CH-S31ZwjLpra33Oq0yB9.png?height=1280&width=1412)\\n\\n1、证明者（不变）\\n\\n首先将 P(x) = x^3−3x^2+2x 因式分解为 P(x) =(x−0)(x−1)(x−2)。\\n\\n2、证明者（不变）\\n\\n随机选择因式中的一部分 t(x) = (x−1)(x−2)，并 Public 出去。\\n\\n3、证明者（不变）\\n\\n证明者根据 P(x) = t(x) \\\\* h(x) 计算出多项式 h(x) = P(x) /t(x) = (x-0) = x。\\n\\n4、全网各方（ 协议二、协议三、协议六 ）\\n\\n（1）网络多方参与生成一个相对可信的 CRS ：生成随机数 s 和 a。也称 Setup 可信设置。\\n\\n（2）构建加密值 g^si、g^a、g^(a\\\\*si)。\\n\\n（3）生成 Proving Key = \\\\[ g^si、g^(a\\\\*si) \\\\]，并发送给证明者。\\n\\n（4）生成 Verifying Key = \\\\[ g^a、g^t(s) \\\\]，并发送给验证者。\\n\\n5、证明者（协议四）\\n\\n（1）通过 g^si 计算得到 g^p(s) 和 g^h(s) （证明者知道 P(x) 和 h(x) = P(x) /t(x) ）。\\n\\n（2）通过 g^(a\\\\*si) 计算得到 g^(a\\\\*p(s)) 。\\n\\n（3）随机生成 δ ，构造随机化 Proof = \\\\[ g^( δ \\\\* p(s))、g^( δ \\\\* h(s))、g^( δ \\\\* (a\\\\*p(s))) \\\\]，然后发送给验证者（Proof 中是不包含 P(x) 的知识的）。\\n\\n6、验证者（协议五）\\n\\n（1）Proof = \\\\[ g^( δ \\\\* p(s))、g^( δ \\\\* h(s))、g^( δ \\\\* (a\\\\*p(s))) \\\\] 简写为 \\\\[ g^p、g^h、g^p’ \\\\]。\\n\\n（2）验证多项式约束（验证证明者是否使用 CRS 的参数来计算 g^p(s) 和 g^h(s)）：\\n\\ne ( (g^p(s))^δ ，g^a ) = e (  (g^p(a\\\\*s))^δ ，g^1 ) （协议五）简写为\\n\\ne ( g^p ，g^a ) = e ( g^p’ ，g^1 )\\n\\n（3）验证多项式系数（验证验证者是否知道多项式的各项系数 = 知道多项式）：\\n\\ne ( g^(P(s) \\\\* δ) ，g^1 ) = e ( g^t(s) ，g^(h(s)\\\\*δ) ) 简写为\\n\\ne ( g^p ，g^1 ) = e ( g^t(s) ，g^h )\\n\\n## 协议八（ 在多项式零知识证明的基础上，增加程序向多项式的转化 ）\\n\\n之前我们已经完成了对多项式 P(x) = h(x) \\\\* t(x) 的证明（ 即协议七 zk-SNARKOP ），如果我们能够把计算机程序转化为 P(x) ，就可以完成对程序的零知识证明。\\n\\n任何计算的本质都是由以下形式的基本运算组成的：\\n\\n`左操作数 运算操作符 右操作数 = 输出结果`\\n\\n以乘法运算操作为例，上述运算可以转换为：l(x) \\\\* r(x) = o(x) ，即 l(x) \\\\* r(x) - o(x) = 0 。\\n\\n令 P(x) = l(x) \\\\* r(x) - o(x) = 0 ，这代表 P(x) 在 x = 某个值 a 的时候与 x 轴有交点。\\n\\n对于函数 f(a ，b) { return a \\\\* b }，当传入参数是 ：3 \\\\* 2 （= 6）的时候，可以构造多项式（ Enforcing Operation ）表示该函数： l(x) = 3x ，r(x) = 2x ， o(x) = 6x ，约束条件为 x=1 。即 l(1) = 3 ，r(1) = 2 ，o(1) = 6。\\n\\n那么 P(x) = l(x) \\\\* r(x) - o(x) = 3x \\\\* 2x - 6x = 6x^2 - 6x ，用图形表示出来就是：\\n\\n![](https://images.mirror-media.xyz/publication-images/Odp9wET4rOcp5QNGq_p2L.png?height=596&width=468)\\n\\n从图形中可以清楚的看到，当 x = 1 的时候 P(x) = l(x) \\\\* r(x) - o(x) = 6x^2 - 6x = 0 ，这意味着 (x-1) 是 P(x) = l(x) \\\\* r(x) - o(x) 分解因式后的一个因子。这就是协议七 zk-SNARKOP 中的合适的 t(x) = x - 1 。\\n\\nzk-SNARKOP 协议的零知识就转化为： P(x) = h(x) \\\\* t(x) = l(x) \\\\* r(x) - o(x)。所以协议可以更新为：\\n\\n![](https://images.mirror-media.xyz/publication-images/DLLf0HYyPs205kseH5YFT.png?height=1248&width=1202)\\n\\n上面协议的本质就是将协议七 zk-SNARKOP 中的 P(x) 用 l(x) \\\\* r(x) - o(x) 代替。\\n\\n协议八也存在比较明显的局限性：\\n\\n1、乘法也不会仅仅是 a \\\\* b 的简单单一运算形式（ 下面章节解决 ）。\\n\\n2、程序计算不可能只包含乘法���（xx解决）？？\\n\\n## 仍然协议八（ 解决复杂乘法的问题 ）\\n\\n我们首先解决复杂乘法计算的问题，比如乘法计算含有中间过程量。\\n\\na \\\\* b \\\\* c （ 例如 3 \\\\* 2 \\\\* 4 = 24 ）可以转化为：\\n\\na \\\\* b = r1\\n\\nr1 \\\\* c = r2\\n\\n我们按照协议八的思路，将上述2个运算构造成 l(x) \\\\* r(x) = o(x) 的形式。将运算构造成多项式的方法统称插值法（用给定的一组点去构造一个能经过所有这些点的弯曲多项式），具体包括：一组未知方程、牛顿多项式、内维尔算法、拉格朗日多项式、快速傅里叶变换。\\n\\n这里我们使用 “ 一组未知方程 ” 去构造 l(x) \\\\* r(x) = o(x) 的形式：\\n\\n`l(1) = a ，l(2) = r1 `\\n\\n`r(1) = b ，r(2) = c`\\n\\n`o(1) = r1 ，o(2) = r2`\\n\\n`当 x = 1 时，l(1) * r(1) = o(1)`\\n\\n`当 x = 2 时，l(2) * r(2) = o(2)`\\n\\n对于 l(1) = a ，l(2) = r1 就相当于点 (1 ，a) 和点 (2 ，r1)  确定一条直线，所以可以得到 l(x)。\\n\\n对于 r(1) = b ，r(2) = c 就相当于点 (1 ，b) 和点 (2 ，c)  确定一条直线，所以可以得到 r(x)。\\n\\n对于 o(1) = r1 ，o(2) = r2 就相当于点 (1 ，r1) 和点 (2 ，r2)  确定一条直线，所以可以得到 o(x)。\\n\\n例如我们要计算的函数是 f(a ，b ，c) { return = a \\\\* b \\\\* c } ，函数是 Public 的，我们要构建 l(x) 、r(x) 、o(x)。\\n\\n将 a \\\\* b \\\\* c 拆分成如下形式：\\n\\na \\\\* b = r1\\n\\nr1 \\\\* c = r2\\n\\n假设参数  a = 3 ，b = 2 ，c = 4，即：\\n\\n3 \\\\* 2 = 6\\n\\n6 \\\\* 4 = 24\\n\\n构建 l(x) 、r(x) 、o(x)：\\n\\nl(1) = 3 ，r(1) = 2 ，o(1) = 6\\n\\nl(2) = 6 ，r(2) = 4 ，o(2) = 24\\n\\nl(x) 经过了点（1 ，3）和点（2 ，6）得到 l(x) = 3x\\n\\n因为2点确定一条直线 y = kx + b\\n\\n1 \\\\* k + b = 3\\n\\n2 \\\\* k + b = 6\\n\\nk = 3 , b = 0\\n\\n同理可以得到 r(x) 和 o(x)。\\n\\n3 \\\\* 1 = 3\\n\\n3 \\\\* 4 = 12\\n\\nl(1) = 3 ， r(1) = 1 ，o(1) = 3\\n\\nl(2) = 3 ，r(2) = 4 ，o(2) = 12\\n\\n> 未完待续\",\"timestamp\":1640310810,\"title\":\"浅谈零知识证明之zk-SNARK\"},\"digest\":\"3vFzcysovzW7IL3-6vxgpnqr3iEMqG2zquQtoRrZzI4\",\"authorship\":{\"contributor\":\"0xd05cFA28Eaf8B4eaFD8Cd86d33c6CeD1a1875417\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"signature\":\"osjW3aD9Fo8Goot8i2NMlXZaEygohzWiV_eP601Qj9LCRtSMIIQoecQrAROZYfgi780ZpAuq5UnCzzb6Q1QBqQ\",\"signingKeySignature\":\"0x37986d551641971cdf6ada5c4365b09fa1f1c9565275e4a2e69a6dfcc1435d3a3e15e6f1cbc1bd770fba430d41423a94c25d58507bcf912632c134b280faffdc1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"KWjtaKwd78DDJrW8n6n5qQxTE9yk6mJXk4es_LvcYgc\\\",\\\"y\\\":\\\"G2NvayJZiTe2Uf64WNGgO06gDiPcjJExpdNPHKCDkus\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"X3qSOjObTknXQ_iGhDBFYETibD0TVW0twz5QDIthjGI\"}"