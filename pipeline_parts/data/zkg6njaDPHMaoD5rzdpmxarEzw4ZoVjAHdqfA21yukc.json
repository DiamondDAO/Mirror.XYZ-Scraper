"{\"content\":{\"body\":\"Aug 25, 202132 min. read\\n\\n编译器的目的是将一种语言转换成另一种语言。把编译器想象成一个翻译器。 比如你会雇一个翻译来听你说英语，然后翻译成日语。\\n\\n为此，翻译人员必须了解源语言和目标语言的语法结构。\\n\\n有些编译器会编译成低级机器码，可以直接在系统上执行。其他编译器会编译成一种中间语言，由虚拟机执行。\\n\\n选择编译器时的一个考虑因素是系统可移植性要求。 [Java](https://en.wikipedia.org/wiki/Java_bytecode) 和 [.NET CLR](https://en.wikipedia.org/wiki/Common_Language_Runtime) 将编译成一种中间语言，以便编译后的代码可以跨多个系统架构移植。 C、Go、C++ 和 Pascal 将编译成可执行的二进制文件。此二进制文件是为编译它的平台构建的。\\n\\nPython 应用程序通常作为源代码分发。Python 解释器的作用是将Python源代码进行转换并一步执行。 CPython 运行时在第一次运行时会编译你的代码。这一步对普通用户是不可见的。\\n\\nPython 代码不会被编译成机器码；它被编译成一种称为 **字节码** 的低级中间语言。 此字节码存储在 `.pyc` 文件中并缓存以供执行。 如果在不更改源代码的情况下两次运行同一个 Python 应用程序，则第二次执行速度会更快。 这是因为它加载编译后的字节码而不是每次都重新编译。\\n\\n## 为什么 CPython 是用 C 而不是用 Python 编写\\n\\nCPython 中的 **C** 是对 C 编程语言的引用，这意味着这个 Python 发行版是用 C 语言编写的。\\n\\n这种说法大多是正确的：CPython 中的编译器是用纯 C 编写的。 但是，许多标准库模块是用纯 Python 或 C 和 Python 组合编写的。\\n\\n**那么为什么 CPython 编译器是用 C 而不是 Python 编写的呢？**\\n\\n答案在于编译器的工作方式。 有两种类型的编译器：\\n\\n1.  [自举编译器](https://en.wikipedia.org/wiki/Self-hosting_\\\\(compilers\\\\)) 是用它们编译的语言编写的编译器，例如 Go 编译器。这是通过称为引导的过程完成的。\\n2.  [源到源编译器](https://en.wikipedia.org/wiki/Source-to-source_compiler) 是用另一种已经有编译器的语言编写的编译器。\\n\\n如果你要从头开始编写新的编程语言，则需要一个可执行应用程序来编译你的编译器！ 你需要一个编译器来执行任何事情，所以当开发新语言时，它们通常首先用更老的、更成熟的语言编写。\\n\\n还有一些可用的工具可以读取语言规范并创建解析器。 流行的编译器-编译器（compiler-compilers）包括 GNU Bison、Yacc 和 ANTLR。\\n\\n> 如果你想了解有关解析器的更多信息，请查看 [lark](https://github.com/lark-parser/lark) 项目。 Lark 是一个用 Python 编写的上下文无关语法解析器。\\n\\n编译器引导的一个很好的例子是 Go 编程语言。 第一个 Go 编译器是用 C 编写的，然后一旦 Go 可以编译了，就用 Go 重写编译器。\\n\\nCPython 保留了 C 语言的传统；许多标准库模块，如 ssl 模块或套接字模块，都是用 C 编写的，用于访问低级操作系统 API。 Windows 和 Linux 内核中用于[创建网络套接字](https://realpython.com/python-sockets/)、 [使用文件系统](https://realpython.com/working-with-files-in-python/)或 [与显示器交互](https://realpython.com/python-gui-with-wxpython/)的 API 都是用 C 编写的。 Python 的可扩展性层专注于 C 语言是有意义的。\\n\\n有一个用 Python 编写的 Python 编译器，称为 PyPy。 PyPy 的标志是一个 [衔尾蛇](https://en.wikipedia.org/wiki/Ouroboros)，代表编译器的自举性质。\\n\\nPython 交叉编译器的另一个示例是 Jython。Jython 是用 Java 编写的，从 Python 源代码编译成 Java 字节码。 与 CPython 可以轻松导入 C 库并从 Python 中使用它们一样，Jython 可以轻松导入和引用 Java 模块和类。\\n\\n创建编译器的第一步是定义语言。 例如，一下不是有效的 Python：\\n\\n    def my_example() <str> :\\n    {\\n        void* result = ;\\n    }\\n\\n编译器在尝试执行之前需要严格的语言语法结构规则。\\n\\n> 对于本书的其余部分，`./python` 将指代 CPython 的编译版本。 但是，实际命令将取决于你的操作系统。\\n>\\n> 对于 Windows：\\n>\\n>     > > python.exe\\n>     >\\n\\n> 对于 Linux：\\n>\\n>     > $ ./python\\n>     >\\n\\n> 对于 macOS：\\n>\\n>     > $ ./python.exe\\n>     >\\n\\n## Python 语言规范\\n\\nCPython 源代码中包含 Python 语言的定义。这个文档是所有 Python 解释器使用的参考规范。\\n\\n该规范采用人类可读和机器可读的格式。文档里面是对 Python 语言的详细解释。包含允许的内容以及每个语句的行为方式。\\n\\n### 语言文档\\n\\n位于 `Doc/reference` 目录中的是 Python 语言中每个功能的 [reStructured-Text](http://docutils.sourceforge.net/rst.html) 解释。 这些文件构成了 [docs.python.org/3/reference](https://docs.python.org/3/reference/) 上的官方 Python 参考指南。\\n\\n目录里面是你需要了解整个语言、结构和关键字的文件：\\n\\n    cpython/Doc/reference/\\n    ├── compound_stmts.rst          复合语句，如 if、while、for 和函数定义\\n    ├── datamodel.rst               对象、值和类型\\n    ├── executionmodel.rst          Python程序的结构\\n    ├── expressions.rst             Python 表达式的元素\\n    ├── grammar.rst                 Python 的核心语法（参考 Grammar/Grammar）\\n    ├── import.rst                  导入系统\\n    ├── index.rst                   语言参考索引\\n    ├── introduction.rst            参考文档介绍\\n    ├── lexical_analysis.rst        词法结构，如行、缩进、标记和关键字\\n    ├── simple_stmts.rst            简单的语句，如 assert、import、return 和 yield\\n    └── toplevel_components.rst     执行 Python 的方式的描述，如脚本和模块\\n\\n### 一个例子\\n\\n在 `Doc/reference/compound_stmts.rst`，你可以看到一个定义 `with` 语句的简单示例。\\n\\n`with` 语句有多种形式，最简单的是上下文管理器的实例化和嵌套的代码块：\\n\\n    with x():\\n        ...\\n\\n你可以使用 `as` 关键字将结果分配给变量：\\n\\n    with x() as y:\\n        ...\\n\\n你还可以使用逗号将上下文管理器链接在一起：\\n\\n    with x() as y, z() as jk:\\n        ...\\n\\n文档包含语言的人类可读规范，机器可读规范包含在单个文件 `Grammar Grammar` 中。\\n\\n### 语法文件\\n\\n> 本节指的是“旧解析器”使用的语法文件。 在发布时，“新解析器”（PEG 解析器）是实验性的，尚未完成。\\n>\\n> 对于 3.8 及以下版本的 CPython，默认使用 pgen 解析器。 对于 CPython 3.9 及更高版本，PEG 解析器是默认的。可以在命令行上使用 `-X oldparser` 启用旧解析器。\\n>\\n> 两个解析器都使用 `Tokens` 文件。\\n\\n语法文件以一种称为[巴科斯范式](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) (BNF) 的上下文符号编写。 巴科斯范式不是 Python 特有的，通常用作许多其他语言中的语法符号。\\n\\n编程语言中语法结构的概念受到 [Noam Chomsky 在 1950 年代关于句法结构的工作](https://en.wikipedia.org/wiki/Syntactic_Structures)的启发！\\n\\nPython 的语法文件使用扩展巴科斯范式（EBNF）规范和正则表达式语法。因此，在语法文件中，你可以使用：\\n\\n*   `*` 用于重复\\n*   `+` 至少重复一次\\n*   `[]` 用于可选部分\\n*   `|` 对于替代品\\n*   `()` 用于分组\\n\\n例如，考虑如何定义一杯咖啡：\\n\\n*   它必须有一个杯子\\n*   它必须包括至少一瓶浓缩咖啡（espresso），并且可以包含多个\\n*   它可以有牛奶，但可选\\n*   你可以在咖啡中加入多种牛奶，如全脂、脱脂和豆奶（soy）\\n\\n在 EBNF 中定义的咖啡订单可能如下所示：\\n\\n    coffee: 'cup' ('espresso')+ ['water'] [milk]\\n    milk: 'full-fat' | 'skimmed' | 'soy'\\n\\n在本章中，语法是用铁路图形象化的。 这张图是咖啡语句的铁路图：\\n\\n![coffee_statement](https://user-images.githubusercontent.com/3297411/130769007-ecd75282-7d28-4d9f-9904-60cba7b83350.png)\\n\\n在铁路图中，每个可能的组合必须从左到右排成一条线。 可选语句可以被绕过，有些语句可以形成循��。\\n\\n如果在语法文件中搜索 `with_stmt`，可以看到定义：\\n\\n    with_stmt: 'with' with_item (',' with_item)*  ':' suite\\n    with_item: test ['as' expr]\\n\\n引号中的任何内容都是字符串文字，称为终端（terminal）。终端是识别关键字的方式。`with_stmt` 指定为：\\n\\n1.  从 `with` 开始\\n2.  后面跟一个 `with_item`，它可以是 `test`，和（可选的） `as` 以及一个表达式 `expr`\\n3.  接着是一个或多个 `with_item`，每个都用逗号隔开\\n4.  以 `:` 结尾\\n5.  跟一个 `suite`\\n\\n在这两行中引用了其他三个定义：\\n\\n• `suite` 是指包含一个或多个语句的代码块 • `test` 指的是一个被评估的简单的语句 • `expr` 指的是一个简单的表达式\\n\\n在铁路图中可视化，`with` 语句如下所示：\\n\\n![with_stmt](https://user-images.githubusercontent.com/3297411/130769199-d7db516f-fb2e-4a7d-ae4e-ca34f5c49d78.png)\\n\\n作为一个更复杂的例子，`try` 语句定义为：\\n\\n    try_stmt: ('try' ':' suite\\n               ((except_clause ':' suite)+\\n                ['else' ':' suite]\\n                ['finally' ':' suite] |\\n               'finally' ':' suite))\\n    except_clause: 'except' [test ['as' NAME]]\\n\\n`try` 语句有两种用途：\\n\\n1.  `try` 和一个或多个 `except` 子句，然后是一个可选的 `else`，然后是一个可选的 `finally`\\n2.  `try` 和只有一个 `finally` 语句\\n\\n或者，在铁路图中可视化：\\n\\n![try_stmt](https://user-images.githubusercontent.com/3297411/130769305-3fc27399-a211-48ae-92c9-780885c2ca03.png)\\n\\n`try` 语句是更复杂结构的一个很好的例子。\\n\\n如果你想详细了解 Python 语言，语法在 `Grammar/Grammar` 中定义。\\n\\n## 使用解析器生成器（The Parser Generator）\\n\\nPython 编译器从不使用语法文件本身。相反，解析器表由解析器生成器创建。 如果对语法文件进行更改，则必须重新生成解析器表并重新编译 CPython。\\n\\n解析器表是潜在解析器状态的列表。当解析树变得复杂时，它们确保语法不会有歧义。\\n\\n## 解析器生成器\\n\\n解析器生成器的工作原理是将 EBNF 语句转换为非确定性有限自动机 (Non-deterministic Finite Automaton，NFA)。 NFA 状态和转换被解析并合并为一个确定性有限自动机 (Deterministic Finite Automaton，DFA)。\\n\\nDFA 被解析器用作解析表。这种技术是[在斯坦福大学形成的](http://infolab.stanford.edu/\\\\~ullman/dragon/slides1.pdf)，并在 1980 年代开发，就在 Python 出现之前。 CPython 的解析器生成器 `pgen` 是 CPython 项目独有的。\\n\\n`pgen` 应用程序在 Python 3.8 中从 C 重写为 Python，在文件 `Parser/pgen/pgen.py` 中。\\n\\n它可通过以下执行：\\n\\n    $ ./python -m Parser.pgen [grammar] [tokens] [graminit.h] [graminit.c]\\n\\n它通常从构建脚本执行，而不是直接执行。\\n\\nDFA 和 NFA 没有视觉输出，但有一个带有有向图输出的 [CPython 分支](https://github.com/tonybaloney/cpython/tree/dot_pgen)。 `decorator` 语法在 `Grammar/Grammar` 中定义为：\\n\\n    decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\\n\\n解析器生成器创建了一个包含 11 个状态的复杂 NFA 图。每个状态都用数字表示（在语法中提示它们的名称）。 状态转移被称为“弧”。\\n\\nDFA 比 NFA 更简单，路径减少了：\\n\\n![decorator_DFA](https://user-images.githubusercontent.com/3297411/130769383-4c305c61-39c4-4239-934e-5fadf0fc5281.png)\\n\\nNFA 和 DFA 图仅用于调试复杂语法的设计。\\n\\n我们将使用铁路图代替 DFA 或 NFA 图来表示语法。例如，此图表示 `decorator` 语句可以采用的路径：\\n\\n![decorator_stmt](https://user-images.githubusercontent.com/3297411/130769434-73eb6a03-e7a1-4baa-bd65-e7b467b49ec9.png)\\n\\n## 重新生成语法\\n\\n要查看 `pgen` 的运行情况，让我们更改部分 Python 语法。 在 `Grammar/Grammar` 中搜索 `pass_stmt` 以查看 `pass` 语句的定义：\\n\\n    pass_stmt: 'pass'\\n\\n![pass_stmt](https://user-images.githubusercontent.com/3297411/130769494-9b57251f-38fe-4d3b-b8eb-73e49c831eda.png)\\n\\n通过添加选择 `|` 和 `proceed` 字面量，更改该行以接受终端（关键字）`'pass'` 或 `'proceed'` 作为关键字：\\n\\n    pass_stmt: 'pass' | 'proceed'\\n\\n![pass_stmt_modified](https://user-images.githubusercontent.com/3297411/130769525-5107b366-f299-4299-a31d-8573304203ec.png)\\n\\n接下来，通过运行 `pgen` 重建语法文件。CPython 带有脚本来自动化 `pgen`。\\n\\n在 macOS 和 Linux 上，运行 `make regen-grammar`：\\n\\n    $ make regen-grammar\\n\\n对于 Windows，从 PCBuild 目录调出命令行并使用 `--regen` 标志运行 `build.bat`：\\n\\n    > build.bat --regen\\n\\n你应该会看到一个输出，显示新的 `Include/graminit.h` 和 `Python/graminit.c` 文件已重新生成。\\n\\n使用重新生成的解析器表，当你重新编译 CPython 时，它将使用新语法。\\n\\n如果代码编译成功，你可以执行新的 CPython 二进制文件并启动 REPL。\\n\\n在 REPL 中，你现在可以尝试定义一个函数。不要使用 pass 语句， 而是使用你编译到 Python 语法中的 `proceed` 关键字替代 `pass`：\\n\\n    $ ./python -X oldparser\\n    Python 3.9.0b1 (tags/v3.9.0b1:97fe9cf, May 19 2020, 10:00:00)\\n    [Clang 10.0.1 (clang-1001.0.46.4)] on darwin\\n    Type \\\"help\\\", \\\"copyright\\\", \\\"credits\\\" or \\\"license\\\" for more information.\\n    >>> def example():\\n    ...    proceed\\n    ...\\n    >>> example()\\n\\n恭喜，你已经更改了 CPython 语法并编译了你自己的 CPython 版本。\\n\\n接下来，我们将探索标记（tokens）及其与语法的关系。\\n\\n### 标记（Tokens）\\n\\n除了 `Grammar` 文件夹中的语法文件之外，还有 `Grammar/Tokens` 文件， 其中包含在分析树中作为叶节点找到的每个唯一类型。每个标记还有一个名称和一个生成的唯一 ID。 名称用于使在分词器（tokenizer）中更容易引用。\\n\\n> `Grammar/Tokens` 文件是 Python 3.8 中的一项新功能。\\n\\n例如，左括号称为 `LPAR`，分号称为称为 `SEMI`。 你将在本书后面看到这些标记：\\n\\n    LPAR                    '('\\n    RPAR                    ')'\\n    LSQB                    '['\\n    RSQB                    ']'\\n    COLON                   ':'\\n    COMMA                   ','\\n    SEMI                    ';'\\n\\n和 `Grammar` 文件一样，如果你修改了 `Grammar/Tokens` 文件，你需要重新运行 `pgen`。\\n\\n要查看操作中的标记，你可以使用 CPython 中的 `tokenize` 模块。\\n\\n> CPython 源代码中有两个标记器。这里演示了一个用 Python 编写的分词器，另一个用 C 编写。 用 Python 编写的分词器是一个实用程序，Python 解释器使用用 C 编写的那个。 它们具有相同的输出和行为。用 C 编写的版本是为性能而设计的，而 Python 中的模块是为调试而设计的。\\n\\n`cpython-book-samples/13/test_tokens.py`:\\n\\n```\\n\\ndef my_function(): proceed\\n```\\n\\n将 `test_tokens.py` 文件输入到标准库中内置的名为 `tokenize` 的模块中。你将按行和字符看到标记列表。 使用 `-e` 标志输出确切的标记名称：\\n\\n    $ ./python -m tokenize -e test_tokens.py\\n\\n    0,0-0,0:            ENCODING       'utf-8'        \\n    1,0-1,18:           COMMENT        '# Demo application'\\n    1,18-1,19:          NL             '\\\\n'           \\n    2,0-2,3:            NAME           'def'          \\n    2,4-2,15:           NAME           'my_function'  \\n    2,15-2,16:          LPAR           '('            \\n    2,16-2,17:          RPAR           ')'            \\n    2,17-2,18:          COLON          ':'            \\n    2,18-2,19:          NEWLINE        '\\\\n'           \\n    3,0-3,4:            INDENT         '    '         \\n    3,4-3,11:           NAME           'proceed'      \\n    3,11-3,12:          NEWLINE        '\\\\n'           \\n    4,0-4,0:            DEDENT         ''             \\n    4,0-4,0:            ENDMARKER      ''\\n\\n在输出中，第一列是行/列坐标的范围，第二列是标记的名称，最后一列是标记的值。\\n\\n在输出中， `tokenize` 模块隐含了一些标记：\\n\\n*   `utf-8` 的 `ENCODING` 标记\\n*   结尾的空白行\\n*   `DEDENT` 关闭函数声明\\n*   `ENDMARKER` 结束文件\\n\\n最佳做法是在 Python 源文件的末尾有一个空行。如果省略它，CPython 会为你添加它。\\n\\n`tokenize` 模块是用纯 Python 编写的，位于 `Lib/tokenize.py` 中。\\n\\n要查看 C 分词器的详细读数，您可以使用 `-d` 标志运行 Python。 使用之前创建的 `test_tokens.py` 脚本，使用以下命令运行它：\\n\\n    $ ./python -d test_tokens.py\\n\\n    Token NAME/'def' ... It's a keyword\\n     DFA 'file_input', state 0: Push 'stmt'\\n     DFA 'stmt', state 0: Push 'compound_stmt'\\n    ...\\n    Token NEWLINE/'' ... It's a token we know\\n     DFA 'funcdef', state 5: [switch func_body_suite to suite] Push 'suite'\\n     DFA 'suite', state 0: Shift.\\n    Token INDENT/'' ... It's a token we know\\n     DFA 'suite', state 1: Shift.\\n    Token NAME/'proceed' ... It's a keyword\\n     DFA 'suite', state 3: Push 'stmt'\\n    ...\\n    ACCEPT.\\n\\n在输出中，你可以看到它突出显示了作为关键字的 `proceed`。 在下一章中，我们将看到执行 Python 二进制文件是如何到达分词器的，以及从那里执行代码时会发生什么。\\n\\n> 要清理你的代码，请恢复 `Grammar/Grammar` 中的更改，再次重新生成语法，然后清理构建并重新编译：\\n>\\n> 对于 macOS 或 Linux：\\n>\\n>     > $ git checkout -- Grammar/Grammar\\n>     > $ make regen-grammar\\n>     > $ make clobber\\n>     > $ make -j2 -s\\n>     >\\n\\n> 对于 Windows：\\n>\\n>     > > git checkout -- Grammar/Grammar\\n>     > > build.bat --regen\\n>     > > build.bat -t CleanAll\\n>     > > build.bat -t Build\\n>     >\\n\\n## 一个更复杂的例子\\n\\n添加 `proceed` 作为 `pass` 的替代关键字是一个简单的更改， 解析器生成器将 `'proceed'` 作为 `pass_stmt` 标记的文字进行匹配。 这个新关键字无需对编译器进行任何更改即可工作。\\n\\n在实践中，对语法的大多数更改都更加复杂。\\n\\nPython 3.8 引入了赋值表达式，格式为 `:=`。赋值表达式既为名称赋值，又返回命名变量的值。 受在 Python 语言中添加赋值表达式影响的语句之一是 `if` 语句。\\n\\n在 3.8 之前，`if` 语句定义为：\\n\\n*   关键字 `if` 后跟 `test`，然后是 `:`\\n*   嵌套的一系列语句（`suite`）\\n*   零个或多个 `elif` 语句，后跟 `test`、一个 `:` 和 `suite`\\n*   一个可选的 `else` 语句，后跟一个 `:` 和一个 `suite`\\n\\n在语法中，这表示为：\\n\\n    if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\\n\\n可视化之后看起来像：\\n\\n为了支持赋值表达式，更改需要向后兼容。 因此，在 `if` 语句中使用 `:=` 必须是可选的。\\n\\n`if` 语句中使用的 `test` 标记类型在许多语句之间是通用的。例如，`assert` 语句后跟一个 `test`（然后是可选的第二个 `test`）。\\n\\n    assert_stmt: 'assert' test [',' test]\\n\\n在 3.8 中添加了替代 `test` 标记类型，以便语法可以规定哪些语句应该支持赋值表达式，哪些不应该支持。\\n\\n这个称为 `namedexpr_test`，在 `Grammer` 中定义为：\\n\\n    namedexpr_test: test [':=' test]\\n\\n或者，在铁路图中可视化为：\\n\\n![namedexpr_test](https://user-images.githubusercontent.com/3297411/130769573-78634152-1b47-4ee8-9ca7-2f6b6e3ff4a1.png)\\n\\n`if` 语句的新语法已更改为用 `namedexpr_test` 替换 `test`：\\n\\n    if_stmt: 'if' namedexpr_test ':' suite ('elif' namedexpr_test ':' suite)\\n            ['else' ':' suite]\\n\\n在铁路图中可视化：\\n\\n![if_stmt_with_namedexpr_test](https://user-images.githubusercontent.com/3297411/130769666-b253d126-ab60-4eb5-8dd6-8e7ca3988282.png)\\n\\n为了区分 `:=` 和现有的 `COLON` (`:`) 和 `EQUAL` (`=`) 标记，将以下标记也添加到 `Grammar/Tokens` 中：\\n\\n    COLONEQUAL              ':='\\n\\n这不是支持赋值表达式所需的唯一更改。 如 [Pull Request](https://github.com/python/cpython/pull/10497) 中所示，这一变化改变了 CPython 编译器的许多部分。\\n\\n> 有关 CPython 解析器生成器的更多信息，`pgen` 的作者在 PyCon Europe 2019 上录制了 有关实现和设计的演示文稿：“[野兽之魂](https://www.youtube.com/watch?v=1\\\\_23AVsiQEc)”。\\n\\n## 总结\\n\\n在本章中，你已经了解了 Python 语法定义和解析器生成器。 在下一章中，你将扩展该知识以构建更复杂的语法功能，即“几乎等于”运算符。\\n\\n在实践中，必须仔细考虑和讨论对 Python 语法的更改。审查水平有两个原因：\\n\\n1.  拥有“太多”的语言特性或复杂的语法会改变 Python 作为一种简单易读的语言的精神\\n2.  语法更改引入向后不兼容，这给所有开发人员增加了工作\\n\\n如果 Python 核心开发人员提议对语法进行更改，则必须将其作为 Python 增强提案 (PEP) 提出。 所有 PEP 都在 PEP 索引上进行编号和索引。 [PEP 5](https://www.python.org/dev/peps/pep-0005/) 记录了语言发展的指南，并指定必须在 PEP 中提出更改。\\n\\n成员还可以通过 [python-ideas 邮件列表](https://www.python.org/community/lists/)建议对核心开发组之外的语言进行更改。\\n\\n你可以在 [PEP 索引](https://www.python.org/dev/peps/)中查看 CPython 未来版本的起草的、拒绝的和接受的 PEP。 一旦 PEP 达成共识，并且草案已定稿，指导委员会必须接受或拒绝它。 [PEP 13](https://www.python.org/dev/peps/pep-0013/) 中定义的指导委员会的任务规定， 他们应努力“维护 Python 语言和 CPython 解释器的质量和稳定性”。\\n\\n###\\n\",\"timestamp\":1635906725,\"title\":\"CPython Internals 笔记 ── Python 语言和语法\"},\"digest\":\"rjwQ7jbcZCD6A_xqoCet65i-MM9KEI7oJ325VR11OKE\",\"authorship\":{\"contributor\":\"0x169841AA3024cfa570024Eb7Dd6Bf5f774092088\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"OwWEp14D01R3fGHRiDauX-UY9D4ixdAt3AqqGIAqtYw\\\",\\\"y\\\":\\\"BahyRmdDiDMXskqMIKUoo3beTS-0Vg7qzBY_mhLsNg0\\\"}\",\"signature\":\"AI47bHACR9foXS8eMOylPFx5viuyS4hnQAji9_OyP6yOgS8fHsIDFYU1KJLq7DcuYprGbv5XAnXE8GS6veOmuw\",\"signingKeySignature\":\"0xff0495e4da663477b2d0ff1bd8f2eed1efb13adcc8980ca4808a941cb990f1de3ecd421860998e36d84d115a0bca426faf446f592505a03a04603a1e08170a761b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"OwWEp14D01R3fGHRiDauX-UY9D4ixdAt3AqqGIAqtYw\\\",\\\"y\\\":\\\"BahyRmdDiDMXskqMIKUoo3beTS-0Vg7qzBY_mhLsNg0\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"rjwQ7jbcZCD6A_xqoCet65i-MM9KEI7oJ325VR11OKE\"}"