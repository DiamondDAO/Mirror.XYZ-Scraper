"{\"content\":{\"body\":\"This was buried in discord and will likely eventually make it into the UMA voting front-end, but for now wanted an easily referenced document. This is a technical guide on how to run validation on [IS_RELAY_VALID](https://github.com/UMAprotocol/UMIPs/blob/master/UMIPs/umip-136.md) requests in the UMA Protocol  \\n  \\n You can read more about UMA Protocol [here](https://docs.umaproject.org/) and more specifics around the voting process [here](https://docs.umaproject.org/uma-tokenholders/uma-holders) \\n _ *_ _ _ _ _ _ _ _ _ _ _ _* _ *_ _ _ _ _ _ _ _ _ _ _ _*\\n\\n### Dependencies:\\n\\nThese instructions are specific to OSX, and should work on \\\\*nix systems. If you happen to be a Windows developer and would like me to add to this, please reach out\\n\\nYou will need the following:\\n\\n* Node v14+ \\n* yarn\\n* XCode Command Line Tools (to support project dependencies)\\n\\n### Setup\\n\\nFirst, you’ll need to clone the UMA Protocol repository to your local environment.\\n\\n`git clone git@github.com:UMAprotocol/protocol.git` \\n\\nThen move into the cloned directory, install node packages: \\n `yarn` \\n\\nNext you will need to build the contracts using the quick build node script: \\n `yarn qbuild` \\n\\n### Configuration\\n\\ndotenv is used for environment variables, in this example the following values should be added to `.env` in the project directory to specify the nodes to connect to, example using  infura nodes:\\n\\n```\\nCUSTOM_NODE_URL=https://mainnet.infura.io/v3/<YOURPROJECTID>\\nNODE_URL_42161=https://arbitrum-mainnet.infura.io/v3/<YOURPROJECTID>\\n```\\n\\nAlternatively, you can use public RPC URLs from the [rpc.info list](https://rpc.info/) (Less secure)\\n\\n### Checking the disputed price request\\n\\nOnce the project is set up, from the root of the `protocols` directory you will want to capture the `Proposal`, `Ancillary Data (raw hexstring)` and `Proposal Timestamp` from [vote.umaproject.org](https://vote.umaproject.org/) on the proposal in question, then run the `getHistoricalPrice.js` script with those details :\\n\\n```\\nHARDHAT_NETWORK=mainnet \\\\\\nnode ./packages/scripts/src/local/getHistoricalPrice.js \\\\\\n--network mainnet \\\\\\n--identifier <Proposal, ex: IS_RELAY_VALID> \\\\\\n--time <UTC timestamp, ex: 1638976595>\\n--ancillaryData <Ancillary Data (raw), ex: 0x72656c6179486173683a633562366430353036326230393730643239643661393565353065646436383336633036653465613931626338343432626365616166663933363339363562322c6f6f5265717565737465723a37333535656663363361653733316635383433383061393833383239326337303436633165343333>\\n```\\n\\nRunning this command with the example values above:\\n\\n```\\nHARDHAT_NETWORK=mainnet node ./packages/scripts/src/local/getHistoricalPrice.js --network mainnet --identifier IS_RELAY_VALID --time 1638976595 --ancillaryData 0x72656c6179486173683a633562366430353036326230393730643239643661393565353065646436383336633036653465613931626338343432626365616166663933363339363562322c6f6f5265717565737465723a37333535656663363361653733316635383433383061393833383239326337303436633165343333\\n```\\n\\nThis script will return **0** or **1**, for **NO**/**YES** on whether the relay is valid. In the example above, we received a **0** so should validate the output and vote `NO`.\\n\\nThe `getHistoricalPrice.js` script mimics how the relayer bot works, but utilizes the ancillary data, which the relayer bot does not use at all.\\n\\n* First, the script tries to find a matching `DepositRelayed` event across all BridgePools, matching the event’s `relayAncillaryDataHash` field with the parsed ancillaryData  from the `SkinnyOptimisticOracle` event. We use the handy parseAncillaryData library to deconstruct the ancillary data into a relayHash\\n* If the relay is found, next we need to find a `FundsDeposited` where the depositHash matches the deposit hash in the matched relay from the previous step. **Note that this step can fail if you’re connecting to an unexpected L2. For example, setting your node to Optimism but the deposit actually occurred on Arbitrum**\\n* Finally, if the relay and the deposit is found, we just need to validate the relay params. There is only one param to validate: the `realizedLpFeePct`, so we use the same library that the bot and the front-end use to compute this and compare the relay’s fee set with the expected value for the deposit.quoteTime.\",\"timestamp\":1639033137,\"title\":\"UMA - IS_RELAY_VALID procedure\"},\"digest\":\"I2pQsQNjB4N6X4Z1s_vv5xRlDAs_s-i_RK7kL0nNCJY\",\"authorship\":{\"contributor\":\"0x11451a541b1F9B6F02B857b82e7C03AC362f9067\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"mSProWVypCYwbo7w0EJExP8_xEYRnXY3uWarPADEjrc\\\",\\\"y\\\":\\\"KGsaMrvVjMzrIgXN4zZa0zkp7Eymg4OvwiJCtbG6ScI\\\"}\",\"signature\":\"osQWiukjlBoo24A5Alrf60eo242-CworYjko2RkE-r__AfVQJv7E8_eqNkxxo_fI9NKMcumzqGCRAfWhtHsBaA\",\"signingKeySignature\":\"0xdb4b4d4318f8481144b165cd85f86221c8d468b64405b93f2af4cdbc43350ab337b988ac4209f1178dae1f4526ba8ec9a0fd5649369fee7e874dca8a36b5b40f1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"mSProWVypCYwbo7w0EJExP8_xEYRnXY3uWarPADEjrc\\\",\\\"y\\\":\\\"KGsaMrvVjMzrIgXN4zZa0zkp7Eymg4OvwiJCtbG6ScI\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"I2pQsQNjB4N6X4Z1s_vv5xRlDAs_s-i_RK7kL0nNCJY\"}"