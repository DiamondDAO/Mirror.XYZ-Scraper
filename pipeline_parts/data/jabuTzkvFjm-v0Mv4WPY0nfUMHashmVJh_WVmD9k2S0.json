"{\"content\":{\"body\":\"My 15 year old son bears a striking resemblance to [Crypto Punk #2101](https://www.larvalabs.com/cryptopunks/details/2101). For his birthday, I’d like to get him a high quality, framed print of #2101 that he can showcase proudly in his room. Unfortunately, the original punk images are only available at a very low resolution and aren’t printshop ready. In this post, I’ll show how to upscale a low-rez image using Python, Tensorflow and Keras so the images will be ready for printing at 300 Dots per Inch (DPI).\\n\\nFirst, load punk #2101 into memory and take a look.\\n\\n```\\nimport cryptopunks.utils as cp\\nimg = cp.get_punk(2101)\\nplt.imshow(img) \\n```\\n\\n![Punk #2101](https://images.mirror-media.xyz/publication-images/DNiByP6JDy05vaFE8uhgS.png?height=248&width=251)\\n\\n## Upsampling images with Keras and UpSampling2d\\n\\nThe Keras library for building deep neural networks provides a layer that is useful for increasing the resolution of images. Upsampling2d takes a multidimensional array as input and doubles each pixel value in the input resulting in an output image that is twice the size.\\n\\nWe can use this layer to repeatedly upsample the 24 x 24  cryptopunks until we have an image of the size we want. For print quality, we’ll need 300 Dots per Inch (DPI), so, if we want a 10 X 10 inch image, we’ll need to upscale the punks to be size 3000 x 3000. We can do this with a simple Keras network like the following …\\n\\n```\\nmodel = keras.Sequential()\\nmodel.add(layers.UpSampling2D(input_shape=(24, 24, 4)))\\nmodel.add(layers.UpSampling2D(input_shape=(48, 48 , 4)))\\nmodel.add(layers.UpSampling2D(input_shape=(192, 192, 4)))\\nmodel.add(layers.UpSampling2D(input_shape=(384, 384, 4)))\\nmodel.add(layers.UpSampling2D(input_shape=(768, 768, 4)))\\nmodel.add(layers.UpSampling2D(input_shape=(1536, 1536, 4)))\\nmodel.summary()\\n```\\n\\nTake a look at the network shape using the `summary` method of `model`.\\n\\n```\\nModel: \\\"sequential_8\\\"\\n_______________________________________________________________\\nLayer (type)                 Output Shape              Param #   \\n===============================================================\\nup_sampling2d_31 (UpSampling (None, 48, 48, 4)         0         \\n_______________________________________________________________\\nup_sampling2d_32 (UpSampling (None, 96, 96, 4)         0         \\n_______________________________________________________________\\nup_sampling2d_33 (UpSampling (None, 192, 192, 4)       0         \\n_______________________________________________________________\\nup_sampling2d_34 (UpSampling (None, 384, 384, 4)       0         \\n_______________________________________________________________\\nup_sampling2d_35 (UpSampling (None, 768, 768, 4)       0         \\n===============================================================\\nup_sampling2d_35 (UpSampling (None, 1536, 1536, 4)       0        \\n===============================================================\\nTotal params: 0\\nTrainable params: 0\\nNon-trainable params: 0\\n```\\n\\nNote that this model doesn’t have any parameters; it’s not a typical Keras model that must be trained on data before it can predict. The model is ready to make predictions, that is, it will `predict` a new images of size 3072 x 3072.\\n\\n```\\nX_ = img.reshape((1,24,24,4))\\nY = model.predict(X_)\\nplt.imshow(y[0])\\n```\\n\\n![Upscaled Punk](https://images.mirror-media.xyz/publication-images/cVufyfLERN-FjfxLAyn5T.png?height=3072&width=3072)\\n\\nThat’s it. The upscaled punk image is print ready and will make a nice 10in X 10in print at 300DPI. While this is a round about way of getting images print-ready, it avoids the need to introduce another image processing library and is completely programmable, that is, going from 1 to 10,000 upscale punks is as simple as a `for` loop.\\n\\nFWIW, I’d also like to be able to buy my son the actual #2101 NFT, but at a 500K valuation, I’m completely comfortable with the simulacra. \",\"timestamp\":1642293485,\"title\":\"Punks for Printers\"},\"digest\":\"Pa1G1sYoJJTy_E1gjI3L2cl4wXi-HbDey3_MyB8YvIM\",\"authorship\":{\"contributor\":\"0x9C65AC91C38598D95099068C0634a5d3276de51c\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"uTo-zzNZiG1UU0QhECGvDLBWkwidN4TOTZkEQ8FMQrM\\\",\\\"y\\\":\\\"xvGTTHcFO5M8d8cW-bhvftuKsNDR3wb16VB4ZtBmQKo\\\"}\",\"signature\":\"7EcxHr0zuajMaOuVZKzDo9P9iE8bR1V0hZrKn9FTNBImfFUqiPz3QVvjCD_hZx_KG-XWHS4yE729OrICmRnalA\",\"signingKeySignature\":\"0xd63a0412df04b89c4661d0e68a3b48e379b93f482d4344eff64242fe55d03ea33c8e894a5690f451a2eec40dffdbe1eda23c269d2ebc1be86d3ae94c19e740ae1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"uTo-zzNZiG1UU0QhECGvDLBWkwidN4TOTZkEQ8FMQrM\\\",\\\"y\\\":\\\"xvGTTHcFO5M8d8cW-bhvftuKsNDR3wb16VB4ZtBmQKo\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"JsnjqU2EIBupwds8MJLLaCAXGSCKU6PCxi6IZvDxur4\"}"