"{\"content\":{\"body\":\"Filecoin：一种去中心化的存储网络\\n\\n协议实验室\\n\\n2017年8月14日\\n\\n**摘要**\\n\\n互联网正处于一场革命当中：中心化专有服务正在被去中心化开放式服务所取代；可信中心被可验证计算取代；脆弱的位置地址被弹性内容地址所取代；低效的整体式服务被点对点算法市场所取代；比特币、以太坊和其他的区块链网络已经证明了去中心化交易账本的有效性。\\n\\n这些公共账本，处理复杂的智能合约应用程序，并且交易价值数百亿美金的加密货币资产。参与者形成一个提供有效支付服务的、没有中心化管理，或信任中心的去中心化网络，这些系统是互联网开放服务的第一个实例。\\n\\nIPFS根据去中心化网络自身已经证实了内容寻址的有效性，即在全球点对点网络上提供数十亿文件使用的服务。它解放孤岛数据、留活网络分区、脱机工作、绕开审查并且给予了数字信息永久性。\\n\\nFilecoin是一个去中心化的存储网络，它让云存储变身成了一个算法市场。这个市场基于一个本地协议通证（也叫Filecoin）来运行，在这里矿工们可以通过向客户提供存储获取Filecoin。\\n\\n反过来，客户花费Filecoin雇佣矿工们来存储或分发数据。和比特币一样，Filecoin矿工们为了可观的奖励而竞争挖区块，但是Filecoin的挖矿功率是和有效存储成比例的，即直接为客户提供有用的服务（这里不像比特币挖矿仅限于维护区块链的共识）。\\n\\n这种设计为矿工们提供了巨大的激励，使他们尽可能的集聚存储以便出租给客户。\\n\\nFilecoin协议将这些集聚来的资源，编织成一个世界上任何人都可以依靠的、自我修复存储网络。\\n\\n这个网络通过复制和分散内容实现稳健型，同时自动检测与修复复制品故障。客户可以选择复制参数，来针对不同的威胁进行保护。Filecoin协议的云存储网络是一个安全的网络，因为内容在客户端是端到端加密的，而存储提供者并不能访问到解密的秘钥。\\n\\nFilecoin是运行在可以为任何数据提供存储基础设施的IPFS之上的激励层。它对去中心化数据，构建及运行分布式应用程序，以及实现智能合约具有巨大的作用。\\n\\n**这些工作包括：**\\n\\n**·**  介绍Filecoin网络，概述这个协议以及详细介绍几个组件。\\n\\n**·**  形式化去中心化存储网络（DSN）的方案和属性，然后**将Filecoin构造为DSN**。\\n\\n**·**  介绍一种叫做**复制证明的新型存储证明方案**，它将可以证明任何数据副本都存储在实际的独立存储器中。\\n\\n**·**  介绍一种新型的**基于有序复制证明和存储之上的有效工作共识**，以作为功率的一种衡量方式。\\n\\n**·**  形式化可验证市场，并构建**存储市场**和**检索市场**，它们将分别管理如何从Filecoin写入和读取数据。\\n\\n**·**  讨论实例，与其他系统的连接，以及如何使用这个协议。\\n\\n注意：Filecoin是一项正在进行中的工作。目前正在进行积极的研究，本文新的版本将出现在https://filecoin.io. 如有意见和建议，请发送电子邮件至research@filecoin.io.\\n\\n**目录**\\n\\n1\\\\. 介绍 5\\n\\n1\\\\.1. 基本组件 5\\n\\n1\\\\.2. 协议概述 5\\n\\n1\\\\.3. 论文组织 6\\n\\n2\\\\. 去中心化存储网络的定义 9\\n\\n2\\\\.1. 故障容错 9\\n\\n2\\\\.2. 属性 10\\n\\n3\\\\. 复制证明和时空证明 11\\n\\n3\\\\.1. 动机 11\\n\\n3\\\\.2. 复制证明 11\\n\\n3\\\\.3. 时空证明 12\\n\\n3\\\\.4. PoRep和PoSt的实际应用 12\\n\\n3\\\\.5. 在Filecoin中的运用 15\\n\\n4\\\\. Filecoin：一个DSN架构 17\\n\\n4\\\\.1. 设置 17\\n\\n4\\\\.2. 数据结构 18\\n\\n4\\\\.3. 协议 18\\n\\n4\\\\.4. 保证和要求 23\\n\\n5\\\\. Filecoin存储和检索市场 26\\n\\n5\\\\.1. 可验证市场 26\\n\\n5\\\\.2. 存储市场 26\\n\\n5\\\\.3. 检索市场 29\\n\\n6\\\\. 有用的工作共识 32\\n\\n6\\\\.1. 动机 32\\n\\n6\\\\.2. Filecoin共识 32\\n\\n7\\\\. 智能合约 36\\n\\n7\\\\.1. Filecoin中的合约 36\\n\\n7\\\\.2. 与其他系统的集成 36\\n\\n8\\\\. 未来的工作 37\\n\\n8\\\\.1. 正在进行的工作 37\\n\\n8\\\\.2. 开放性问题 378.3. 证明和正式验证 37\\n\\n**图表清单**\\n\\n图 1 Filecoin协议草图 7\\n\\n图 2 Filecoin协议插图 8\\n\\n图3 PoSt.Prove的基础机制图示 15\\n\\n图4 复制证明和时空证明的协议草图 16\\n\\n图5 DSN方案中的数据结构 18\\n\\n图6 Filecoin DSN的执行示例 22\\n\\n图7 Filecoin DSN中Put和Get协议的描述 24\\n\\n图8 Filecoin DSN中Manage协议的描述 25\\n\\n图9 可验证市场的通用协议 26\\n\\n图10 存储市场和检索市场的订单数据结构 28\\n\\n图11 详细的存储市场协议 30\\n\\n图12 详细的检索市场协议 31\\n\\n图13 在期望共识协议中的领袖选举 35\\n\\n1\\n\\n**介绍**\\n\\nFilecoin是一种协议通证，它的区块链运行在一种叫做“时空证明”的新型证明机制上，它的区块将被存储数据的矿工挖掘。Filecoin协议不依赖于单个协调和独立存储提供者组成的网络来提供数据存储和检索服务，其中：\\n\\n(1) 用户为数据存储和检索支付通证，\\n\\n(2) 存储矿工通过提供存储空间赚取通证，\\n\\n(3) 检索矿工提供数据服务赚取通证。\\n\\n**1.1.基本组件**\\n\\nFilecoin协议建立在四个新型组件之上。\\n\\n**去中心化存储网络（DSN）**：我们提供一个由独立存储提供者组成的网络的抽象概念，以便于它们提供存储和检索服务（见第2章）。接着我们将Filecoin作为一个可激励的、可审计并且可验证的DSN构架来展示（见第4章）。\\n\\n**新型的存储证明**：我们提出两种新型的存储证明（见第3章）：**(1) 复制证明**允许存储提供者，证明数据确实被复制到了其独特的专用物理存储设备上。强制执行独特的物理副本，使验证者可以检验证明者不是在同一个存储空间中将多个数据副本重复删除；**(2)时空证明**允许存储提供者证明他们在指定的时间内持续存储了某些数据。\\n\\n可验证市场：我们将存储请求和检索请求建模成由Filecoin网络操作的两个去中心化的可验证市场内的订单（见第5章）。可验证市场确保了当一种服务被正确提供的时候，相应的款项会被支付。我们展示的存储市场和检索市场中，矿工和客户可以分别地提交存储订单和检索订单。\\n\\n有效的工作证明：我们展示了如何基于“时空证明”来构建一个有效的工作证明来应用于共识协议之中。矿工将不再需要花费不必要的计算资源来挖掘区块，而是必须在网络中存储数据。\\n\\n**1.2.协议概述**\\n\\nFilecoin协议是一个构建在区块链和本地通证之上的去中心化存储网络。用户为存储和检索数据花费通证，矿工以存储和提供数据赚取通证。\\n\\nFilecoin的DSN通过两个可验证的市场来分别处理存储和检索请求：即存储市场和检索市场。用户和矿工为所要求的和提供的服务设定价格，并将订单提交到市场上。\\n\\n市场由采用了时空证明和复制证明的Filecoin网络来操作，以确保矿工准确无误地存储他们承诺存储的数据。\\n\\n最后，矿工可以参与区块链中新区块的创造中。一个矿工对下一个区块的影响力与它在网络中当前存储的使用量成正比。\\n\\n图1是使用了特定术语的Filecoin协议草图，这些术语将会在本文后面阐述，图2是一个例子。\\n\\n**1.3.论文组织**\\n\\n本文的其余内容安排如下：\\n\\n我们将在第2章中阐述一个理论上的DSN方案的定义与要求。\\n\\n在第3章中，我们将会刺激、定义并且展示我们的复制证明和时空证明协议，他们将在Filecoin系统中用加密的方式保证数据按照订单的要求被持续不断地存储。\\n\\n第4章则描述了Filecoin DSN的具体事例，包括描述数据结构、协议以及参与者之间的相互作用。\\n\\n第5章将定义及描述了可验证市场的概念，包括了存储市场和验证市场是如何实施的。\\n\\n第6章为演示及评估矿工对网络的贡献描述了时空证明协议的使用情况，这对扩展区块链以及分配奖励区块是必要的。\\n\\n第7章则提供了Filecoin智能合约的简要介绍。\\n\\n第8章则以对未来工作的讨论结束。\\n\\n图1是使用了特定术语的Filecoin协议草图\\n\\n\\\\*\\\\*图 2 Filecoin协议插图，展示了客户和矿工之间的互动。\\\\*\\\\*此图分别在上面和下面展示了存储检索市场和区块链，随着时间推进从左侧的订单匹配阶段过渡到右侧的结算阶段。请注意，在为检索进行小额支付之前，用户必须为小额支付锁定资金。\\n\\n2\\n\\n**去中心化存储网络的定义**\\n\\n我们介绍了去中心化存储网络（DSN）方案的概念。DSNs聚集了多个独立存储供应商提供的存储空间，并且它能自我协调，以对用户提供数据存储和检索服务。这种协调是去中心化并且不需要信任方的：即通过协议调节及验证个体方的操作，来达到安全操作整个系统的目的。DSNs可以根据系统的需求采用不同的调节策略，包括拜占庭协议、流言协议以及无冲突可复制数据类型（CRDTs）。在后面的第4章中，我们将会提供一个Filecoin DSN的架构。\\n\\n定义 2.1. 一个DSN方案 II是一个由存储供应商和客户运行的协议元组：\\n\\n**（Put, Get, Manage）**\\n\\n**Put (data) → key**：客户执行Put协议在唯一的标识秘钥下存储数据。\\n\\n**Get (key) → data**：客户执行Get协议用秘钥检索当前存储的数据。\\n\\n**Manage ()**：网络的参与中通过Manage协议来进行协调：即控制可用的存储，审核供应商提供的服务，以及修复可能出现的故障。Manage协议常常由存储提供商联合客户或者审计网络一同运行。\\n\\n一个DSN方案 II 必须确保数据的完整性和可回收性，并且能够容许下面这些管理和存储上的故障。\\n\\n**2.1故障容错**\\n\\n**2.1.1.管理故障**\\n\\n我们将管理故障定义为由Manage协议中参与者引起的拜占庭故障。一个DSN方案依赖于它Manage协议的故障容错性。违反故障容错性的管理故障假设会对系统的活跃度和安全性进行妥协。\\n\\n例如，考虑一个DSN方案II ，其中Manage协议需要拜占庭协议来审核存储供应商。在这样的协议中，网络接收存储供应商提供的存储证明并运行拜占庭协议来对这些证明的有效性达成共识。如果在 f＜n/2 个所有节点之中，拜占庭协议能容许最多个故障节点，那么我们的DSN可以容许个故障节点。在违反这些假设的情况下，审计上就要做出妥协。\\n\\n**2.2.2.可恢复性**\\n\\n该属性满足了以下要求：给定我们的II容错假设，如果数据被成功地存储在了 II，并且存储供应商继续遵循协议，那么用户最终可以检索数据。\\n\\n\\\\*\\\\*定义 2.3.\\\\*\\\\*一个DSN方案II可以提供数据完整性如果：对任意成功的数据下私钥的Put操作，存在一个 Get操作成功的客户针对私钥检索数据的。\\n\\n**2.2.3其他属性**\\n\\n\\\\*\\\\*定义2.4.\\\\*\\\\*一个DSN方案 II是可以公开验证的，如果：对于每一个成功的Put操作，存储网络供应商可以生成当前正在被存储的数据证明。存储证明必须能够说服任意的知晓私钥但不能访问数据的有效验证者。\\n\\n**定义 2.5.** 一个DSN方案 ∏ 是可以审查的，如果它生成了可验证的操作轨迹，并且在未来的时间点上，能够确认数据当时确实在正确的时间线内被存储了。\\n\\n**定义 2.6.** 一个DSN方案 ∏ 具备可兼容激励性，如果：存储供应商由于成功提供了存储和检索服务而获得了奖励，或者因为作弊而受到惩罚，这样的存储供应商的优势策略是存储数据。\\n\\n3\\n\\n**复制证明和时空证明**\\n\\n在Filecoin协议中，存储供应商必须让他们的客户相信，客户付费的数据已经被他们存储了；在实践中，存储供应商将生成存储证明供给区块链网络，或者客户自己来进行验证。\\n\\n在这一章中，我们将会介绍并勾勒出复制证明和时空证明的实现方案。\\n\\n**3.1动机**\\n\\n存储证明（POS）方案类似“数据持有性验证”（PDP）和“可恢复性验证”（POR）【3,4】方案。它允许一个将数据外包服务器（既证明人P）的用户（既验证者V）可以反复检查服务器是否依然存储数据D。用户可以用比下载数据还高效的方式来验证他外包给服务器的数据的完整性。服务器通过对一组随机数据进行采样和提交小量数据来生成拥有的概率证明作为给用户的响应协议。\\n\\nPDP和PoR方案只是保证了证明人在响应的时候拥有某些数据。在Filecoin中，我们需要更强大的保障能阻止作恶矿工利用不提供存储却获得奖励的三种类型攻击：女巫攻击（Sybil attack）、外包攻击（outsourcing attacks）、代攻击（generation attacks）。\\n\\n**女巫攻击**：作恶矿工可能通过创建多个女巫身份来假装存储（并且获得奖励）了很多份物理存储副本，但实际上只存储了一份。\\n\\n**外包攻击**：依赖于可以从其他存储供应商处快速获取数据，作恶矿工可能承诺存储比他们实际物理存储容量大得多的数据。\\n\\n**生成攻击**：作恶矿工可能会宣称要存储大量的数据，但他们反而使用小程序有效地生成请求。如果这个小程序小于所宣称要存储的数据，那么作恶矿工在赢取Filecoin区块的可能性上就增加了，因为可能性是与矿工当前使用中的存储成正比的。\\n\\n**3.2 复制证明**\\n\\n“复制证明”（PoRep）是一个新型的存储证明。它允许服务器（既证明人P）说服用户（既验证者V）一些数据D已被复制到它唯一的专用物理存储上了。我们的方案是一种交互式协议。证明者P：(a)承诺存储数据D的n个不同的副本（独立物理副本），然后（b）通过一个挑战/响应协议来说服验证者V，P确实已经存储了每个副本。据我们所知，PoRep改善了PDP和PoR方案，阻止了女巫攻击、外包攻击、代攻击。\\n\\n请注意，对于复制证明正式的定义以及其属性的描述和它的深入研究，我们推荐阅读者阅读协议实验室的另一份学术报告。\\n\\n**定义3.1(复制证明**）PoRep方案使得一个有效的证明人P能说服验证者V，数据D的专属于P的、一个独立物理副本R已被存储在P上。PoRep协议其特征是多项式时间算法的元组：（Setup,Prove,Verify）\\n\\n\\\\*\\\\*PoRep.Setup(1λ,D)\\\\*\\\\*→R,Sp，Sv,其中Sp和Sv是P和V的特点方案的设置变量，λ是一个安全参数。PoRep.Setup用来生成副本R，并且给予P和V必要的信息来运行PoRep.Prove和PoRep.Verify。一些方案可能要求证明人或者是有互动的第三方去运算PoRep.Setup。\\n\\n\\\\*\\\\*PoRep.Verify(Sp,R,C)\\\\*\\\\*→πc，其中C是验证人V发出的随机验证，πc是证明者产生的对于数据D的特定副本R的访问权的证明。PoRep.Prove由P（证明者）为V（验证者）运行生成πc。\\n\\n\\\\*\\\\*PoRep.Verify(Sv,c,πc)\\\\*\\\\*→{0,1},用来检测证明是否是正确。PoRep.Verify由V运行B并且说服V：P已经存储了R。\\n\\n**3.3.时空证明**\\n\\n时空证明方案，允许用户检测在挑战期间存储供应商是否存储了外包数据。��们如何使用PoS方案来证明数据在于短时间内被存储了呢？对这个问题的一个自然的回答是要求用户重复（如每分钟）对存储供应商发出挑战。然而，每次交互所需要的通讯复杂程度将会成为类似Filecoin这类系统的瓶颈，因为存储供应商也会被要求提交他们的证明到区块链网络。\\n\\n为了回答这个问题，我们引出一种新的证明，时空证明，其中验证者可以检验在一段时间内证明者是否存储了他/她的外包数据。如此对证明者的要求则是 (1)生成顺序的存储证明（在这里是复制证明），来作为一种 (2)递归执行生成简短证明的确定时间的方法。\\n\\n**定义3.2**（时空证明）PoSt方案使得有效的证明者P能够说服验证者V：在一段时间t内，P已经存储了一些数据D。PoSt协议的特征是多项式时间算法的元组：（Setup，Prove,Verify）\\n\\n\\\\*\\\\*PoSt.Setup(1λ,D)\\\\*\\\\*→Sp,Sv，其中Sp和Sv是P和V的特点方案的设置变量，λ是一个安全参数。PoSt.Setup用来给予P和V必要的信息来运行PoSt.Prove。一些方案可能要求证明人或者是有互动的第三方去运算PoSt.Setup。\\n\\n\\\\*\\\\*PoSt.Prove(Sp,D,c,t)\\\\*\\\\*→πc,其中C是验证人v发出的随机验证，πc是证明人在一段时间内可以访问数据D的证明。PoSt.Prove由P（证明人）为V（验证者）运行生成πc。\\n\\n\\\\*\\\\*PoSt.Verify(Sv,c,t,πc)\\\\*\\\\*→{0,1},用来检测证明是否是正确。PoSt.Verify由V运行和说服V相信P在一段时间内已经存储了t。\\n\\n**3.4.PoRep和PoSt的实际应用**\\n\\n我们对PoRep和PoSt在线用系统中的应用构建感兴趣，而不是依赖于硬件或是信任方。我们给出了一个PoRep的系统架构（详见复制证明学术报告中“以密封为基础的复制证明”），它在Setup过程中需要一个非常慢的顺序计算来密封以生成副本。PoRep和PoSt的协议草图在图4中给出，PoSt底层机制的证明步骤则在图3中。\\n\\n**3.4.1构建加密区块**\\n\\n**防碰撞哈希运算**：我们使用一个防碰撞的哈希函数：CRH：{0,1}\\\\*→{0,1}O(λ)。我们还使用了一个防碰撞hax函数MerkleCRH,它将字符串分割成多个部分，构造出二叉树饼递归应用CRH，然后输出树根。\\n\\nzk-SNARKS:我们的PoRep和Post的实际事实依赖于零知识证明的简洁的非交互式知识论(zk-SNARKs)|6,7,8\\\\]。因为zk-SNARKs是简洁的,所以证明很短并且很容易验证。更正式地,让L成为NP语言,C是L的决策电路。受信任的一方进行次设置阶段,产生两个公共密钥:证明密钥pk和验证密钥wk。证明密钥pk使任何(不可信)的证明者都能产生证明证明π,对于她选择的实例ⅹ,ⅹ∈L。非交互式证明π是零知识和知识证明。任何人都可以使用验证密钥v验证证明π。特别是 zk-SNARK的证明可公开验证:任何人都可以验证π,而不与产生π的证明者进行交互。证明π具有恒定的大小并且可以在|x|中线性的时间内验证。\\n\\n对于zk-SNARKs的流程满足性是多项式时间算法的元组:**(KeyGen,Prove,Verify**）\\n\\n注意：Filecoin是一项正在进行中的工作。目前正在进行积极的研究，本文新的版本将出现在https://filecoin.io. 如有意见和建议，请发送电子邮件至research@filecoin.io.\\n\\n\\\\*\\\\*KeyGen(1λ,C)\\\\*\\\\*→(pk,vk),输入安全参数λ和电路C之上, KeyGen产生概率样本pk和wk。这两个秘钥作为公共秘钥发布,可在Lc中用于证明/验证成员资格。\\n\\n\\\\*\\\\*Prove(pk,x,w)\\\\*\\\\*→π,在输入pk、x和 NP 声明的证人w之上，证明者 Prove 为 声明x∈ Lc，输出一个非交互式的证明。\\n\\n\\\\*\\\\*Verify(vk,x,π)\\\\*\\\\*→{0,1},在输入vk、x以及证明π之上，如果x∈Lc，验证者Verify输出1.\\n\\n我们建议感兴趣的读者参考 \\\\[6\\\\] \\\\[7\\\\] \\\\[8\\\\]，了解zk-SNARK系统的正式介绍和实例。通常来讲，这些系统需要一个信任方来运行 KeyGen 操作；创新的可扩展计算的完整 性和隐私性系统（SCIP）\\\\[9\\\\]展示了在以上假设信任的前提下，为避免这个第一步， 展示了一个有希望的方向。\\n\\n**3.4.2 密封操作**\\n\\n密封操作所扮演的角色是(1) 通过要求证明者存储一个对于他们公钥来说独特的伪随机排列D，强迫复制品成为物理独立副本，这样，承诺存储n个复制品将会导致n个独立副本的专用空间（因此复制品的存储大小是n倍），并且(2)在PoRep.Setup过程中强迫生成副本实质上会花费比预计响应挑战更多的时间。有关密封操作更正式的定义，请参见\\\\[5\\\\]。以上的操作可以用 SealAES−256来实现，并且τ使得 SealAES−256需要花费比诚实的挑战验证证明序列多10-100倍的时间。请注意，选择τ是极为重要的，因为与以随机访问ℛ来运行Prove相比，运行SealBCτ将毫无疑问地更花时间。\\n\\n**3.4.3 密封操作**\\n\\n本章将描述 PoRep 协议的架构，并且在图4中包含了一个简单的协议草图；实现和优化的细节被省略了。\\n\\n**创建副本**：Setup算法通过密封操作生成一个副本并且提供证明。证明者生成副本并将输出（不包括ℛ）发送给验证者。\\n\\n**证明存储**：Prove算法生成对于副本的存储证明。证明者收到来自验证者的随机挑战c， 要求在以rt为树根ℛ的Merkle树中确认特定的叶子ℛ；证明者生成关于ℛ的、 Merkle路径通往rt的知识证明。\\n\\n**验证证明**：Verify算法检查副本给定Merkle树根和原始数据哈希的存储证明的合法性。证明是可以公开验证的：维护去中心化系统账本的节点和对特定数据感兴趣的客户可以验证这些证明。\\n\\n**3.4.4. 实用的 PoSt架构**\\n\\n本章将描述 PoSt 协议的架构，并且在图4中包含了一个简化的协议草图；实现和优化的细节被省略了。Setup和Verify算法和上面PoRep中的架构相同，因此这里只描述Prove。\\n\\n**3.5.在Filecoin中的运用**\\n\\nFilecoin协议采用了时空证明来审核矿工提供的存储。为了在Filecoin中使用PoSt，出于无指定验证者和我们想要任何网络成员都可以验证的原因，我们将我们的方案修改成了非交互模式。由于我们的验证者是在公共通证模型下运行的，我们可以从区块链中提取随机性来发出挑战。\\n\\n4\\n\\n**Filecoin：一个DSN架构**\\n\\nFilecoin DSN是一个可审查的、可公开验证并且为激励所设计的去中心化存储网络。客户为了存储和检索数据向矿工付费；矿工提供硬盘空间和带宽来赚取费用。矿工只有在网络审核他们确实提供了服务后才会收到付款。\\n\\n在本章中，我们将展示基于DSN定义以及时空证明的Filecoin DSN架构。\\n\\n**4.1设置**\\n\\n**4.1.1.参与者**\\n\\n任何使用者都可以作为客户、存储矿工或检索矿工来进行参与。\\n\\n客户在DSN中通过Put和Get请求来付费进行存储及检索数据。\\n\\n存储矿工向网络提供数据存储。存储矿工在Filecoin中提供他们的硬盘空间并且服务Put请求。想要成为存储矿工，用户必须用与存储空间成比例的抵押物来抵押自己的硬盘空间。存储矿工用承诺在特定时间存储客户数据的方式来响应Put请求。存储矿工生成时空证明并将他们提交到区块链来向网络证明他们一直在存储数据。在证明无效或者丢失的情况下，存储矿工将被惩罚并失去一部分的抵押物。存储矿工也有资格挖取新的区块，如果挖到新的区块，矿工将获得创建新区块的奖励以及包含在区块中的交易费。\\n\\n检索矿工为网络提供数据检索服务。检索矿工在Filecoin中提供给客户Get请求所需的数据。与存储矿工不同，他们不需要抵押、承诺存储数据或是提供存储证明。存储矿工可以很自然同时兼做检索矿工。检索矿工可以从客户或者检索市场上获取碎片。\\n\\n**4.1.2.网络N**\\n\\n我们将运行Filecoin全节点的所有用户设想为一个单一的抽象实体：网络。网络充当运行Manage协议的中介；非正式地，在Filecoin区块链的每个新区块中，全节点将管理可用存储，验证抵押物，审核存储证明以及修复可能的故障。\\n\\n**4.1.3. 账本**\\n\\n我们的协议适用于基于账本的货币；一般而言，我们称之为 Ledger，L。在任何给定 时间 Lt （称为纪元），所有用户都可以访问 Lt ，在纪元 t 时候下，账本的交易是顺序 的。账本是只可附加式的。Filecoin DSN 协议可以在任何允许验证 Filecoin 证明的账本 上实现；在第 6 章中我们展示了我们如何基于有用的工作构建一个账本。\\n\\n**4.1.4.市场**\\n\\n存储的供给和需求组成了两个Filecoin市场：存储市场和检索市场。这两个市场是两个去中心化交易所，这会在第5章中详细解释。简言之，客户和矿工为他们请求的服务设定价格或是通过向两个市场分别提交订单。交易所为客户和矿工提供了一种方式来查看匹配报价并发起交易。如果请求的服务被成功提供，通过运行Manage协议，网络将保证矿工得到报酬的同时客户也被收取了费用。\\n\\n**4.2.数据结构**\\n\\n碎片：一个碎片是客户存储在DSN的数据的一部分。例如，数据可以被有意分为很多个碎片，每一个碎片由不同的存储矿工保存。\\n\\n扇区：一个扇区是存储矿工提供给网络的一些硬盘空间。矿工将从客户那里得来的碎片存储在他们的扇区中并为他们的服务获取通证。为了存储碎片，存储矿工必须向网络抵押他们的扇区。\\n\\n分配表：分配表是一个用来跟踪碎片以及分配扇区的数据结构。分配表在账本中每一个区块都会更新一次，并且它的Merkle树根将存储在最新的区块中。在实践中，该表用来保持DSN的状态，允许在证明验证过程中快速查找。更多细节请看图5。\\n\\n订单：一个订单是请求或提供服务的意向声明。客户向市场提交报价订单以请求服务（存储市场以存储数据或检索市场以检索数据），矿工提交询价订单来提供服务。订单的数据结构如图10所示。市场的协议将在第5章中详细介绍。\\n\\n订单簿：订单簿是订单的集合。请查看章节5.2.2.中的存储市场订单簿和章节5.3.2.中的检索市场订单簿。\\n\\n抵押：抵押是向网络提供存储（特别是扇区）的一种承诺。存储矿工必须将他们的抵押提交给账本才能开始在存储市场中接受订单。一个抵押包含了抵押扇区的大小和存储矿工存放的抵押物（更多详细信息请看图5）。\\n\\n**图5 DSN方案中的数据结构**\\n\\n**4.3.协议**\\n\\n在这一章中，我们将通过描述客户、网络和矿工执行的操作来概述Filecoin DSN。我们在图7中介绍了Get和Put协议的方法，在图8中介绍了Manage协议。图6展示了一个协议执行的示例。Filecoin协议的概览则是在图1中。\\n\\n**4.3.1.客户周期**\\n\\n我们给出了客户周期的概览；对于接下来协议的深层次的解释将在第5章中给出。\\n\\n\\\\*\\\\*Put：客户将数据存储在Filecoin。\\\\*\\\\*客户可以通过向存储矿工支付Filecoin通证来存储他们的数据。Put协议的细节将在接下来的章节5.2.中。一个客户通过向存储市场订单簿提交一个报价订单（提交订单到区块链）来启动Put协议。当匹配到从矿工而来的询价订单时，客户将碎片发给矿工。双方签署成交订单并且将它提交到存储市场订单簿。客户们可以通过提交多份订单（或在订单中指定复制因子）来决定他们碎片的物理副本数量。冗余度越高，存储故障的容许度就越高。\\n\\n**Get：客户从Filecoin检索数据**。客户可以通过向检索矿工支付Filecoin通证来检索在DSN中存储的任何数据。Get协议在章节5.3.中有详细介绍。一个客户通过向检索市场订单簿提交一个报价订单（向整个网络广播他们的订单）来启动Get协议。当匹配到从矿工而来的询价订单时，客户将收到从矿工而来的碎片。收到后，双方签署成交订单并且将它提交到区块链来确认交易成功。\\n\\n**4.3.2.挖矿周期（对于存储矿工）**\\n\\n我们给出了一个非正式的挖矿周期概述\\n\\n**1.抵押：存储矿工向网络抵押存储**\\n\\n存储矿工通过在区块链抵押交易（通过Manage.PledgeSector.）中存放抵押物来向整个网络抵押他们的存储。抵押物将在提供服务期间被抵押，并且会在矿工为他们承诺存储数据提供存储证明时返还给他们。如果一些存储证明失败了，那么成比例的抵押物就会损失掉。\\n\\n一旦抵押交易在区块链中出现，矿工就可以在存储市场中提供他们的存储了。\\n\\n**2.接收订单：存储矿工从存储市场获取存储请求**\\n\\n一旦抵押交易出现在区块链中（因为在分配表中），矿工可以在存储市场中提供他们的存储：他们设定价格并且通过 Put.AddOrders.在市场的订单簿中添加\\n\\n一个询价订单。\\n\\n通过 Put.MatchOrders 检查他们的订单是否和客户的报价订单匹配一致。\\n\\n一旦订单匹配，客户将发送他们的数据给存储矿工。矿工收到碎片时运行Put.ReceivePiece。当数据被接收后，矿工和客户双方签署一个成交订单并\\n\\n将它提交到区块链。\\n\\n**3.密封：存储矿工为未来的证明准备碎片**\\n\\n存储矿工的存储被切分扇区，每个扇区包含了分配给矿工的碎片。网络通过分配表来跟踪每个存储矿工的扇区。当一个存储矿工的扇区被填满了，这个扇区就被密封起来了。密封是一种缓慢的顺序操作，它将扇区中的数据转换成复制品，即一个与矿工公钥相关联的唯一的物理副本。密封如章节 3.4.中描述的一样，是一个复制证明期间的必须操作。\\n\\n**4.证明：存储矿工证明他们正在存储所承诺的碎片**\\n\\n当存储矿工被分配数据时，他们必须重复生成复制证明来保证他们在存储数据（更多细节请参阅第 3 章）。证明被公布在区块链上并由网络来验证它们。\\n\\n**4.3.3. 挖矿周期（对于检索矿工）**\\n\\n我们给出一个对于检索矿工非正式的挖矿周期概述。\\n\\n\\\\*\\\\*1.收到订单：\\\\*\\\\*检索矿工从检索市场得到数据请求\\n\\n检索矿工通过向网络广播他们的询价订单来宣布他们的碎片：他们设置价格并向市场订单簿添加询价订单。\\n\\n然后检索矿工检查是否与客户的报价订单匹配一致。\\n\\n**2.发送：检索矿工发送碎片给客户**\\n\\n一旦订单匹配，检索矿工发送数据碎片给客户（详情参见章节 5.3.）。当碎片接收完毕，矿工和客户双方签署成交订单并将它提交到区块链。\\n\\n**4.3.4. 网络周期**\\n\\n我们给出一个非正式的网络操作概述。\\n\\n**1.分配**：网络将客户的碎片分配给存储矿工的扇区。\\n\\n客户通过在存储市场上提交报价订单来启动 Put 协议。\\n\\n当询价与报价订单相匹配时，有关各方共同承诺交易并在市场上提交成交订单。\\n\\n此时，网络将数据分配给矿工并将其记录在分配表中。\\n\\n**2.修复**：网络发现故障并尝试修复它们。\\n\\n所有的存储分配对于网络中的每个参与者都是公开的。在每一个区块，网络都会检查每一个分配的所需证明是否存在，检查它们是否有效，并采取相应措施：\\n\\n如果有任何证明丢失或是无效，网络会通过扣除部分抵押物来惩罚存储矿工。\\n\\n如果大量证明丢失或是无效（由系统参数 ∆fault 定义），网络会认定存储矿工存在故障并将订单设定为失败，并且重新推出同一份碎片的新订单进入市场。\\n\\n如果每一个所有存储该碎片的存储矿工都有故障，则该碎片丢失，客户获得退款。\\n\\n**图6 Filecoin DSN的执行示例，**\\n\\n**按���分组并按照行及时间顺序排序**\\n\\n**4.4保证和要求**\\n\\n以下是Filecoin DSN如何实现完整性、可检索性、可公开验证性和激励兼容性。\\n\\n实现完整性：碎片以加密哈希值命名。在一个Put请求之后，客户只需要存储哈希值即可通过Get取回（取回与检索英文相同）数据并且验证收到的数据的完整性。\\n\\n实现激励兼容性：非正式地，矿工通过提供存储而获得奖励。当矿工承诺存储数据时，他们需要生成证明。忽略证明的矿工会受到惩罚（通过损失部分抵押物），并且不会收到存储的奖励。\\n\\n实现可公开验证性和可审核性：存储矿工需要向区块链提交他们的存储证明(SEAL, POST)。网络中的任意用户都可以在不访问外包数据的情况下验证这些证明的有效性。由于这些证明都是存储在区块链上的，所以一丝一毫的操作都是可以被随时审核的。\\n\\n实现激励兼容性：非正式地，矿工通过提供存储而获得奖励。当矿工承诺存储数据时，他们需要生成证明。忽略证明的矿工会受到惩罚（通过损失部分抵押物），并且不会收到存储的奖励。\\n\\n实现保密性：如果客户希望他们的数据被私密存储，他们必须在上传数据之前进行数据加密。\\n\\n**图7 Filecoin DSN中Put和Get协议的描述**\\n\\n**图8 Filecoin DSN中Manage协议的描述**\\n\\n5\\n\\n**Filecoin存储和检索市场**\\n\\nFilecoin有两个市场：存储市场和检索市场。这两个市场拥有相同的结构与不同的设计。存储市场允许客户向存储矿工付费来存储数据。检索市场允许客户向检索矿工付费来享受数据的检索传递服务。在这两种情况下，客户和矿工可以设置他们的报价和要价或是接受当前的报价。这些交易是由区块链网络Filecoin全节点网络的拟人化概念所运行的。网络保证矿工在提供服务时，可以得到来自客户的奖励。\\n\\n**5.1 可验证市场**\\n\\n交易市场是促进特定商品或服务交易的协议。它们使得买家和卖家促成交易。出于我们的目的，我们要求交易是可以验证的：即一个���中心化的参与者的网络必须能够在买家和卖家之间验证交易。\\n\\n我们提出了可验证市场的概念，其中没有任何的实体来管理交易所，交易是透明的，任何人都可以匿名参与。可验证市场协议使得对于商品和服务的交易完全去中心化：订单簿的一致性、订单结算和服务的正确执行，都是通过矿工和Filecoin全节点这些参与者独立验证的。我们将可验证市场简化为以下架构：\\n\\n**定义 5.1.** 一个可验证市场是一个有着两个阶段的协议：订单匹配与订单结算。订单是购买或出售抵押物、商品或服务的意向声明，订单簿则是所有可用订单的清单。\\n\\n**图9 可验证市场的通用协议**\\n\\n**5.2.存储市场**\\n\\n存储市场是一个允许客户（如买家）为了他们的数据请求存储也允许存储矿工（如卖家）提供他们的存储空间。\\n\\n**5.2.1要求**\\n\\n我们根据以下要求设计了存储市场协议：\\n\\n**链上订单簿**：重要的是：(1) 存储矿工的订单是公开的，所以网络始终知晓最低价格，客户可以对其订单做出明智的决定，(2) 即使客户接受了最低的价格，他们的订单还是要必须始终提交到订单簿中，这样市场可以对新报价作出反应。因此，我们要求将订单明确地添加到Filecoin区块链中，以便添加到订单簿中。\\n\\n**参与者对他们的资源做出承诺**：我们要求双方都承诺将他们的资源作为避免损害的一种方式：避免存储矿工不提供服务，也可以避免客户没有可用资金。为了参与存储市场，存储矿工必须抵押与其在DSN中的存储量成比例的抵押物（详情请参阅章节4.3.3.）。通过这种方式，网络可以惩罚那些承诺存储数据但又不提供存储证明的存储矿工。同样的，客户必须向订单存入指定的资金，以这种方式保证在结算期间的承诺与资金的可用性。\\n\\n**故障的自处理**：只有在存储矿工反复证明他们已经在约定时间内存储了碎片的情况下，订单才会结算给矿工。网络必须能够验证这些证明的存在与正确性，并且按照章节4.3.4.中的修复部分中的规则行事。\\n\\n**5.2.2数据结构**\\n\\nPut订单：有三种类型的订单：出价订单，询价订单和成交订单。存储矿工创建询价订单来添加存储，客户创建出价订单来请求存储，当双方对价格达成一致时，他们便一起创建成交订单。订单的数据结构细节图10所示，其中对于订单的参数被明确地定义了。\\n\\nPut 订单簿：存储市场中的订单簿是当前有效且开放的询价、出价以及成交订单的集合。用户可以通过图7中描述的Put协议：AddOrders和MatchOrders的方法来与订单簿交互。\\n\\n订单簿是公开的，并且每一个诚实的用户都有着相同的订单簿视图。在每一个纪元，如果新的订单交易 (txorder) 出现在新的区块链区块中，那么这个新的订单就会被添加到订单簿中；订单在被取消、过期或是结算后移除出订单簿。订单被添加在区块链中的区块中，因此在订单簿中的订单都是有效的。\\n\\n**定义 5.2.** 我们定义了出价、询价以及成交订单的有效性：\\n\\n**（有效的出价订单）**：一个客户的出价订单，\\n\\n\\\\*\\\\*（有效的询价订单）：\\\\*\\\\*一个存储矿工 M的询价订单，\\n\\n（有效的成交订单）：一个成交订单，\\n\\n备注：如果一个作恶客户从存储矿工那里收到了一份已经签署的合同，但从来没有将其添加到订单簿中，那么存储矿工就无法重新使用订单中提交的存储。ts将阻止这种攻击，因为，在ts之后，订单将变为无效并且无法被添加到订单簿中。\\n\\n**图10 存储市场和检索市场的订单数据结构**\\n\\n**5.2.3存储市场协议**\\n\\n简而言之，存储市场协议被分为两个阶段：订单匹配和订单结算。\\n\\n**订单匹配**：客户和存储矿工通过提交交易到区块链来将他们的订单提交到订单簿中（第1步）。当订单匹配完成，客户将碎片发送给存储矿工，随后双方签署成交订单并且将它提交到订单簿（第2步）。\\n\\n**结算**：存储矿工封存他们的扇区（第3a步），为包含碎片的扇区生成存储证明并且定期将它们提交到区块链（第3b步）；与此同时，其余的网络必须验证矿工所生成的证明并且修复可能的故障（第3c步）。\\n\\n存储市场协议细节请参阅图11。\\n\\n**5.3检索市场**\\n\\n检索市场允许客户请求检索特定的碎片，并由检索矿工提供这个服务。与存储矿工不同，检索矿工不需要在特定时间周期内存储数据或者生成存储证明。在网络中的任何用户都可以成为检索矿工，通过提供检索服务来赚取Filecoin通证。检索矿工可以直接从客户那里获取碎片，也可以通过检索市场获取它们，或者作为存储矿工直接存储它们。\\n\\n**5.3.1要求**\\n\\n我们根据以下要求设计了检索市场协议：\\n\\n**链下订单簿**：客户必须能够找到提供所需碎片的检索矿工，并且在定价之后直接交易。这意味着订单簿不能通过区块链来运行，因为这将成为快速检索请求的瓶颈，相反，参与者将只能看到订单簿的一部分。因此，我们要求双方广播自己的订单。\\n\\n**无信任方检索**：公平交换 \\\\[10\\\\] 的不可能性提醒我们要让双方在没有信任方的情况下进行交易是不可能的。在存储市场中，区块链网络将作为一个验证存储矿工提供的存储的（去中心化）信任方。在检索市场中，检索矿工和客户将在没有网络见证文件交易的前提下来进行数据交易。我们通过要求检索矿工将数据分割成多个部分来解决这么问题，并且对于发送给客户的每个部分，矿工都会收到付款。这样，如果客户停止付款，或者矿工停止发送数据，任何一方都可以停止交易。值得注意的是，要想让这个办法管用，我们必须假设始终有一个诚实的检索矿工。\\n\\n**支付通道**：客户希望在提交付款之后立即可以取回碎片，检索矿工则希望只有在确认会收到付款之后才会提供碎片。通过公共账本验证付款可能是检索请求的瓶颈，因此我们必须依赖于高效的链下付款。Filecoin区块链必须支持可以进行快速并且乐观的交易通道，并且仅在出现纠纷的情况下才使用区块链。通过这种方式，检索矿工和客户可以快速发送我们协议要求的小额支付。包括创建支付通道网络在内的未来工作在前面的 \\\\[11\\\\] \\\\[12\\\\] 中可以见到。\\n\\n**5.3.2. 数据结构**\\n\\nGet 订单：在检索市场中存在三种订单：\\n\\nGet订单簿：检索市场中的订单簿是当前有效且开放的询价、出价以及成交订单的集合。不同于存储市场，每一个用户都会有不同的订单簿视图，因为订单是在网络中广播的，而每一个矿工和客户只会跟踪他们感兴趣的订单。\\n\\n**图11 详细的存储市场协议**\\n\\n**5.3.3检索市场协议**\\n\\n简而言之，检索市场协议分为两个阶段：订单匹配和订单结算。\\n\\n**订单匹配**：客户和检索矿工通过广播他们的订单将订单添加到订单簿（第1步）。当订单匹配完成，客户和检索矿工之间建立一条小额支付通道（第2步）。\\n\\n**结算**：检索矿工发送碎片的一小部分给客户，然后客户针对每一份碎片都会向矿工发送一份签署的收据（第3步）。检索矿工向区块链出示送达收据从而获得奖励（第4步）。\\n\\n该协议将会在图12中详细解释。\\n\\n图12 详细的检索市场协议\\n\\n6\\n\\n有用的工作共识\\n\\nFilecoin DSN协议可以在任何允许Filecoin证明验证的共识协议之上实现。在本章中，我们将介绍如何基于有用的工作来引导共识协议。代替掉浪费的工作证明计算，由工作的Filecoin矿工所生成的时空证明是允许他们参与共识的原因。\\n\\n有用的工作：如果计算的输出是对整个网络有价值的，而不仅仅是保卫区块链的安全，我们便认为矿工在共识协议中所做的工作是有用的。\\n\\n**6.1.动机**\\n\\n确保区块链的安全是至关重要的，工作证明方案常常需要解决其答案不可再用或者需要大量的浪费计算的难题。\\n\\n**不可重复利用的工作**：大多数无权限的区块链要求矿工解决一个难以解决的计算难题，例如反转哈希函数。通常这些难题的解决方案都是无用的，并且除了保护网络之外没有任何固定的价值。我们能够重新将这项工作重新用于有用的事情吗？\\n\\n**尝试重复使用的工作**：业内已经有了数次尝试再利用挖矿功率进行有用的计算。有些尝试要求矿工同时与标准的工作证明进行一些特殊计算。其他的尝试想用有用的问题取代工作证明，但依然很难解决。例如，Primecoin重新利用矿工的计算能力来寻找新的素数，以太坊要求矿工与工作证明一起执行小程序，Permacoin通过要求矿工反转哈希函数同时证明某些数据正在存档来提供存档服务。尽管这些尝试中的绝大多数都能执行有用的工作，但是这些计算中浪费的工作量仍然很普遍。\\n\\n**浪费的工作**：解决难题在机器成本和能源成本方面的消耗是非常昂贵的，特别是如果这些谜题完全依赖于计算能力。当挖矿算法令人尴尬地平行时，解决难题的普遍因素是计算能力。我们可以减少浪费的工作吗？\\n\\n**尝试减少浪费**：理想情况下，网络资源的大部分应该花在有用工作上。一些尝试是要求矿工使用更节能的解决方案。例如，Spacemint要求矿工用硬盘而不是算力来挖矿；虽然更加节能，但是这些硬盘空间依然被浪费了，因为它们被随机数据填满了。其他的尝试会用基于权益证明的传统拜占庭协议来代替解决难题的困难，其中利益相关方在下一个区块中的投票数与它们在系统中所占有的货币份额成正比。\\n\\n我们着手设计了一个基于用户数据存储的有用的工作的共识协议。\\n\\n**6.2.Filecoin共识**\\n\\n我们提出了一种有用的工作共识协议，其中网络选择一个矿工来创建新区块（我们称之为矿工的投票权）的概率与当前这个矿工使用中的存储和网络其余部分相关的存储的关系成正比。我们设计了Filecoin协议，以便矿工宁愿投资存储而不是算力来并行挖掘计算。矿工提供存储并重新使用计算以证明数据被存储以参与共识。\\n\\n**6.2.1. 挖矿功率建模**\\n\\n功率容错：在我们的技术报告 \\\\[13\\\\] 中，我们提出了功率容错，即一个根据参与者对协议结果的影响重新构建拜占庭故障的抽象化概念。每个参与者控制网络总功率 n 中的一些功率，f 是故障或作恶参与者所控制的功率占比。\\n\\n在 Filecoin 中，功率有以下属性：\\n\\n**公开**：网络中当前正在使用的存储总量是公开的。通过读取区块链，任何人都可以计算每个矿工的存储任务，因此任何人都可以在任意时间点计算出每一个矿工的功率与网络总功率。\\n\\n**可公开验证的**：对于每一个存储任务，矿工被要求生成时空证明以证明服务在被持续提供。通过读取区块链，任何人都可以验证矿工所声明的功率是否正确。\\n\\n**可变的**：在任意时间点，矿工可以通过抵押新扇区并且填充新扇区的方式来添加新的存储。这样矿工便可以改变他们的功率。\\n\\n**6.2.2. 用时空证明来衡量功率**\\n\\n对于每一个 Δproof 区块，矿工们必须提交时空证明到网络，如果网络中的绝大部分功率都认为这些证明是有效的，那么这些证明将被成功地添加到区块链中。在每一个区块中，每个全节点都会更新分配表、添加新的存储任务、移除过期的存储任务并且标记缺失的证明。\\n\\n一个矿工 ℳi的功率可以通过分配表中的条目来进行计算和验证，这些可以通过两种方式来实现：\\n\\n**全节点验证**：如果一个节点拥有完整的区块链记录，则可以从创世区块运行网络协议直到当前区块并为矿工 ℳi读取分配表。这一过程验证当前分配给 ℳi\\n\\n存储的每一个时空证明。\\n\\n**简单存储验证**：假设一个小型客户可以访问一个广播了最新区块的可信源。小型客户可以从网络的节点中请求：(1) 矿工 ℳ在当前分配表中的条目，(2) 一个可以证明该条目包含在最后一个区块的状态树中的 Merkle 路径，(3) 从创世区块到当前区块的区块头。这样，小型客户就可以将时空证明的验证委托给网络。\\n\\n功率计算的安全性来自于时空证明的安全性。在这个设定里面，PoSt保证矿工无法对他们被分配的存储量说谎。实际上，他们不能声称能够存储比当前存储的数据更多的数据，因为这需要花时间来获取并运行缓慢的PoSt.Setup，并且由于PoSt.Prove是一个顺序计算，他们不能通过并行计算来更快地生成证明。\\n\\n**6.2.3使用功率达成共识**\\n\\n我们通过扩展现有的（和未来的）权益证明共识协议来预见实施Filecoin共识的多种策略，其中权益被指定的存储所替换。但是我们预见了权益证明协议的改进，所以我们我们提出了一项基于我们之前的工作的架构，称为预期共识 \\\\[14\\\\]。我们的策略是在每一轮选出一名（或多名）矿工，这样赢得选举的概率和每一个矿工所被分配的存储成正比。\\n\\n预期共识：预期共识EC的基础在于在每个纪元确定地、不可预测地并且秘密地选举一小部分领袖。我们的期望是每个纪元都只选出1个领袖，但一些纪元内可能会出现0个或者多个领袖。领袖通过创建一个区块并将其传播到网络的方式来拓展区块链条。在每一个纪元，区块链将被延伸一个或多个区块。在没有领袖的纪元里，一个空的区块将被添加到区块链中。虽然区块链中的区块可以线性排序，但它的数据结构是一个有向无环图。EC是一个概率共识，每个纪元都比前面的区块更加确定，最终因为不同历史可能性很小的缘故达到足够的确定性。如果绝大部分的参与者通过扩展链或签名区块的方式将他们的权重添加到区块所属的链上，那么这个区块就被确定了。\\n\\n选举矿工：在每一个纪元，每个矿工都会检查它们是否当选为领袖，这与先前的协议类地完成：CoA \\\\[15\\\\]，Snow White \\\\[16\\\\]，Algorand \\\\[17\\\\]。\\n\\n定义 6.1. （Filecoin 中的 EC 选举）如果满足以下条件，则在时刻 矿工 ℳ当选领袖：\\n\\n其中 rand（t）是一个可以在纪元t从区块链中提取的公开的随机变量，Pti是矿工 ℳi\\n\\n的功率。对于任何m，ℋ(m)的大小都是L，H是一种安全的加密哈希函数，<m>Mi是一个由 Mi签署的消息m，使得：\\n\\n在图 13 中，我们描述了矿工（ProveElect）和网络节点（VerifyElect）之间的协议。\\n\\n这种选举方案提供了三个属性：**公平、保密**和**可公开验证性**。\\n\\n**公平**：由于签名是确定的，并且和是固定的，每个参与者每次选举都只有一次机会。假设 是一种安全的加密哈希函数，那么 一定是一个从 均匀选择的实数。因此，方程式为真的概率必须是/ ，这等于矿工在网络中功率的那部分。因为这个概率在功率上是线性的，所以这种可能性在分裂或汇集功率下得以保留。请注意，随机值 在时间之前都是未知的。\\n\\n**保密**：在给定数字签名的假设情况下，一个没有秘钥 的有能力的攻击者可以通过计算来获取签名的可能性是可以忽略不计的。\\n\\n**可公开验证的**：一个当选的领袖 可以通过展示、 和 来说服一个有效验证者。鉴于前面的观点，有能力的攻击者在没有获胜秘钥的情况下是不能生成证明的。\\n\\n图13 在期望共识协议中的领袖选举\\n\\n7\\n\\n智能合约\\n\\nFilecoin为终端用户提供了两个基本的原语：Get和Put。这些原语让客户可以在市场中以他们自己喜爱的价格存储和检索数据。虽然原语涵盖了Filecoin的默认使用案例，但我们还是通过支持智能合约的部署，允许在Get和Put之上设计更复杂的操作。用户可以编写新的精细的存储/检索请求，我们将其称为文件合约以及通用智能合约。我们整合了合约系统（基于 \\\\[18\\\\]）和一个桥接系统将Filecoin存储带入其他区块链之中，反之亦然，也将其他的区块链的功能带入Filecoin之中。\\n\\n我们期望在Filecoin生态系统中存在大量的智能合约，我们也期待一个由智能合约开发者组成的社区。\\n\\n**7.1.Filecoin中的合约**\\n\\n智能合约使得Filecoin的用户能够编写可以花费通证、在市场中请求存储/检索数据和验证存储证明的有状态的程序。用户可以通过将交易发送到账本以触发合约中的功能函数来与智能合约进行交互。我们拓展了智能合约系统以支持Filecoin的特定操作（如市场操作和证明验证）。\\n\\nFIlecoin支持��定于数据存储的合同，以及更通用的智能合约：\\n\\n\\\\*\\\\*文件合约：\\\\*\\\\*我们允许用户对他们提供的存储服务进行编程。有几个例子值得一提：(1) 承包矿工：客户可以提前指定提供服务的矿工而无需参与市场，(2) 支付策略：客户可以针对矿工设计不同的奖励策略，比如一个可以随着时间的推移越付越高费用的合约，另一个合约则由一个值得信任的预报器来设定存储价格，(3) 票务服务：合同允许矿工存入代表他们的用户存入通证并且支付存储/检索服务， (4) 更复杂的操作：客户可以创建允许数据更新的合约。\\n\\n**智能合约**：用户可以将程序与其他系统中的事物相关联（如以太坊 \\\\[18\\\\]），这并不直接依赖于存储的使用。我们预见了一些应用如：去中心化命名系统、资产追踪和众筹平台。\\n\\n**7.2.与其他系统的集成**\\n\\n桥接系统是连接不同区块链的工具；虽然仍在进行中，但我们计划支持跨链交互，以便将Filecoin存储带入其他基于区块链的平台，并将其他平台的功能也带入Filecoin。\\n\\n**Filecoin在其他平台上**：其他的区块链系统如比特币 \\\\[19\\\\]、Zcash \\\\[20\\\\]，特别是以太坊 \\\\[18\\\\] 和Tezos允许开发者编写智能合约；然而这些平台只提供很少的存储能力和非常高的成本。我们计划提供一种桥接系统以将存储和检索支持带入这些平台。我们注意到IPFS已经被一些智能合约（和协议通证）当做引用和分发内容的方式使用了。添加对Filecoin的支持将允许这些系统能够以交易Filecoin通证的方式来保证IPFS上存储的内容。\\n\\n**其他平台在Filecoin上**：我们计划提供桥接系统以链接FIlecoin和其他区块链的服务。例如，与Zcash的集成将支持发送隐私存储数据的请求。\\n\\n8\\n\\n**未来的工作**\\n\\n这项工作为Filecoin网络的构建提供了一条清晰而有凝聚力的道路；然而，我们也认为这项工作是未来分散存储系统研究的起点。在本章中，我们确定并填充了三类未来的工作。这包括已完成的工作，它们只是等待描述和发布、提出改进当前协议的开放式问题以及协议的形式化等方面。\\n\\n**8.1.正在进行的工作**\\n\\n以下主题代表正在进行的工作\\n\\n一个描述每个区块中Filecoin状态树的规范\\n\\nFilecoin及其组件的详细性能评估和基准\\n\\n一个完全可实现的Filecoin协议规范\\n\\n一个赞助检索票务模型，其中通过发行每片可承载且可花费的通证，任何客户C1都可以赞助另一个客户C2的下载\\n\\n一个分层共识协议，其中Filecoin子网可以在临时或永久分区进行分区操作或继续处理交易。\\n\\nl使用SNARK/STARK增加区块链快照\\n\\n基于以太坊的Filecoin接口合约和协议\\n\\n与Braid的区块链归档和跨区块链盖戳\\n\\n仅在解决冲突的时候在区块链上发布时空证明\\n\\n正式证明Filecoin DSN和新型存储证明的实现\\n\\n**8.2.开放性问题**\\n\\n这里有许多未解决的问题，尽管他们不会耽误上线时间，但其答案有可能大大改善整个网络。\\n\\n一个描述复制证明密封功能更好的原语，其中理想情况下是O(n)解码（而不是O(nm)解码），并且无需SNARK/STARK就可以公开验证\\n\\n一个描述复制证明Prove功能更好的原语，其中无需SNARK/STARK就可以公开验证且透明\\n\\n一个可以公开验证且透明的检索证明或是其他的存储证明\\n\\n检索市场中针对检索的新策略（例如，基于概率支付、零知识条件支付）\\n\\n一个更好的期望共识秘密领袖选举，其中每一个纪元只有一个领袖当选\\n\\n一个更好的SNARKs可信设置方案，允许公共参数的增量扩展（可以运行一系列MPCs的方案，其中每个额外的MPC严格降低故障概率，并且每个MPC的输出可用于系统）\\n\\n**8.3.证明和正式验证**\\n\\n由于证明和正式验证的明确价值，我们计划证明Filecoin网络的很多属性，并在未来几个月和几年内开发正式验证协议的规范。我们已经有了一些正在进行中的证明，还有更多的还在思考中。但是要证明Filecoin的很多属性（如缩放和离线）将是艰难且长期的工作。\\n\\n预期协议和变体的正确性证明\\n\\n功率容错的正确性证明，其中异步1/2将不会导致分叉\\n\\n在通用组合框架中制定Filecoin DSN，将Get、Put和Manage作为理想的功能来描述，并证明我们的确实现了它\\n\\n自动自愈保证的正式模型和证明\\n\\n正式地验证协议描述（例如TLA 或者Verdi）\\n\\n正式验证实现（例如Verdi）\\n\\n对Filecoin激励的博弈论分析\\n\\n**致谢**\\n\\n这项工作是协议实验室团队中多个人的累计工作，如果没有协议实验室的合作者和顾问的帮助、评论和审查是不可能完成的。Juan Benet在2014年书写的原始的Filecoin白皮书为这项工作奠定了基础。他和Nicola Greco开发了新的协议并且与提供了有用的贡献、评论、审查和交流的剩余团队成员合作写完了这份白皮书。特别是，David“Davidad”Dalrymple提出了订单簿范例和其他想法，Matt Zumwalt改进了白皮书的结构，Evan Miyazono创作了插图并完成了论文，Jeromy Johnson在设计协议时提出了深刻见解，Steven Allen提出了富有洞察力的问题和说明。我们同样也感谢所有的合作者和顾问们有用的交流；尤其是Andrew Miller和Eli Ben-Sasson。\",\"timestamp\":1640707216,\"title\":\"filcoin白皮书\"},\"digest\":\"MaY3HR5FZU4Jn7P-6McltBJpCP0jNrtBDg9BEBcjI4k\",\"authorship\":{\"contributor\":\"0x2b72C6B14de6C551d7fE16424b4e88b4a562D6B5\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"C7UBp3H7lwfsWswop2WDus069-a4ltSzZyvU4Qw0xoc\\\",\\\"y\\\":\\\"xq60_g6JEC5gZUyiP0l-ucmqNEgyoe1D3ggPlWl7pBU\\\"}\",\"signature\":\"HiUEZHNGbWzf_Io5GCSTuhErUEL05IH7jBfi91-cJrO5FR_8eNpsIk43TncdwPi2TPOktPIVf5MIQ-y94E9p-A\",\"signingKeySignature\":\"0x58fb9fbe200c0ba165a368d8178a86f6d8c2a3c5033caeb3d17fed26778f3daa041f9bee3769f54d5495509526f7658bf2a8c2f0863cc072f656651487225c971b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"C7UBp3H7lwfsWswop2WDus069-a4ltSzZyvU4Qw0xoc\\\",\\\"y\\\":\\\"xq60_g6JEC5gZUyiP0l-ucmqNEgyoe1D3ggPlWl7pBU\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"qG7wDsfX5BoYfAom8ItxQ82UA2MJUuPnWp9p3ubeCS8\"}"