"{\"content\":{\"body\":\"由于项目需要使用到websocket，根据自己项目需求，封装符合自己项目使用的简单组件。单列模式，只实现了发送和接受的简单功能，后续继续补充\\n\\n```python\\nfrom asyncio.tasks import sleep\\r\\nfrom concurrent.futures import thread\\r\\nimport inspect\\r\\nimport logging\\r\\nimport socketserver\\r\\nimport threading\\r\\nimport time\\r\\nimport asyncio\\r\\nimport websockets\\r\\nimport sys\\r\\nimport os\\r\\nimport json\\r\\nimport pathlib\\r\\nimport ssl\\r\\nimport nest_asyncio\\r\\n\\r\\nnest_asyncio.apply()\\r\\n\\r\\ndef synchronized(func):\\r\\n\\r\\n    func.__lock__ = threading.Lock()\\r\\n\\r\\n    def lock_func(*args, **kwargs):\\r\\n        with func.__lock__:\\r\\n            return func(*args, **kwargs)\\r\\n    return lock_func\\r\\n\\r\\nclass WebsocketAssembly(object):\\r\\n    instance = None\\r\\n    port = None\\r\\n    host = None\\r\\n    connected = set()\\r\\n    ssl_enable = False\\r\\n    user_callback = None\\r\\n    websocket_server = None\\r\\n    loop=None\\r\\n    threadarr=[]\\r\\n    ssl_enable = False\\r\\n\\r\\n    @synchronized\\r\\n    def __new__(cls, *args, **kwargs):\\r\\n        print(\\\"__new__\\\")\\r\\n        if cls.instance is None:\\r\\n            cls.instance = object.__new__(cls, *args, **kwargs)\\r\\n        return cls.instance\\r\\n\\r\\n    @staticmethod\\r\\n    async def send_message(websocket, message):\\r\\n        await websocket.send(message)\\r\\n\\r\\n    @staticmethod\\r\\n    async def broadcast_message(message):\\r\\n        if len(WebsocketAssembly.connected) > 0:\\r\\n            await asyncio.wait([connected.send(message) for connected in WebsocketAssembly.connected])\\r\\n    \\r\\n    @staticmethod\\r\\n    async def send_message(websocket, message):\\r\\n        await websocket.send(message)\\r\\n\\r\\n    async def register_client(self, websocket):\\r\\n        self.connected.add(websocket)\\r\\n    \\r\\n    async def unregister_client(self,websocket):\\r\\n        self.connected.remove(websocket)\\r\\n\\r\\n    async def callback(self, websocket, path):\\r\\n        print(\\\"register_client: \\\", websocket)\\r\\n        await self.register_client(websocket)\\r\\n        if self.user_callback is not None:\\r\\n            await self.user_callback(websocket, None)\\r\\n        try:\\r\\n            async for message in websocket:\\r\\n                if self.user_callback is not None:\\r\\n                    await self.user_callback(websocket, message)\\r\\n        except Exception as e:\\r\\n            print(\\\"Exception: \\\", e)\\r\\n        finally:\\r\\n            print(\\\"unregister_client: \\\", websocket)\\r\\n            await self.unregister_client(websocket)\\r\\n    \\r\\n    def run_loop(self,lp,host,port, callback, ssl_enable):\\r\\n        asyncio.set_event_loop(lp)\\r\\n        if callback is not None:\\r\\n            self.user_callback = callback\\r\\n        try:\\r\\n            if ssl_enable:\\r\\n                ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\\r\\n                ssl_context.load_cert_chain(pathlib.Path(__file__).with_name('localhost.pem'))\\r\\n                self.websocket_server = websockets.serve(self.callback, host,port,ssl=ssl_context)\\r\\n                lp.run_until_complete(self.websocket_server)\\r\\n                lp.run_forever()\\r\\n            else:\\r\\n                self.websocket_server = websockets.serve(self.callback, host,port)\\r\\n                lp.run_until_complete(self.websocket_server)\\r\\n                lp.run_forever()\\r\\n        except Exception as e:\\r\\n            print(e)\\r\\n\\r\\n    def create_websocket(self, host, port, ssl_enable = False, callback = None,):\\r\\n        if self.port is not None and self.port == port and self.host is not None and self.host == host:\\r\\n            return\\r\\n\\r\\n        self.host = host\\r\\n        self.port = port\\r\\n        self.ssl_enable = ssl_enable\\r\\n        self.loop= asyncio.new_event_loop()\\r\\n        thread = threading.Thread(target=self.run_loop,args=(self.loop, self.host, self.port, callback, self.ssl_enable),name=\\\"Websoket_server\\\")\\r\\n        self.threadarr.append(thread)\\r\\n        thread.setDaemon(True)\\r\\n        thread.start()\\r\\n    \\r\\n    def destroy_websocket(self):\\r\\n        for s in self.websocket_server.ws_server.sockets:\\r\\n            s.close()\\r\\n        self.loop.stop()\\r\\n        while(self.loop.is_running()):\\r\\n            time.sleep(0.5)\\r\\n        self.loop.close()\\r\\n        self.loop=None\\r\\n        self.host = None\\r\\n        self.port = None\\r\\n        self.connected = set()\\r\\n        self.instance = None\\r\\n \\r\\nif __name__ == '__main__':\\r\\n    async def test_callback(websocket, massage):\\r\\n        print(\\\"test_callback: \\\", websocket)\\r\\n        print(\\\"test_callback: \\\", massage)\\r\\n    \\r\\n    ssl_enable = False\\r\\n    websocketobj = WebsocketAssembly()\\r\\n    # websocketobj.create_websocket(\\\"localhost\\\", 8194, ssl_enable)\\r\\n    websocketobj.create_websocket(\\\"localhost\\\", 8194, ssl_enable, test_callback)\\r\\n    if websocketobj.websocket_server is None:\\r\\n        print(\\\"start websocket server failed\\\")\\r\\n\\r\\n    cn = 0\\r\\n    st = time.time()\\r\\n    while True and websocketobj.websocket_server is not None:\\r\\n        if (time.time() - st) > 5:\\r\\n            st =  time.time()\\r\\n            cn = cn + 1\\r\\n            print(\\\"cn: \\\", cn)\\r\\n            if (len(websocketobj.connected) > 0):\\r\\n                print(\\\"broadcast message\\\")\\r\\n                asyncio.get_event_loop().run_until_complete(websocketobj.broadcast_message(\\\"hello all\\\"))\\r\\n            if cn > 5 and (len(websocketobj.connected) > 0):\\r\\n                for connected in websocketobj.connected:\\r\\n                    asyncio.get_event_loop().run_until_complete(websocketobj.send_message(connected, \\\"test\\\"))\\r\\n                cn = 0\\r\\n                    \\r\\n```\",\"timestamp\":1640911167,\"title\":\"简单封装python中的websockets\"},\"digest\":\"P_jgxJcXsFNmNLhXE_p6qybmi8vxN0t9DIUn_V_EaDs\",\"authorship\":{\"contributor\":\"0x071b7EBD8F4f3Bb80e80a296430101229505d378\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"RRieZykNbX3BCZs130y1zBwmQPAkD7Frp4PStqJWePI\\\",\\\"y\\\":\\\"wH7wY3vSF28hPkb8nGIHrCetptdwshBbRJ26cLXXXic\\\"}\",\"signature\":\"kqshcsNHfiI0s2oIJBxG_1xsqzYuZLQcq85JoXok_vXlyefBYK-ff7Vkgl99jJbpZgA-QeHceDLD4yFL0MSx4w\",\"signingKeySignature\":\"0x3c5537acfefeb85b9cdb54c71d66a6b61500499f1601891926679f6d61f8fb925c5dabaa5f72f021fb5f9f39e4127c55d788dc1f4199986d6d1808c94120d5c21b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"RRieZykNbX3BCZs130y1zBwmQPAkD7Frp4PStqJWePI\\\",\\\"y\\\":\\\"wH7wY3vSF28hPkb8nGIHrCetptdwshBbRJ26cLXXXic\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"xGsEKDFTEh2-X9S2pNAZrK-L4M6kNfY1jdt8v0HIXfY\"}"