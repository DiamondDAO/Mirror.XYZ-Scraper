"{\"content\":{\"body\":\"## This is a technical overview of the airdrop process for 'The Discovery of Galaxy Joa' by Jupiter Group\\n\\n## Not your average NFT drop!\\n\\nThe technologies involved make this drop pretty much the first of its kind. Using zero-knowledge proofs (`zkSync`) for token minting, `Chainlink VRF` for raffle drawing, and `Storj` for decentralized storage - there's not much more we could've done to make this more web3. And putting it all together in under 4 days is a personal feat of mine :sunglasses:\\n\\nI'd like to expand on each component of this procedure to highlight some technical features and hopefully inspire others to try minting their NFTs in this fashion.\\n\\n## Chaink VRF - a deterministic, fair raffle\\n\\nThe conditions for the drop were that we would take a snapshot of all [Boonji](https://opensea.io/collection/boonjiproject) tokens and their OpenSea listings on the night of December 13th. Out of these owners, we would choose 33 random accounts. As long as the account didn't have their token listed *or* it was listed for at least `3.3 eth` - they would qualify for the drop.\\n\\nThere's a myriad of ways to do this, but we wanted a process that was non-biased, cheap, and simple enough that anyone else could replicate it and generate the same list of winners that we did, provided the same input. For entropy in Solidity, developers can turn to [Chainlink VRF(Verifiable Random Function)](https://docs.chain.link/docs/chainlink-vrf/). The idea is that for every request, the VRF contract generates the random number and a cryptographic proof of how that number was determined. The only trick is the request/callback nature of this procedure, but we don't have to worry about that for this feature. If you need more info on integrating with your solidity contract, [read here](https://docs.chain.link/docs/get-a-random-number/).\\n\\nTo take advantage of this verifiable randomness locally without deploying a contract, we can simply uses `ethers.js` to query the blockchain for the log that the `ChainlinkVRF` contract emits upon completing a request; each event object contains the random number generated that we can use.\\n\\n```javascript\\n// instantiate the contract object using mainnet address/abi\\nconst ChainlinkVRF = await new ethers.Contract(CHAINLINK_VRF_MAINNET, abi, ethersProvider);\\n\\n// query events from a generic block range\\nconst eventFilter = vrf.filters.RandomnessRequestFulfilled();\\nconst events = await vrf.queryFilter(eventFilter, fromBlock, toBlock);\\n```\\n\\nThe random number generated is of type `BigNumber`, but we can parse it to fit our needs.\\n\\n```javascript\\n// guarantee the same random numbers each time by doing rand % limitNumber\\nconst modVal = ethers.BigNumber.from(TOTAL_TOKEN_HOLDERS.toString());\\n\\nconst _getRandomNumberFromEvent = (event) => {\\n  const b = ethers.utils.formatEther(event.args.output); // actually just a BigNumber\\n  const [massiveInteger] = b.split('.');\\n  return parseInt(ethers.BigNumber.from(massiveInteger).mod(modVal).toNumber());\\n}\\n```\\n\\nNow it's just a matter of applying a simple algorithm to deterministically choose the winners. We use word *deterministically* because this process should produce the same output every time, given the same input (the snapshot of winners).\\n\\n```\\nfor each number in `randomNumbers`:\\n 1. retrieve the owner at index in `tokenOwners`\\n  - if owner has listed the token for less than 3.3 ETH => retrieve the next owner (idx+1) until false\\n 2. flag owner as a weiner\\n 3. remove the account from the array of `tokenOwners` for the next draw not to include\\n```\\n\\n## Storj | Decentralized storage of assets and metadata\\n\\nThe protocol of choice for hosting token metadata is [IPFS](https://ipfs.io/), although you would still need to use a pinning service like [Pinata](https://www.pinata.cloud/).\\n\\nHowever, at Jupiter Group we use [Storj](https://www.storj.io/) to host and serve our content. It was a successful integration for the Boonji drop ([see case study](https://www.storj.io/documents/storj-case-study-boonji-project.pdf?utm_content=190414592&utm_medium=social&utm_source=twitter&hss_channel=tw-345738416)) and so we're running with it for future projects. It's secure, highly available, and open source - everything we need for a web3 project.\\n\\nUploading content using the [uplink cli](https://www.storj.io/integrations/uplink-cli) and then sharing it can be done via a bash script\\n\\n```bash\\nuplink cp ./scripts/storj/assets/1.png sj://boonji-joa/assets/1.png\\nuplink share sj://boonji-joa/assets --url --not-after=none\\n```\\n\\nNaturally, we want to automate as much of the process as possible. So the steps required to prep the NFT metadata are:\\n\\n1. have all NFT assets in a local directory\\n2. rename the files to be deterministic based on `tokenId`\\n3. upload and get the public read-access URL\\n4. prepare all token metadata JSON files with the apppropriate values for `name`, `image`, etc\\n5. upload all metadata JSON files and get the public read-access URL\\n\\nAs long as filenames are deterministic based on `tokenId`, the only thing we need to provide the ERC721 contract is the `baseURI`, which in this case will resolve to something like `https://link.us1.storjshare.io/raw/...` (tip: providing the `/raw/` flag will automatically download the file from the browser)\\n\\n## zkSync | Minting NFTs\\n\\nHere is the meat of the project: minting the tokens on a zk-rollup and enabling withdrawals to L1. We highly respect the values behind [zkSync](https://zksync.io/) and the team at [Matter Labs](https://matter-labs.io/). Furthermore, their developer resources are top notch; I can say that with confidence because I hacked this entire drop together in under 4 days without even having looked at their docs prior!\\n\\nThere's many layers to understanding ZK rollups, the UX/transactions, etc. If you want a deep dive, feel free to check out [their Medium page](https://blog.matter-labs.io/). For our purposes, we're just highlight the features of `zkSync` and move on to the steps to minting\\n\\n* extremely low transaction fees, as long as you stay on l2 :)\\n* funds are cryptographically secure\\n* users are always in control of their funds\\n\\nAll the resources I used were [their guide for NFTs](https://zksync.io/dev/nfts.html), [Javascript SDK docs](https://zksync.io/api/sdk/js/tutorial.html), and [environment for deployed contracts](https://zksync.io/api/environments.html).\\n\\nAt a high-level, these are the things we have to do before minting on `zkSync`\\n\\n1. instantiate an ethers wallet to sign transactions on `zkSync`\\n2. activate our account\\n3. **guarantee that our tokens can be withdrawn to L1**\\n4. mint tokens on behalf of other accounts\\n\\n**Step three** is in bold because it's the most important one - any tokens we mint using the `zkSync` SDK only live on the L2, and withdrawal to L1 must be supported. From their docs, there's 3 components to withdrawals to L1:\\n\\n```\\n- Factory: L1 contract that can mint L1 NFT tokens\\n- Creator: user which mints NFT on L2\\n- NFTOwner: user which owns NFT on L2\\n```\\n\\nWithdrawals are essentially an atomic transaction where the token on L1 is burned, and the token on L1 is minted. `zkSync` provides a default \\\"factory\\\" contract on L1 to mint tokens. A developer can almost implement their own \\\"factory\\\" contract to handle the mint on L1. The only two requirements are (1) the contract must implement a specific `mint` function and (2) the contract must be registered with the L1 `Governance` contract via specific function call.\\n\\nIn our case, we needed to implement a custom factory contract as opposed to using the default factory contract because that contract assumes each token's `contentHash` is an IPFS CID, which the default factory contract resolves as `ipfs://${contentHash}` for each `tokenURI`. Since we're using Storj, we have to construct the `tokenURI` differently.\\n\\nOur `BoonjixJoaFactory` contract implements `ERC721` and the required `mintNFTFromZkSync()` function which does the minting of a given token from l2. One thing to note is that we do *not* reuse the provided `tokenId` and instead rely on the token id recovered from `contentHash`. We do use a counter, though, but only to keep track of the current number of tokes minted (see `totalSupply()`).\\n\\nTo satisfy the first requirement - the contract must implement a specific `mint` function, here's our `mintNFTFromZkSync()` function signature. This function is called from the `ZkSync` smart contract when a user goes through the withdrawal process on L2, and takes care of minting on L1 (like calling `_safeMint()`):\\n\\n```solidity\\n/// @dev mints a token from zksync l2\\n/// @notice only the zksync contract can call\\n/// @param creator original minter on l2\\n/// @param recipient account to receive token on l1\\n/// @param creatorAccountId creator account id on l2\\n/// @param serialId enumerable id of tokens minted by the creator\\n/// @param contentHash bytes32 hash of token uri\\n/// @param tokenId the token id (from l2)\\nfunction mintNFTFromZkSync(\\n  address creator,\\n  address recipient,\\n  uint32 creatorAccountId,\\n  uint32 serialId,\\n  bytes32 contentHash,\\n  uint256 tokenId\\n) external override onlyZkSync {}\\n```\\n\\nTo satisfy the second requirement - the contract must be registered with the L1 `Governance` contract, we have to include in our smart contract the following:\\n\\n```solidity\\n/// @dev registers a creator with the zksync Governance contract to bridge tokens from l2\\n/// @param governance the zksync Governance contract\\n/// @param _creatorAccountId the creator account id on zksync\\n/// @param creator a whitelisted creator\\n/// @param signature payload signed by creator\\nfunction registerFactory(\\n  address governance,\\n  uint32 _creatorAccountId,\\n  address creator,\\n  bytes calldata signature\\n) external onlyOwner {\\n  IGovernance(governance).registerNFTFactoryCreator(_creatorAccountId, creator, signature);\\n}\\n```\\n\\nTo generate the required signature, check out [their docs](https://zksync.io/dev/nfts.html#factory-registration), but to make things easier on folks following along, here's my hacky script. It formats all inputs as expected in the signature - you can confirm this by checking out the implementation of the [Governance contract on the zkSync repo](https://github.com/matter-labs/zksync/blob/master/contracts/contracts/Governance.sol#L165)\\n\\n```javascript\\nconst factory = await _getFactoryContract(ethWallet);\\nconst _accountId = await syncWallet.getAccountId();\\nconst _accountIdHex = hre.ethers.utils.hexValue(_accountId);\\nconst accountId = `000${_accountIdHex.split('0x')[1]}`;\\nconst creatorAddress = address.split('0x')[1].toLowerCase();\\nconst factoryAddress = factory.address.split('0x')[1].toLowerCase();\\nconst msg = `\\\\nCreator's account ID in zkSync: ${accountId}\\\\nCreator: ${creatorAddress}\\\\nFactory: ${factoryAddress}`;\\n\\nconst signature = await ethWallet.signMessage(msg);\\nconst tx = await factory.registerFactory(GOVERNANCE_MAINNET, _accountId, address, signature);\\n```\\n\\nNow that our factory contract is registered, we can guarantee that token owners can safely withdraw their NFTs to L1, and a custom factory will be ready handle the minting.\\n\\nHow do we mint? It's pretty straight-forward, actually. There's just a few gotchas along the way.\\n\\nHere's a function that will mint an NFT on `zkSync` with a given contentHash\\n\\n```javascript\\nconst mintNFT = async (syncProvider, syncWallet, recipient, contentHash) => {\\n  const fee = await _logTxFeeSync(syncProvider, syncWallet);\\n  const nft = await syncWallet.mintNFT({\\n    recipient,\\n    contentHash,\\n    feeToken: 'ETH',\\n    fee,\\n  });\\n  await nft.awaitReceipt();\\n};\\n```\\n\\nHere, `recipient` is the address to receive the freshly minted NFT. However, **if the recipient never activated their account on zkSync**, you'll get the following error:\\n\\n```\\nZKSyncTxError: zkSync transaction failed: Recipient account not found\\n```\\n\\nOne way around this is to first transfer a little bit of ETH to this potentially address. From the docs:\\n\\n```\\nUsers can transfer NFTs to existing accounts and transfer to addresses that have not yet registered a zkSync account. TRANSFER and TRANSFER_TO_NEW opcodes will work the same\\n```\\n\\nWe can either mint NFT to ourselves and then transfer, or transfer a little bit of ETH to the recipient to trigger that `TRANSFER_TO_NEW` opcode.\\n\\nOnce the token is minted, the recipient should see it in their zk wallet: <https://wallet.zksync.io/account>. Another gotcha is that transactions on zksync go thorough a state change from `committed` to `verified`. Finality can be achieved usually within the hour, and only then can accounts withdraw to L1.\\n[wallet](https://link.us1.storjshare.io/raw/juqoeqikhodvo2puepob3lszpbfq/boonji-joa%2FScreen%20Shot%202021-12-16%20at%205.04.50%20PM.png)\\n\\nFinally, when a token has reached finality and is in the `verified` state (2 green arrows in the UI), it can be withdrawn to L1 here: <https://wallet.zksync.io/transaction/nft/withdraw>\\n[withdraw](https://link.us1.storjshare.io/raw/jwvcdhxmhq7yef5u7bufvhrjydvq/boonji-joa%2FScreen%20Shot%202021-12-16%20at%205.07.31%20PM.png).\\n\\n## Conclusion\\n\\nPutting all components together, going through a few rinkeby dry runs, and deploying on mainnet was quite the experience; it's exhilarating to be on the cutting edge. With `zkSync` soon supporting smart contracts written in Solidity, it's all but guaranteed that protocols will take advantage of cheap and fast transaction finality and port their Solidity code over.\\n\\nWe had DefiSummer in 2020.\\n\\nNFTs took over in 2021.\\n\\n**2022 will be the year of zk-rollups**.\",\"timestamp\":1639701174,\"title\":\"Minting NFTs on ZkSync | Jupiter Group\"},\"digest\":\"IiypIxUHOkSsaTXF6SpAR5ZlBjjIubMN9x8Ymw6LXJg\",\"authorship\":{\"contributor\":\"0x28ff8e457feF9870B9d1529FE68Fbb95C3181f64\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"HgScCGlXm1RefJKCv9y46e7hc_XKzQETPGweOjk4B5E\\\",\\\"y\\\":\\\"GuZGtJfE_BUD4FIOqC54SJcWFqgbhGgipAUUgEH64fc\\\"}\",\"signature\":\"urCxgTtPPx3sdOvA3yPeqMEkJFCja3Wl_S8dXoP8x2POnUQqHimB1HBPHq84P0hc37Qb-ccCzIaSJASHltXYCw\",\"signingKeySignature\":\"0xc21b58d0f322958613ca437204dfac4c1c8a38619d45d7f96cb316adb9205431100ab71eb0cdf2afd1914b3f28bdb08da95495ce0a4ec713e6d32539b41790cb1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"HgScCGlXm1RefJKCv9y46e7hc_XKzQETPGweOjk4B5E\\\",\\\"y\\\":\\\"GuZGtJfE_BUD4FIOqC54SJcWFqgbhGgipAUUgEH64fc\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"IiypIxUHOkSsaTXF6SpAR5ZlBjjIubMN9x8Ymw6LXJg\"}"