"{\"content\":{\"body\":\"![](https://images.mirror-media.xyz/publication-images/60d940cf-0d56-42b7-a48e-b6dd302470ea.jpg?height=640&width=1280)\\n\\nOver the past few weeks, I built a few apps that integrated with [Mirror](https://mirror.xyz), to try and understand how their protocol worked. I started using their internal APIs and, from there, worked my way to more decentralized sources. Here’s how I did it (and how you can too).\\n\\n## The Actual Write Race\\n\\nThe idea for [The Actual Write Race](https://write-race.m1guelpf.me) was to build a list of all existing Mirror publications, and rank them based on the number of articles they had written (simulating Mirror’s $WRITE race) to add a fun touch.\\n\\nTo get the list of publications, we can query the Mirror GraphQL API (live at `https://mirror-api.com/graphql`) with the following query:\\n\\n```graphql\\nquery FetchPublications {\\n    publications {\\n        ensLabel\\n        displayName\\n\\tavatarURL\\n\\tcontributor {\\n\\t    displayName\\n\\t    avatarURL\\n\\t    address\\n        }\\n    }\\n}\\n```\\n\\nThe `publications` query will give us most of the data we need, and if I were to build a simple listing I could have stopped here, but I also need the number of entries to rank them. Ideally, I should just be able to fetch the `entries` key on the above query, but due to how Mirror has structured their API, the entries are set to `null` when querying the publication list. Instead, we can use a second query to fetch the entries for each publication and check the length of those.\\n\\n```graphql\\nquery PublicationEntries($ensLabel: String!) {\\n    publication(ensLabel: $ensLabel) {\\n        ensLabel\\n        entries {\\n            digest\\n        }\\n    }\\n}\\n```\\n\\nIt’s not the best system, and it has a blatant N+1 issue, but it’s the best I could get for this project, and the data is only fetched once a day, so it didn’t end up being an issue. If you want to learn more about this project, [the source is available on GitHub](https://github.com/m1guelpf/write-race).\\n\\n## Mirror Client\\n\\nThe Mirror interface is beautiful, and I wanted to take a chance at recreating it with [Tailwind CSS](https://tailwindcss.com), so I decided to build a custom Mirror client with [Next.js](https://nextjs.com). The hard part of this project turned out to be retrieving Mirror entries in a decentralized way (querying the blockweave instead of Mirror’s API).\\n\\nTo start, we need to know the wallet address of the publication owner. Since Mirror subdomains are ENS names, we can do this by resolving `{publication}.mirror.xyz` with any ENS resolver. With this information, we can query the blockweave (which conveniently offers a GraphQL API hosted at `https://arweave.net/graphql`) by retrieving transactions created by Mirror and signed by that wallet address:\\n\\n```graphql\\nquery FetchTransactions($address: String!) {\\n    transactions(first: 100, tags: [{ name: \\\"App-Name\\\", values: [\\\"MirrorXYZ\\\"] }, { name: \\\"Contributor\\\", values: [$address] }]) {\\n        edges {\\n            node {\\n                id\\n                tags {\\n                    name\\n                    value\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSince Mirror supports editing entries by pushing additional transactions, we need to check the `Original-Content-Digest` tag to make sure we only take the latest edition of each entry into account. We’ll use that original digest as the slug for the post (emulating Mirror) and the node ID to fetch the entry from the blockweave using the Arweave NPM library.\\n\\n```js\\nconst getPaths = async () => {\\n    const {\\n        data: {\\n            transactions: { edges },\\n        },\\n    } = await queryGraphQL()\\n\\n    edges.map(({ node }) => {\\n        const tags = Object.fromEntries(node.tags.map(tag => [tag.name, tag.value]))\\n\\t\\t\\n        return { slug: tags['Original-Content-Digest'], path: node.id }\\n    }).filter(entry => entry.slug && entry.slug !== '').reduce((acc, current) => {\\n        const x = acc.find(entry => entry.slug === current.slug)\\n\\t\\t\\n        if (!x) return acc.concat([current])\\n        else return acc\\n    }, [])\\n}\\n\\nconst getEntries = async () => {\\n    const paths = await getPaths()\\n\\t\\t\\n    return Promise.all(\\n        paths.map(async entry => JSON.parse(\\n            await arweave.transactions.getData(entry.path, { decode: true, string: true }), entry.slug)\\n        )\\n    )\\n}\\n```\\n\\nThis will get you an array of entries following [this format](https://fr7z6iuftumjyixkaozevog2og5weiop5xzjl7jxp4jq2jegwz2q.arweave.net/LH-fIoWdGJwi6gOySrjacbtiIc_t8pX9N38TDSSGtnU), you can then just parse the markdown bodies and render your entries.\\n\\nThen, to fetch the contents of a single entry, you can query by the original content digest (which we’re using as a slug).\\n\\n```graphql\\nquery FetchTransaction($digest: String!) {\\n    transactions(tags: { name: \\\"Original-Content-Digest\\\", values: [$digest] }) {\\n        edges {\\n            node {\\n                id\\n            }\\n        }\\n    }\\n}\\n```\\n\\nKeep in mind in this example we’re not verifying the signature of any of these entries, so anyone could add new entries with a random string as the signature. Ideally, you’d use a library like `eth-sig-util` to make sure all entries are authentic.\\n\\nIf you’re curious about the source of my Mirror client, it’s [available on GitHub](https://github.com/m1guelpf/mirror-next). You can also see it live [at m1guelpf.blog](https://m1guelpf.blog).\\n\\n## Extending Mirror\\n\\nWith these two data sources (Mirror’s GraphQL API & the blockweave), you can build anything on top of Mirror. Here are a few ideas:\\n\\n- RSS feeds for Mirror blogs (my Mirror client [already includes an RSS feed](https://m1guelpf.blog/feed.xml), you’d just need to make it work with any other publication\\n- A substack-like app that watches for new entries on a specific publication (or maybe all of them?) and emails subscribers the content.\\n- A interface allowing people who don’t yet have a Mirror publication to publish their articles on Arweave using the same format Mirror uses.\\n\\nMake sure to send me any cool apps you build with Mirror! You can find me at [@m1guelpf](https://twitter.com/m1guelpf) on Twitter.\",\"timestamp\":1617409673,\"title\":\"Building apps with Mirror\",\"publication\":\"miguel\"},\"digest\":\"ofY4m25Sc-_LKy3BhRIQ0Dsf3Vz8FyB1EEy1kf8tXCk\",\"authorship\":{\"contributor\":\"0xE340b00B6B622C136fFA5CFf130eC8edCdDCb39D\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"_7N5IkC7jJf12RCIHsh8NpFwxtsbnerOFQmJ4A3_Yao\\\",\\\"y\\\":\\\"XjWHfjIYuFPdWtWgb3o9q-7kCw29d3RxLYvFSJ8fxKY\\\"}\",\"signature\":\"1YYk7ylwrs4Vh7nDgr-fU0Fnsw5AMUREukCG8KI4jwH8Nck2hKadHfz7k9uF_z_F-x4hm0AdWgQ6ppKgAg9zWA\",\"signingKeySignature\":\"0x0cc0cd7a75bf04a6d6d139a25dcee648e22d41b59f312e0e8250db837906fdfd46597fc249815b4886e31df5e2ac7dc12c3c5bbb9e35c141df576254af2060321b\",\"signingKeyMessage\":\"I authorize the publication of articles on miguel.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"_7N5IkC7jJf12RCIHsh8NpFwxtsbnerOFQmJ4A3_Yao\\\",\\\"y\\\":\\\"XjWHfjIYuFPdWtWgb3o9q-7kCw29d3RxLYvFSJ8fxKY\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"ofY4m25Sc-_LKy3BhRIQ0Dsf3Vz8FyB1EEy1kf8tXCk\"}"