"{\"content\":{\"body\":\"ES7 到 ES12 常用新语法\\n众所周知，ECMAScript 的迭代是很快的，想必作为前端开发人员对近几年 ES6 的新语法已经十分熟悉了，但是 ES7 到 ES12 中一些新增的 ECMAScript 提案，可能还是没有广泛地被开发者所熟知。本文带着大家一起来了解一下 2016 到 2021 年新增的一些 ECMAScript 语法以及提案，帮助大家更好地应用于自己的项目中。\\n\\nTC39 规范介绍：\\nStage 0（strawman），任何 TC39 的成员都可以提交。\\nStage 1（proposal），进入此阶段意味着这一提案被认为是正式的了，需要对此提案的场景与 API 进行详尽的描述。\\nStage 2（draft），这一阶段的提案如果能最终进入到标准，那么在之后的阶段都不会有太大的变化，因为理论上只接受增量修改。\\nStage 3（candidate），这一阶段的提案只有在遇到了重大问题才会修改，规范文档需要被全面的完成。\\nStage 4（finished），这一阶段的提案将会被纳入到 ES 每年发布的规范之中。\\n\\nES7（ES2016）\\n\\n1、Array.prototype.includes\\n\\n概述\\n\\nincludes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n使用 ECMAScript 数组时，通常需要确定数组是否包含某个元素。普遍的方法是：\\nif (arr.indexOf(el) !== -1) {\\n...\\n}\\n严格意义来说，使用 indexOf 来确定数组中是否包含某个元素是存在问题的：\\n\\n语义不符，我们的目的是想知道数组中是否包含某个元素，并不是想知道数组中某个元素首次出现的索引。\\n对 NaN 不生效，\\\\[NaN\\\\].indexOf(NaN) === -1。\\n\\n语法\\n\\narr.includes(valueToFind\\\\[, fromIndex\\\\])\\n\\nvalueToFind：需要查找的元素值。\\n\\nfromIndex：可选的。从 fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 arr.length + fromIndex 的索引开始搜（即从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。\\n\\n例子：\\n\\\\[1, 2, 3\\\\].includes(2);     // true\\n\\\\[1, 2, 3\\\\].includes(4);     // false\\n\\\\[1, 2, 3\\\\].includes(3, 3);  // false\\n\\\\[1, 2, 3\\\\].includes(3, -1); // true\\n\\\\[1, 2, NaN\\\\].includes(NaN); // true\\n\\n注意事项\\n1、如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。\\nconst arr = \\\\['a', 'b', 'c'\\\\];\\narr.includes('c', 3);   // false\\narr.includes('c', 100); // false\\n2、如果 fromIndex 为负值，计算出的索引将作为开始搜索 valueToFind 的位置。如果计算出的索引小于 0，则整个数组都会被搜索。\\n// array length is 3\\n// fromIndex is -100\\n// computed index is 3 + (-100) = -97\\n\\nconst arr = \\\\['a', 'b', 'c'\\\\];\\n\\narr.includes('a', -100); // true\\narr.includes('b', -100); // true\\narr.includes('c', -100); // true\\narr.includes('a', -2);   // false\\n3、includes() 方法有意设计为通用方法。它不要求 this 值是数组对象，所以它可以被用于其他类型的对象（比如类数组对象）。下面的例子展示了在函数的 arguments 对象上调用 includes() 方法。\\n(function() {\\nconsole.log(\\\\[\\\\].includes.call(arguments, 'a')); // true\\nconsole.log(\\\\[\\\\].includes.call(arguments, 'd')); // false\\n})('a', 'b', 'c');\\n\\n2、Exponentiation Operator\\n\\n概述\\n\\n求幂运算符（\\\\*\\\\*）返回将第一个操作数加到第二个操作数的幂的结果。它等效于 Math.pow，不同之处在于它也接受 BigInt 作为操作数。\\n该提案目前处于 Stage 3 阶段。\\nTC39 直通车\\n\\n语法\\n\\nOperator: var1 \\\\*\\\\* var2\\n\\n求幂运算符是是右结合的: a \\\\*\\\\* b \\\\*\\\\* c 等于 a \\\\*\\\\* (b \\\\*\\\\* c)。\\n例子：\\n2 \\\\*\\\\* 3   // 8\\n3 \\\\*\\\\* 2   // 9\\n3 \\\\*\\\\* 2.5 // 15.588457268119896\\n10 \\\\*\\\\* -1 // 0.1\\nNaN \\\\*\\\\* 2 // NaN\\n\\n2 \\\\*\\\\* 3 \\\\*\\\\* 2   // 512\\n2 \\\\*\\\\* (3 \\\\*\\\\* 2) // 512\\n(2 \\\\*\\\\* 3) \\\\*\\\\* 2 // 64\\n\\n\\\\-(2 \\\\*\\\\* 2) // -4\\n\\n(-2) \\\\*\\\\* 2 // 4\\n\\nES8（ES2017）\\n\\n1、async 和 await\\n\\n概述\\n\\nasync 和 await 关键字是基于 Generator 函数的语法糖，使异步代码更易于编写和阅读。通过使用它们，异步代码看起来更像是老式同步代码。\\nTC39 直通车\\n\\n动机\\n简化异步编程写法。\\n使用 Generator 函数，依次读取两个文件：\\nconst fs = require('fs');\\n\\nconst readFile = function (fileName) {\\nreturn new Promise(function (resolve, reject) {\\nfs.readFile(fileName, function(error, data) {\\nif (error) return reject(error);\\nresolve(data);\\n});\\n});\\n};\\n\\nconst gen = function\\\\* () {\\nconst f1 = yield readFile('/etc/fstab');\\nconst f2 = yield readFile('/etc/shells');\\nconsole.log(f1.toString());\\nconsole.log(f2.toString());\\n};\\n\\n上面代码的函数 gen 可以写成 async 函数，就是下面这样：\\nconst asyncReadFile = async function () {\\nconst f1 = await readFile('/etc/fstab');\\nconst f2 = await readFile('/etc/shells');\\nconsole.log(f1.toString());\\nconsole.log(f2.toString());\\n};\\n一比较就会发现，async 函数就是将 Generator 函数的星号（\\\\*）替换成 async，将 yield 替换成 await。\\nasync 函数对 Generator 函数的改进，体现在以下四点：\\n\\n内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\\n更好的语义。async 和 await，比起星号（\\\\*）和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\\n更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值等，但这时会自动转成立即 resolved 的 Promise 对象）。\\n返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。\\n\\n语法\\nasync function getData() {\\n  const res = await api.getTableData(); // await 异步任务\\n  // do something  \\n}\\n例子：\\nasync function getStockPriceByName(name) {\\nconst symbol = await getStockSymbol(name);\\nconst stockPrice = await getStockPrice(symbol);\\nreturn stockPrice;\\n}\\n\\ngetStockPriceByName('goog').then(function (result) {\\nconsole.log(result);\\n});\\n\\n2、Object.values 和 Object.entries\\n\\n概述\\n\\nObject.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同（区别在于 for...in 循环枚举原型链中的属性）。\\nObject.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for...in 循环还会枚举原型链中的属性）。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n语法\\n\\nObject.values(obj)\\n\\nobj：被返回可枚举属性值的对象。\\n\\nObject.entries(obj)\\n\\nobj：可以返回其可枚举属性的键值对的对象。\\n\\n例子：\\nObject.values({a: 1, b: 2, c: 3});  // \\\\[1, 2, 3\\\\]\\nObject.keys({a: 1, b: 2, c: 3});    // \\\\[a, b, c\\\\]\\nObject.entries({a: 1, b: 2, c: 3}); // \\\\[\\\\[\\\"a\\\", 1\\\\], \\\\[\\\"b\\\", 2\\\\], \\\\[\\\"c\\\", 3\\\\]\\\\]\\n\\n3、Object.getOwnPropertyDescriptors\\n\\n概述\\n\\n获取一个对象所有自身属性的描述符，如果没有任何自身属性，则返回空对象。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\nECMAScript 中没有一个方法能够简化两个对象之间的拷贝。如今，函数式编程和不可变对象是复杂应用程序的重要组成部分，每个框架或库都在实现自己的样板文件，以便在组合对象或原型之间正确复制属性。\\n回到 Object.assign，它大多数情况下会出现一些不希望出现的行为，因为它的复制方式会吞噬行为：它直接访问属性和符号，而不是它们的描述符，丢弃可能的访问器，在组合更复杂的对象或类的原型时可能会导致危险。\\n检索所有描述符，无论是否可枚举，也是实现类及其原型组合的关键，因为默认情况下，它们具有不可枚举的方法和访问器。\\n此外，装饰器可以轻松地从一个类或 mixin 中获取所有描述符，并通过 Object.defineProperties 过滤不需要的描述符。\\nObject.assign 只适合做对象的浅拷贝。\\n\\n语法\\n\\nObject.getOwnPropertyDescriptors(obj)\\n\\nobj：任意对象\\n\\n例子：\\nconst a = {\\nb: 123,\\nc: '文字内容',\\nd() { return 2; }\\n};\\nObject.getOwnPropertyDescriptors(a);\\n// 输出结果\\n{\\nb:{\\nconfigurable: true,\\nenumerable: true,\\nvalue: 123,\\nwritable: true,\\n\\\\[\\\\[Prototype\\\\]\\\\]: Object,\\n}\\nc:{\\nconfigurable: true,\\nenumerable: true,\\nvalue: \\\"文字内容\\\",\\nwritable: true,\\n\\\\[\\\\[Prototype\\\\]\\\\]: Object,\\n}\\nd:{\\nconfigurable: true,\\nenumerable: true,\\nvalue: ƒ d(),\\nwritable: true,\\n\\\\[\\\\[Prototype\\\\]\\\\]: Object,\\n},\\n\\\\[\\\\[Prototype\\\\]\\\\]: Object,\\n}\\n\\n4、String.prototype.padStart 和 String.prototype.padEnd\\n\\n概述\\n\\npadStart() 方法用另一个字符串填充当前字符串（如果需要的话，会重复多次），以便产生的字符串达到给定的长度。从当前字符串的开头（左侧）开始填充。\\npadEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n语法\\n\\nstr.padStart(targetLength \\\\[, padString\\\\])\\n\\ntargetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\\n\\npadString：可选的。填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 \\\" \\\"（U+0020）。\\n\\nstr.padEnd(targetLength \\\\[, padString\\\\])\\n\\ntargetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\\n\\npadString：可选的。填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 \\\" \\\"（U+0020）。\\n\\n例子：\\n'abc'.padStart(10);         // \\\"       abc\\\"\\n'abc'.padStart(10, \\\"foo\\\");  // \\\"foofoofabc\\\"\\n'abc'.padStart(6,\\\"123465\\\"); // \\\"123abc\\\"\\n'abc'.padStart(8, \\\"0\\\");     // \\\"00000abc\\\"\\n'abc'.padStart(1);          // \\\"abc\\\"\\n'abc'.padEnd(10);          // \\\"abc       \\\"\\n'abc'.padEnd(10, \\\"foo\\\");   // \\\"abcfoofoof\\\"\\n'abc'.padEnd(6, \\\"123456\\\"); // \\\"abc123\\\"\\n'abc'.padEnd(1);           // \\\"abc\\\"\\n\\nES9（ES2018）\\n\\n1、for await...of\\n\\n概述\\n\\nfor await...of 语句创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象，包括: 内置的 String、Array、类似数组对象（例如 arguments 或 NodeList）、TypedArray、Map、Set 和用户定义的异步/同步迭代器。它使用对象的每个不同属性的值调用要执行的语句来调用自定义迭代钩子。\\n类似于 await 运算符一样，该语句只能在一个 async function 内部使用。\\nTC39 直通车\\n\\n动机\\n迭代器接口（在 ECMAScript 2015 中引入）是一种顺序数据访问协议，它支持开发通用和可组合的数据使用者和转换器。\\n由于在迭代器方法返回时必须知道序列中的下一个值和数据源的“完成”状态，因此迭代器仅适用于表示同步数据源。虽然 JavaScript 程序员遇到的许多数据源是同步的（例如内存列表和其他数据结构），但许多其他数据源不是。例如，任何需要 I/O 访问的数据源通常会使用基于事件或流式异步 API 来表示。不幸的是，迭代器不能用于表示这样的数据源。\\n（即使是 promise 的迭代器也是不够的，因为它只允许异步确定值，但需要同步确定“完成”状态。）\\n为了为异步数据源提供通用的数据访问协议，因此引入了异步迭代语句 for await...of。\\n\\n语法\\n\\nasync function process(iterable) {\\n  for await (variable of iterable) {\\n// Do something.\\n}\\n}\\n\\nvariable：在每次迭代中，将不同属性的值分配给变量。变量有可能以 const、let 或者 var 来声明。\\n\\niterable：被迭代枚举其属性的对象。与 for...of 相比，这里的对象可以返回 Promise，如果是这样，那么 variable 将是 Promise 所包含的值，否则是值本身。\\n\\n例子：\\nfunction getTime(seconds){\\nreturn new Promise(resolve=>{\\nsetTimeout(() => {\\nresolve(seconds)\\n}, seconds);\\n})\\n}\\nasync function test(){\\nlet arr = \\\\[getTime(500), getTime(300), getTime(3000)\\\\];\\nfor await (let x of arr){\\nconsole.log(x); // 500  300 3000 按顺序的\\n}\\n}\\n\\ntest()\\n\\n2、Promise.prototype.finally\\n\\n概述\\n\\nfinally() 方法返回一个 Promise。在 Promise 结束时，无论结果是 fulfilled 还是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。\\n这避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。\\nTC39 直通车\\n\\n动机\\n有些时候在 Promise 完成时，不管结果是 fulfilled 还是 rejected，我们想执行一些清理工作，或是设置一些变量，这个是时候，我们不得不在 resolve 和 catch 中把同样的代码书写两遍，这是重复且无意义的工作。\\nPromise.finally() 提案，可以在 Promise 完成时，无论结果是 fulfilled 还是 rejected，都会执行 finally 函数。\\n\\n语法\\n\\nPromise.resolve().then().catch(e => e).finally(onFinally);\\n\\nonFinally：Promise 结束后调用的 Function。\\n\\n例子：\\nlet isLoading = true;\\nfetch(myRequest).then(function(response) {\\nconst contentType = response.headers.get(\\\"content-type\\\");\\nif(contentType && contentType.includes(\\\"application/json\\\")) {\\nreturn response.json();\\n}\\nthrow new TypeError(\\\"Oops, we haven't got JSON!\\\");\\n})\\n.then(function(json) { /\\\\* process your JSON further \\\\*/ })\\n.catch(function(error) { console.log(error); })\\n.finally(function() { isLoading = false; });\\n\\n注意事项\\nfinally() 虽然与 .then(onFinally, onFinally) 类似，但它们不同的是：\\n\\n调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\\n由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。\\n与 Promise.resolve(2).then(() => {}, () => {})（resolved 的结果为 undefined）不同，Promise.resolve(2).finally(() => {}) resolved 的结果为 2。\\n同样，Promise.reject(3).then(() => {}, () => {})（fulfilled 的结果为 undefined），Promise.reject(3).finally(() => {}) rejected 的结果为 3。\\n\\n3、Object Rest/Spread Properties\\n\\n概述\\n\\n将 Rest 语法添加到解构中。Rest 属性收集那些尚未被解构模式拾取的剩余可枚举属性键。\\n将 Spread 语法添加到对象字面量中。将已有对象的所有可枚举（ enumerable ）属性拷贝到新构造的对象中。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n浅拷贝（Shallow-cloning，不包含 prototype）和对象合并，可以使用更简短的 Spread 语法。而不必再使用 Object.assign() 方式。\\nconst obj1 = { foo: 'bar', x: 42 };\\nconst obj2 = { foo: 'baz', y: 13 };\\n\\nconst clonedObj = { ...obj1 };\\n// 克隆后的对象: { foo: \\\"bar\\\", x: 42 }\\n\\nconst mergedObj = { ...obj1, ...obj2 };\\n// 合并后的对象: { foo: \\\"baz\\\", x: 42, y: 13 }\\n有些时候我们在解构一个对象时，可能只关心它的其中一两个属性，这个时候 Rest 语法可以极大简化变量提取过程。\\nconst { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\\nx; // 1\\ny; // 2\\n\\n语法\\nRest\\nconst { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\\nx; // 1\\ny; // 2\\nz; // { a: 3, b: 4 }\\nSpread\\nlet n = { x, y, ...z };\\nn; // { x: 1, y: 2, a: 3, b: 4 }\\n\\n注意事项\\nObject.assign() 函数会触发 setters，而 Spread 语法则不会。\\n\\nES10（ES2019）\\n\\n1、Array.prototype.flat 和 Array.prototype.flatMap\\n\\n概述\\n\\nflat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\\nflatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\\nflatMap 方法与 map 方法结合深度 depth 为 1 的 flat 几乎相同。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n如果我们想扁平化一个多层嵌套的数组，代码如下：\\n// 使用 reduce、concat 和递归展开无限多层嵌套的数组\\nconst arr = \\\\[1, 2, 3, \\\\[1, 2, 3, 4, \\\\[2, 3, 4\\\\]\\\\]\\\\];\\n\\nfunction flatDeep(arr, d = 1) {\\nreturn d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), \\\\[\\\\]) : arr.slice();\\n};\\n\\nflatDeep(arr, Infinity);\\n// \\\\[1, 2, 3, 1, 2, 3, 4, 2, 3, 4\\\\]\\nflat 提案正是用来简化这个流程：\\nconst arr = \\\\[1, 2, 3, \\\\[1, 2, 3, 4, \\\\[2, 3, 4\\\\]\\\\]\\\\];\\narr.flat(Infinity);\\n// \\\\[1, 2, 3, 1, 2, 3, 4, 2, 3, 4\\\\]\\n如果我们想将包含几句话的数组拆分成单个词组成的新数组，代码如下：\\nconst arr = \\\\[\\\"it's Sunny in\\\", \\\"\\\", \\\"California\\\"\\\\];\\nconst arr1 = arr.map(x => x.split(\\\" \\\"));\\n// \\\\[\\\\[\\\"it's\\\",\\\"Sunny\\\",\\\"in\\\"\\\\],\\\\[\\\"\\\"\\\\],\\\\[\\\"California\\\"\\\\]\\\\];\\narr1.flat(2);\\n// \\\\[\\\"it's\\\", \\\"Sunny\\\", \\\"in\\\", \\\"\\\", \\\"California\\\"\\\\]\\nflatMap 提案可以用来简化该流程：\\nconst arr = \\\\[\\\"it's Sunny in\\\", \\\"\\\", \\\"California\\\"\\\\];\\narr.flatMap(x => x.split(\\\" \\\"));\\n// \\\\[\\\"it's\\\", \\\"Sunny\\\", \\\"in\\\", \\\"\\\", \\\"California\\\"\\\\]\\n\\n语法\\n\\narr.flat(\\\\[depth\\\\])\\n\\ndepth：可选的。指定要提取嵌套数组的结构深度，默认值为 1。\\n\\n例子：\\n\\\\[1, 2, \\\\[3, 4\\\\]\\\\].flat(1); \\n// \\\\[1, 2, 3, 4\\\\]\\n\\n\\\\[1, 2, \\\\[3, 4, \\\\[5, 6\\\\]\\\\]\\\\].flat(2); \\n// \\\\[1, 2, 3, 4, 5, 6\\\\]\\n\\n\\\\[1, 2, \\\\[3, 4, \\\\[5, 6\\\\]\\\\]\\\\].flat(Infinity); \\n// \\\\[1, 2, 3, 4, 5, 6\\\\]\\n\\narr.flatMap(\\nfunction callback(\\ncurrentValue\\\\[, index\\\\[, array\\\\]\\\\]) {\\n// return element for new_array\\n}\\\\[, thisArg\\\\])\\n\\ncallback：可以生成一个新数组中的元素的函数，可以传入三个参数：\\n\\ncurrentValue：当前正在数组中处理的元素。\\n\\nindex：可选的。数组中正在处理的当前元素的索引。\\n\\narray：可选的。数组中正在处理的当前元素的索引。\\n\\nthisArg：可选的。执行 callback 函数时 使用的 this 值。\\n\\n例子：\\n\\\\[1, 2, 3, 4\\\\].flatMap(a => \\\\[a \\\\*\\\\* 2\\\\]); \\n// \\\\[1, 4, 9, 16\\\\]\\nmap() 与 flatMap()\\nconst arr1 = \\\\[1, 2, 3, 4\\\\];\\n\\narr1.map(x => \\\\[x \\\\* 2\\\\]);\\n// \\\\[\\\\[2\\\\], \\\\[4\\\\], \\\\[6\\\\], \\\\[8\\\\]\\\\]\\n\\narr1.flatMap(x => \\\\[x \\\\* 2\\\\]);\\n// \\\\[2, 4, 6, 8\\\\]\\n\\narr1.map(x => \\\\[x \\\\* 2\\\\]).flat(1);\\n// \\\\[2, 4, 6, 8\\\\]\\n\\n// only one level is flattened\\narr1.flatMap(x => \\\\[\\\\[x \\\\* 2\\\\]\\\\]);\\n// \\\\[\\\\[2\\\\], \\\\[4\\\\], \\\\[6\\\\], \\\\[8\\\\]\\\\]\\nlet arr1 = \\\\[\\\"it's Sunny in\\\", \\\"\\\", \\\"California\\\"\\\\];\\n\\narr1.map(x => x.split(\\\" \\\"));\\n// \\\\[\\\\[\\\"it's\\\",\\\"Sunny\\\",\\\"in\\\"\\\\],\\\\[\\\"\\\"\\\\],\\\\[\\\"California\\\"\\\\]\\\\]\\n\\narr1.flatMap(x => x.split(\\\" \\\"));\\n// \\\\[\\\"it's\\\",\\\"Sunny\\\",\\\"in\\\", \\\"\\\", \\\"California\\\"\\\\]\\n\\n2、Object.fromEntries\\n\\n概述\\n\\nObject.fromEntries() 方法把键值对列表转换为一个对象。\\nObject.fromEntries() 执行与 Object.entries 互逆的操作。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\nconst obj = { foo: true, bar: false };\\nconst map = new Map(Object.entries(obj));\\n如果要将类似上面代码中的 map 再转换为 obj，我们不得不编写帮助函数：\\nconst obj = Array.from(map).reduce((acc, \\\\[key, val\\\\]) => Object.assign(acc, { \\\\[key\\\\]: val }), {});\\nObject.fromEntries 提案正是用来简化这个流程。\\n\\n语法\\n\\nObject.fromEntries(iterable);\\n\\niterable：类似 Array、Map 或者其它实现了可迭代协议的可迭代对象。\\n\\n例子：\\n嵌套数组\\nconst obj = Object.fromEntries(\\\\[\\\\['a', 0\\\\], \\\\['b', 1\\\\]\\\\]);\\n// { a: 0, b: 1 }\\nObject.entries\\nconst obj = { abc: 1, def: 2, ghij: 3 };\\nconst res = Object.fromEntries(\\nObject.entries(obj)\\n.filter((\\\\[key, val\\\\]) => key.length === 3)\\n.map((\\\\[key, val\\\\]) => \\\\[key, val \\\\* 2\\\\])\\n);\\n// { abc: 2, def: 4 }\\n通过 Object.fromEntries，可以将 Map 转化为 Object：\\nconst map = new Map(\\\\[\\\\['a', 1\\\\], \\\\['b', 2\\\\], \\\\['c', 3\\\\]\\\\]);\\nconst obj = Object.fromEntries(map);\\n// { a: 1, b: 2, c: 3 }\\n\\n3、String.prototype.trimStart 和 String.prototype.trimEnd\\n\\n概述\\n\\n去除字符串首尾的连续空白符。\\ntrimStart() 方法从字符串的开头删除空白符。trimLeft() 是此方法的别名。\\ntrimEnd() 方法从字符串的结尾删除空白符。trimRight() 是此方法的别名。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\nES5 标准化了 String.prototype.trim。\\n所有主要搜索引擎也实现了相应的 trimLeft 和 trimRight 功能，但是无任何标准规范。\\n为了与 padStart/padEnd 保持一致，所以提议使用 trimStart 和 trimEnd。\\n考虑到不同浏览器的兼容性问题，trimLeft/trimRight 将作为 trimStart/trimEnd 的别名使用。\\nString.prototype.trimLeft === String.prototype.trimStart;\\n// true\\nString.prototype.trimRight === String.prototype.trimEnd;\\n// true\\n\\n语法\\nconst greeting = '   Hello world!   ';\\nconsole.log(greeting.trimStart());\\n// \\\"Hello world!   \\\";\\nconsole.log(greeting.trimEnd());\\n// \\\"   Hello world!\\\";\\n\\n4、Optional Catch Binding\\n\\n概述\\n\\n该提案对 ECMAScript 进行了语法更改，允许在不使用 catch 绑定的情况下省略 catch 绑定。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\ntry {\\n// try to use a web feature which may not be implemented\\n} catch (unused) {\\n// fall back to a less desirable web feature with broader support\\n}\\nlet isTheFeatureImplemented = false;\\ntry {\\n// stress the required bits of the web API\\nisTheFeatureImplemented = true;\\n} catch (unused) {}\\n普遍认为，声明或写入从未读取的变量会引发程序错误。\\n\\n语法\\ntry {\\n// ...\\n} catch {\\n// ...\\n}\\n\\n5、Symbol.prototype.description\\n\\n概述\\n\\nSymbol 对象可以通过一个可选的描述创建，可用于调试，但不能用于访问 symbol 本身。\\nSymbol.prototype.description 属性可以用于读取该描述。与 Symbol.prototype.toString() 不同的是它不会包含 \\\"Symbol()\\\" 的字符串。\\ndescription 是一个只读属性，它会返回 Symbol 对象的可选描述的字符串。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n直接暴露 symbol 的 description 内部插槽，取代通过 symbol.prototype.toString 间接暴露。\\n\\n语法\\nSymbol('myDescription').description;\\n\\nSymbol.iterator.description;\\n\\nSymbol.for('foo').description;\\n例子：\\nSymbol('desc').toString();  // \\\"Symbol(desc)\\\"\\nSymbol('desc').description; // \\\"desc\\\"\\nSymbol('').description;     // \\\"\\\"\\nSymbol().description;       // undefined\\n\\n// well-known symbols\\nSymbol.iterator.toString();  // \\\"Symbol(Symbol.iterator)\\\"\\nSymbol.iterator.description; // \\\"Symbol.iterator\\\"\\n\\n// global symbols\\nSymbol.for('foo').toString();  // \\\"Symbol(foo)\\\"\\nSymbol.for('foo').description; // \\\"foo\\\"\\n\\nES11（ES2020）\\n\\n1、String.prototype.matchAll\\n\\n概述\\n\\nmatchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。\\nTC39 直通车\\n\\n动机\\n之前，如果我们要获取所有匹配项信息，只能通过循环调用 regexp.exec()（ regexp 需使用 /g 标志）：\\nconst regexp = RegExp('foo\\\\[a-z\\\\]\\\\*', 'g');\\nconst str = 'table football, foosball';\\nlet match;\\n\\nwhile ((match = regexp.exec(str)) !== null) {\\nconsole.log(`Found ${match[0]} start = ${match.index} end = ${regexp.lastIndex}.`);\\n// expected output: \\\"Found football start=6 end=14.\\\"\\n// expected output: \\\"Found foosball start=16 end=24.\\\"\\n}\\n如果使用 matchAll，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用 /g 标志）。使用 matchAll 会得到一个迭代器的返回值，配合 for...of、array spread 或者 Array.from() 可以更方便实现功能。\\n\\n语法\\n\\nstr.matchAll(regexp)\\n\\nregexp：正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp\\n\\nRegExp 必须是设置了全局模式 /g 的形式，否则会抛出异常 TypeError。\\n例子：\\nconst regexp = RegExp('foo\\\\[a-z\\\\]\\\\*', 'g');\\nconst str = 'table football, foosball';\\nconst matches = str.matchAll(regexp);\\n\\nfor (const match of matches) {\\nconsole.log(`Found ${match[0]} start = ${match.index} end = ${match.index + match[0].length}.`);\\n}\\n// expected output: \\\"Found football start=6 end=14.\\\"\\n// expected output: \\\"Found foosball start=16 end=24.\\\"\\n\\n// matches iterator is exhausted after the for..of iteration\\n// Call matchAll again to create a new iterator\\nArray.from(str.matchAll(regexp), m => m\\\\[0\\\\]);\\n// Array \\\\[ \\\"football\\\", \\\"foosball\\\" \\\\]\\n\\n注意事项\\n1、如果没有 /g 标志，matchAll 会抛出异常。\\nconst regexp = RegExp('\\\\[a-c\\\\]', '');\\nconst str = 'abc';\\nArray.from(str.matchAll(regexp), m => m\\\\[0\\\\]);\\n// TypeError: String.prototype.matchAll called with a non-global RegExp argument\\n2、matchAll 内部做了一个 regexp 的复制，所以不像 regexp.exec，lastIndex 在字符串扫描时不会改变。\\nconst regexp = RegExp('\\\\[a-c\\\\]', 'g');\\nregexp.lastIndex = 1;\\nconst str = 'abc';\\nArray.from(str.matchAll(regexp), m => `${regexp.lastIndex} ${m[0]}`);\\n// Array \\\\[ \\\"1 b\\\", \\\"1 c\\\" \\\\]\\n3、matchAll 的另外一个亮点是更好地获取捕获组。因为当使用 match() 和 /g 标志方式获取匹配信息时，捕获组会被忽略：\\nconst regexp = /t(e)(st(\\\\\\\\d?))/g;\\nconst str = 'test1test2';\\n\\nstr.match(regexp);\\n// Array \\\\['test1', 'test2'\\\\]\\n使用 matchAll 可以通过如下方式获取分组捕获：\\nlet array = \\\\[...str.matchAll(regexp)\\\\];\\n\\narray\\\\[0\\\\];\\n// \\\\['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4\\\\]\\narray\\\\[1\\\\];\\n// \\\\['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4\\\\]\\n\\n2、Dynamic Import\\n\\n概述\\n\\n动态导入模块\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。下面的是你可能会需要动态导入的场景：\\n\\n当静态导入的模块很明显的降低了代码的加载速度且被使用的可能性很低，或者并不需要马上使用它。\\n当静态导入的模块很明显的占用了大量系统内存且被使用的可能性很低。\\n当被导入的模块，在加载时并不存在，需要异步获取。\\n当导入模块的说明符，需要动态构建。（静态导入只能使用静态说明符）。\\n当被导入的模块有副作用（这里说的副作用，可以理解为模块中会直接运行的代码），这些副作用只有在触发了某些条件才被需要时。（原则上来说，模块不能有副作用，但是很多时候，你无法控制你所依赖的模块的内容）。\\n\\n语法\\n\\nimport()\\n\\n关键字 import 可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise。\\n例子：\\nimport('/modules/my-module.js')\\n.then((module) => {\\n// Do something with the module.\\n});\\n也支持 await 关键字\\nconst module = await import('/modules/my-module.js');\\n模板字符串形式\\nconst main = document.querySelector(\\\"main\\\");\\nfor (const link of document.querySelectorAll(\\\"nav > a\\\")) {\\nlink.addEventListener(\\\"click\\\", e => {\\ne.preventDefault();\\nimport(`./section-modules/${link.dataset.entryModule}.js`)\\n.then(module => {\\nmodule.loadPageInto(main);\\n})\\n.catch(err => {\\nmain.textContent = err.message;\\n});\\n});\\n}\\n\\n注意事项\\n请不要滥用动态导入（只有在必要情况下采用）。\\n静态框架能更好地初始化依赖，而且更有利于静态分析工具和 tree shaking 发挥作用。\\n与静态 import 差异：\\n\\nimport() 可以从脚本中使用，而不仅仅是从模块中使用。\\n如果 import() 在模块中使用，它可以出现在任何级别的任何地方，并且不会被提升。\\n\\nimport() 接受任意字符串（此处显示了运行时确定的模板字符串），而不仅仅是静态字符串文字。\\n模块中存在 import() 并不会建立依赖关系，在对包含的模块求值之前，必须先获取并求值依赖关系。\\n\\nimport() 不建立可以静态分析的依赖关系（但是，在诸如 import('./foo.js') 这样的简单情况下，实现可能仍然能够执行推测性抓取）。\\n\\n3、import.meta\\n\\n概述\\n\\nimport.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n通常情况下，主机环境可以提供有用的模块特定信息，以便在模块内进行代码评估。以下是几个例子。\\n模块的 URL 或 文件名\\n这是在 Node.js 的 CommonJS 模块系统中通过作用域内 __filename 变量（及其对应的 __dirname ）提供的。这允许通过代码轻松解析相对于模块文件的资源，例如：\\nconst fs = require(\\\"fs\\\");\\nconst path = require(\\\"path\\\");\\nconst bytes = fs.readFileSync(path.resolve(__dirname, \\\"data.bin\\\"));\\n如果没有可用的 _dirname，像 fs.readFileSync('data.bin') 这样的代码将解析相对于当前工作目录的 data.bin。这对于库作者来说通常是没有用的，因为他们将自己的资源与模块捆绑在一起，这些模块可以位于与 CWD 相关的任何位置。\\n浏览器中也存在相似的行为，将文件名替换为 URL。\\nscrpit 标签引入资源\\n<script data-option=\\\"value\\\" src=\\\"library.js\\\"></script>\\n\\n// 获取 data-option 的值如下\\nconst theOption = document.currentScript.dataset.option;\\n为此使用（有效的）全局变量而不是词法范围的值的机制是有问题的，因为这意味着该值仅设置在顶级，并且必须保存在那里才能用于任何异步代码。\\nmainModule\\n在 Node.js 中，通常的做法是通过以下代码来确定您是程序的 main 模块还是 entry 模块：\\nif (module === process.mainModule) {\\n// run tests for this library, or provide a CLI interface, or similar\\n}\\n也就是说，它允许单个文件在导入时用作库，或者在直接运行时用作副作用程序。\\n请注意，此特定公式如何依赖于将主机提供的作用域值模块与主机提供的全局值 process.mainModule 进行比较。\\n其他可设想的情况\\n\\n其他 Node.js 方法，如 module.children 或 require.resolve()\\n\\n关于模块所属 package 的信息，或者通过 Node.js 的 package.json 或 web package\\n\\n指向嵌入在 HTML 模块中的 JavaScript 模块的包含 DocumentFragment 的指针\\n\\n语法\\n\\nimport.meta\\n\\nimport.meta 对象由一个关键字 import，一个点符号和一个 meta 属性名组成。通常情况下 import. 是作为一个属性访问的上下文，但是在这里 import 不是一个真正的对象。\\nimport.meta 对象带有一个 null 的原型对象。这个对象可以扩展，并且它的属性都是可写，可配置和可枚举的。\\n例子：\\n以下代码使用了我们添加到 import.meta 中的两个属性：\\n(async () => {\\nconst response = await fetch(new URL(\\\"../hamsters.jpg\\\", import.meta.url));\\nconst blob = await response.blob();\\n\\nconst size = import.meta.scriptElement.dataset.size || 300;\\n\\nconst image = new Image();\\nimage.src = URL.createObjectURL(blob);\\nimage.width = image.height = size;\\n\\ndocument.body.appendChild(image);\\n})();\\n当这个模块被加载时，无论它的位置如何，它都会加载 hamsters.jpg 文件，并显示图像。可以使用用于导入它的脚本元素来配置图像的大小，例如：\\n<script type=\\\"module\\\" src=\\\"path/to/hamster-displayer.mjs\\\" data-size=\\\"500\\\"></script>\\n\\n4、BigInt\\n\\n概述\\n\\n在 JavaScript 中，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。（新的基本数据类型）\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n在 JavaScript 中，当 number 大于 Number.MAX_SAFE_INTEGER 时，就会发生精度丢失。\\nconst x = Number.MAX_SAFE_INTEGER;\\n// 9007199254740991, this is 1 less than 2^53\\n\\nconst y = x + 1;\\n// 9007199254740992, ok, checks out\\n\\nconst z = x + 2;\\n// 9007199254740992, wait, that’s the same as above!\\nBigInt 的提案正是要解决这个问题，BigInt 使 Number.MAX_SAFE_INTEGER 不再是 JavaScript 的限制。它可以表示任意精度的整数。\\n\\n语法\\n\\n通过 BigInt 方法，或是在一个数值后添加 n 后缀，来将一个 Number 转换为 BigInt 类型。\\n\\n例子：\\nconst theBiggestInt = 9007199254740991n;\\nconst alsoHuge = BigInt(9007199254740991);\\n// 9007199254740991n\\nconst hugeButString = BigInt('9007199254740991');\\n// 9007199254740991n\\nNumber.MAX_SAFE_INTEGER;\\n// 9007199254740991\\nNumber.MAX_SAFE_INTEGER + 10 - 10;\\n// 9007199254740990   （精度丢失）\\nBigInt(Number.MAX_SAFE_INTEGER) + 10n - 10n;\\n// 9007199254740991n  （计算结果为 bigint 类型）\\n\\ntypeof 9007199254740991n === \\\"bigint\\\";\\n// true\\n你可以使用 +、\\\\*、-、\\\\*\\\\*、% 运算符，就像在 Number 中使用一样。\\nconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);\\n// 9007199254740991\\n\\nconst maxPlusOne = previousMaxSafe + 1n;\\n// 9007199254740992n\\n\\nconst theFuture = previousMaxSafe + 2n;\\n// 9007199254740993n, this works now!\\n\\nconst multi = previousMaxSafe \\\\* 2n;\\n// 18014398509481982n\\n\\nconst subtr = multi – 10n;\\n// 18014398509481972n\\n\\nconst mod = multi % 10n;\\n// 2n\\n\\nconst bigN = 2n \\\\*\\\\* 54n;\\n// 18014398509481984n\\n\\nbigN \\\\* -1n\\n// –18014398509481984n\\n\\n注意事项\\n1、/ 除法运算符也可以使用，但是会向下取整。\\n因为 BigInt 不是 BigDecimal。\\nconst expected = 4n / 2n; // 2n\\nconst rounded = 5n / 2n;  // 2n, not 2.5n\\n2、BigInt 并不严格等于 Number。\\n2n === 2; // false\\n2n == 2;  // true\\n3、比较运算符可以正常使用。\\n1n < 2;  // true\\n2n > 1;  // true\\n2 > 2;   // false\\n2n > 2;  // false\\n2n >= 2; // true\\n4、数组中混合 BigInt 和 Number 可以正常排序。\\nconst mixed = \\\\[4n, 6, -12n, 10, 4, 0, 0n\\\\];\\n// \\\\[4n, 6, -12n, 10, 4, 0, 0n\\\\]\\n\\nmixed.sort();\\n// \\\\[-12n, 0, 0n, 10, 4n, 4, 6\\\\]\\n5、BigInt 不可以与 Number 混合运算。\\n1n + 2;\\n// TypeError: Cannot mix BigInt and other types, use explicit conversions\\n\\n1n \\\\* 2;\\n// TypeError: Cannot mix BigInt and other types, use explicit conversions\\n\\n5、Promise.allSettled\\n\\n概述\\n\\nPromise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。\\n当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个 promise 的结果时，通常使用它。\\n相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个 reject 时立即结束。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n\\napi\\n描述\\n\\nPromise.allSettled\\n不会短路\\n本提案 🆕\\n\\nPromise.all\\n当存在输入值 rejected 时短路\\n在 ES2015 中添加 ✅\\n\\nPromise.race\\n当存在输入值 稳定 时短路\\n在 ES2015 中添加 ✅\\n\\nPromise.any\\n当存在输入值 fulfilled 时短路\\n在 ES2021 中添加 ✅\\n\\n可以看出，Promise.all、Promise.race、Promise.any 都存在短路行为。\\nPromise.allSettled 不存在短路行为，它确保每个 promise 都可以执行完毕，无论状态是 fulfilled 还是  rejected。\\n\\n语法\\n\\nPromise.allSettled(iterable)\\n\\niterable：一个可迭代的对象，例如 Array，其中每个成员都是 Promise。\\n\\n一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，未决议的 promise 将被异步完成。那时，所返回的 promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。\\n对于每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value。如果值为 rejected，则存在一个 reason。value（或 reason）反映了每个 promise 决议（或拒绝）的值。\\n例子：\\nconst promise1 = Promise.resolve(3);\\nconst promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));\\nconst promises = \\\\[promise1, promise2\\\\];\\n\\nPromise.allSettled(promises)\\n.then((results) => results.forEach((result) => console.log(result.status)));\\n\\n// expected output:\\n// \\\"fulfilled\\\"\\n// \\\"rejected\\\"\\nconst promise1 = Promise.resolve(3);\\nconst promise2 = 42;\\nconst promise3 = new Promise((resolve, reject) => reject('我是失败的Promise_1'));\\nconst promise4 = new Promise((resolve, reject) => reject('我是失败的Promise_2'));\\nconst promiseList = \\\\[promise1, promise2, promise3, promise4\\\\];\\nPromise.allSettled(promiseList)\\n.then(values => {\\n  console.log(values);\\n});\\n\\n6、globalThis\\n\\n概述\\n\\n全局属性 globalThis 包含全局的 this 值，类似于全局对象（global object）。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n编写访问全局对象的可移植 ECMAScript 代码是很困难的。在 web 端，可以是 window 或者 self 或者 this 或者 frames。在 node.js 中，是 global 或者 this。\\n其中，只有 this 在 V8 的 d8 或者 JavaScriptCore 的 jsc 这样的 shell 中可用。\\n在 sloppy 模式下的独立函数调用中，this 也可以工作，但是在模块中或在函数内的严格模式下它是 undefined。\\n在这样的上下文中，全局对象仍然可以通过 Function('return this')() 访问，但在某些 CSP 设置中，例如在 Chrome 应用程序中是不可访问的。\\n下面是一些从外部获取全局对象的代码，作为单个参数传递给 IIFE，它在大多数情况下都有效，但实际上不适用于 d8 当在模块中或在函数内的严格模式下（可以使用函数技巧修复）：\\nfunction foo() {\\n// If we're in a browser, the global namespace is named 'window'. If we're\\n// in node, it's named 'global'. If we're in a shell, 'this' might work.\\n(typeof window !== \\\"undefined\\\"\\n? window\\n\\\\: (typeof process === 'object' &&\\ntypeof require === 'function' &&\\ntypeof global === 'object')\\n? global\\n\\\\: this);\\n}\\n此外，由于 CSP 问题，es6-shim 必须从 Function('return this')() 转换，\\n当前处理 browsers、node、web workers、frames 方式如下：\\nconst getGlobal = function () {\\n// the only reliable means to get the global object is\\n// `Function('return this')()`\\n// However, this causes CSP violations in Chrome apps.\\nif (typeof self !== 'undefined') { return self; }\\nif (typeof window !== 'undefined') { return window; }\\nif (typeof global !== 'undefined') { return global; }\\nthrow new Error('unable to locate global object');\\n};\\n\\n语法\\n在浏览器中， window、globalThis、this 三者全等：\\nwindow === this;       // true\\nwindow === globalThis; // true\\nthis === globalThis;   // true\\n在 node.js 中，global、globalThis、this 三者全等：\\n\\n> global === this;       // true\\n> global === globalThis; // true\\n> this === globalThis;   // true\\n\\n7、Nullish Coalescing\\n\\n概述\\n\\n空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n在执行属性访问时，如果属性访问的结果为 null 或 undefined，则通常需要提供默认值。目前，在 JavaScript 中表达此意图的一种典型方式是使用 || 运算符。\\nconst response = {\\nsettings: {\\nnullValue: null,\\nheight: 400,\\nanimationDuration: 0,\\nheaderText: '',\\nshowSplashScreen: false,\\n},\\n};\\nconst undefinedValue = response.settings.undefinedValue || 'some other default';\\n// result: 'some other default'\\nconst nullValue = response.settings.nullValue || 'some other default';\\n// result: 'some other default'\\n这对于 null 和 undefined 的值常见情况非常有效，但有许多 falsy 值可能会产生令人惊讶的结果：\\nconst headerText = response.settings.headerText || 'Hello, world!';\\n// Potentially unintended. '' is falsy, result: 'Hello, world!'\\nconst animationDuration = response.settings.animationDuration || 300;\\n// Potentially unintended. 0 is falsy, result: 300\\nconst showSplashScreen = response.settings.showSplashScreen || true;\\n// Potentially unintended. false is falsy, result: true\\n\\n语法\\n\\nleftExpr ?? rightExpr\\n\\n例子：\\nlet user = {\\nu1: 0,\\nu2: false,\\nu3: null,\\nu4: undefined,\\nu5: '',\\n}\\nlet u2 = user.u2 ?? '用户2'; // false\\nlet u3 = user.u3 ?? '用户3'; // 用户3\\nlet u4 = user.u4 ?? '用户4'; // 用户4\\nlet u5 = user.u5 ?? '用户5'; // ''\\n\\n8、Optional Chaining\\n\\n概述\\n\\n可选链操作符（?.）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用（null 或者 undefined）的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n在寻找对象结构深处的属性值时，通常必须检查中间节点是否存在：\\nconst street = user.address && user.address.street;\\n此外，许多 API 返回对象或 null/undefined，并且可能希望仅在结果不为 null 时从结果中提取属性：\\nconst fooInput = myForm.querySelector('input\\\\[name=foo\\\\]');\\nconst fooValue = fooInput ? fooInput.value : undefined;\\n\\n语法\\n\\nobj?.prop\\nobj?.\\\\[expr\\\\]\\narr?.\\\\[index\\\\]\\nfunc?.(args)\\n\\n例子：\\n使用可选链访问对象属性：\\nlet user = {};\\nlet u1 = [user.childer.name](http://user.childer.name);\\n// TypeError: Cannot read property 'name' of undefined\\nlet u1 = user?.childer?.name;\\n// undefined\\n使用可选链进行函数调用\\nfunction doSomething(onContent, onError) {\\ntry {\\n// ... do something with the data\\n}\\ncatch (err) {\\nonError?.(err.message); // 如果onError是undefined也不会有异常\\n}\\n}\\n当使用方括号与属性名的形式来访问属性时，你也可以使用可选链操作符：\\nconst nestedProp = obj?.\\\\['prop' + 'Name'\\\\];\\n可选链访问数组元素：\\nlet arrayItem = arr?.\\\\[42\\\\];\\n\\nES12（ES2021）\\n\\n1、String.prototype.replaceAll\\n\\n概述\\n\\nreplaceAll() 方法返回一个新字符串，新字符串所有满足 pattern 的部分都已被 replacement 替换。pattern 可以是一个字符串或一个 RegExp， replacement 可以是一个字符串或一个在每次匹配被调用的函数。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n目前没有办法在不使用全局正则表达式的情况下替换字符串中子字符串的所有实例。 String.prototype.replace 仅在与字符串参数一起使用时替换掉第一次出现的子字符串。\\n目前实现这一目标的最常见方法是使用全局正则表达式：\\nconst queryString = 'q=query+string+parameters';\\nconst withSpaces = queryString.replace(/+/g, ' ');\\n这种方法的缺点是需要对特殊的 RegExp 字符进行转义——注意转义的 +。\\n另一种解决方案是结合 String.split 和 Array.join：\\nconst queryString = 'q=query+string+parameters';\\nconst withSpaces = queryString.split('+').join(' ');\\n这种方法避免了任何转义，但带来了将字符串拆分为数组，然后再将数组各项重新粘合在一起的开销。\\n\\n语法\\n\\nString.prototype.replaceAll(searchValue, replaceValue);\\n\\n返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉。\\n除了以下两种情况外，在其他所有情况下 String.prototype.replaceAll 行为都与 String.prototype.replace 相同：\\n\\n如果 searchValue 是一个字符串，String.prototype.replace 只替换一次出现的 searchValue，而 String.prototype.replaceAll 替换所有出现的 searchValue。\\n如果 searchValue 是非全局正则表达式，则 String.prototype.replace 替换单个匹配项，而 String.prototype.replaceAll 抛出异常。这样做是为了避免缺少全局标志（这意味着“不要全部替换”）和被调用方法的名称（强烈建议“全部替换”）之间的固有混淆。\\n\\n例子：\\nconst queryString = 'q=query+string+parameters';\\nconst withSpaces = queryString.replaceAll('+', ' ');\\n\\n2、Promise.any\\n\\n概述\\n\\nPromise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n语法\\n\\nPromise.any(iterable)\\n\\niterable：一个可迭代的对象，例如 Array。\\n\\n例子：\\nconst promise1 = new Promise((resolve, reject) => reject('失败的Promise1'));\\nconst promise2 = new Promise((resolve, reject) => reject('失败的Promise2'));\\nconst promiseList = \\\\[promise1, promise2\\\\];\\nPromise.any(promiseList)\\n.then(values=>{\\n  console.log(values);\\n})\\n.catch(error=>{\\n  console.log(error);\\n});\\n在上面的示例中，error 是 AggregateError，它是一个新的 error 子类，将各个错误组合在一起。每个 AggregateError 实例都包含一个指向异常数组的指针。\\n\\n3、Logical Assignment Operators\\n\\n概述\\n\\n逻辑赋值运算符\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n语法\\n\\n||=\\n&&=\\n??=\\n\\n例子：\\na ||= b;\\n//等价于\\na = a || (a = b);\\n\\na &&= b;\\n//等价于\\na = a && (a = b);\\n\\na ??= b;\\n//等价于\\na = a ?? (a = b);\\n\\n4、Numeric Separators\\n\\n概述\\n\\n数字分隔符\\n它是将其早期草案与 Christophe Porteneuve 的提案 numeric underscores 合并的结果，以扩展现有的 NumericLiteral 以允许数字之间的分隔符。\\n该提案目前处于 Stage 4 阶段。\\nTC39 直通车\\n\\n动机\\n此功能使开发人员能够通过在数字之间创建视觉分隔来使他们的数字文字更具可读性。\\n\\n语法\\n\\n使用下划线 _（U+005F）在数字间进行分隔。\\n\\n例子：\\n十进制\\nconst price1 = 1_000_000_000;\\nconst price2 = 1000000000;\\nprice1 === price2; // true\\n\\nconst float1 = 0.000_001;\\nconst float2 = 0.000001;\\nfloat1 === float2; // true;\\n二进制\\nconst nibbles1 = 0b1010_0001_1000_0101;\\nconst nibbles2 = 0b1010000110000101;\\nnibbles1 === nibbles2; // true\\n十六进制\\nconst message1 = 0xA1_B1_C1;\\nconst message2 = 0xA1B1C1;\\nmessage1 === message2; // true\\nBigInt\\nconst big1 = 1_000_000_000n;\\nconst big2 = 1000000000n;\\nbig1 === big2; // true\",\"timestamp\":1640253137,\"title\":\"ES7 到 ES12 常用新语法\"},\"digest\":\"eQntEEP5_1B9-pGLG9JpNgQPnXDPqX9MsU1uW-XIggQ\",\"authorship\":{\"contributor\":\"0x6b9a51DA0bd43437987AfA76ACF4ca667e0F0E10\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"0dDgyOk70wIPQDq_bIgKUabZcXxHDH_iEybmTJps3wQ\\\",\\\"y\\\":\\\"CIBe_qi0dl8bp5-qR2w66kTfXGEUsIThV6ZhLLlleXU\\\"}\",\"signature\":\"oTb7gnNE7p_ZPR4G1rwuFkaRgJ0tcmbvi1bCcLFTvACBDcRwGAGYLWnik2GyRMvnnA4euR_WxQqStBG2O0OBZw\",\"signingKeySignature\":\"0xc1a429b9bc1d4cd612c46325c5249e69b64f4fcf8b6eacce2a53a80155140c9a367a7e723c46acd9107c749459925af7ceda05b0520976574d228ad82dfb02b61c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"0dDgyOk70wIPQDq_bIgKUabZcXxHDH_iEybmTJps3wQ\\\",\\\"y\\\":\\\"CIBe_qi0dl8bp5-qR2w66kTfXGEUsIThV6ZhLLlleXU\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"eQntEEP5_1B9-pGLG9JpNgQPnXDPqX9MsU1uW-XIggQ\"}"