"{\"content\":{\"body\":\"## [](#introduction)Introduction\\n\\nWe will learn how to implement a RESTful API for a simple todo application using NestJS framework. But what is NestJS?\\n\\n> \\\"A progressive Node.js framework for building efficient, reliable and scalable server-side applications.\\\"\\n\\nYou can read more about NestJS [here](https://docs.nestjs.com/).\\n\\nIn this article, it assumes you have at least the basic understanding of TypeScript and even better with NodeJS and ExpressJS. However if you aren't familiar with these requirements, I will list down you what I recommend you to watch to learn from:\\n\\n*   TypeScript by [Fireship](https://www.youtube.com/watch?v=ahCwqrYpIuM)\\n*   NodeJS by [Fireship](https://www.youtube.com/watch?v=ENrzD9HAZK4)\\n*   ExpressJS by [Traversy Media](https://www.youtube.com/watch?v=L72fhGm1tfE)\\n\\nI also recommend you to subscribe on those YouTube channels as they produce high quality content and it's for free! I have other favorite YouTube channels as well but I will write it in another article.\\n\\nAnd if you are a frontend developer and have been using Angular for awhile, then this should be very familiar to you since NestJS is very similar with how Angular code is structured! Dependency injections, modules, generate code using CLI, and so much more!\\n\\n## [](#installation)Installation\\n\\nThis installation guide will be based on for Linux since I am using WSL2 on Windows and it is my preference and find it more convenient. I believe installation process is very similar but in case for other platforms I suggest you to consult the documentation that can be found [here](https://docs.nestjs.com/first-steps)\\n\\n## [](#installing-nest-cli)Installing Nest CLI\\n\\nOpen up your terminal and execute this command to install Nest CLI\\\\\\n\\n\\n    sudo npm install -g @nestjs/cli\\n\\n\\n\\nTo test it out if it has been successfully installed just execute the command below and that should tell you the current version installed for Nest CLI\\\\\\n\\n\\n    nest -v\\n\\n\\n\\n## [](#create-a-new-nest-project)Create a new Nest project\\n\\nNavigate to your projects directory or in any directory whichever you prefer and run this command below to install you a new project\\\\\\n\\n\\n    nest new todo-rest-app\\n\\n\\n\\nIf it asks you which package manager to select from, just choose anything you prefer but in this article I will select NPM.\\n\\nAnd now wait for the entire CLI to scaffold the new starter project for you.\\n\\n## [](#open-the-project-in-your-ide)Open the project in your IDE\\n\\nOnce that is done installing, open it on your preferred code editor. In my case I will open it with VSCode (Visual Studio Code), so I will execute in the terminal with this command\\\\\\n\\n\\n    cd todo-rest-app && code .\\n\\n\\n\\nThen that should open up your IDE.\\n\\n## [](#creating-todo-feature)Creating \\\"Todo\\\" feature\\n\\nWe can easily generate code for the Module class, Service class, Controller class by using the powerful CLI.\\n\\nOne thing to take note is that when creating a new feature, you should start by generating a module class for the particular feature. So for instance `TodoModule` is being generated first.\\n\\nSo let us generate them right on!\\\\\\n\\n\\n    # TodoModule\\n    nest g module Todo\\n    # Using alias: nest g mo Todo\\n\\n    # TodoService\\n    nest g service Todo\\n    # Using alias: nest g s Todo\\n\\n    # TodoController\\n    nest g controller Todo \\n    # Using alias: nest g co Todo \\n\\n\\n\\nThis should create a folder called \\\"todo\\\" and it will also add the `TodoService` under the `providers` array in `TodoModule` and the `TodoController` in the `controllers` array.\\n\\n## [](#creating-a-todo-modelschema)Creating a Todo model/schema\\n\\nBefore we proceed to writing the code for handling data and exposing it to the REST API we first create a data model for Todo. So let us create a schema using Mongoose package, so let's install it\\\\\\n\\n\\n    npm install --save @nestjs/mongoose mongoose\\n\\n\\n\\nRight after installation make sure to add `MongooseModule` into the imports array. We'll want to import this under `AppModule` so we let the application know where the MongoDB is coming from.\\n\\nHowever if you don't have MongoDB installed in your system you can use [this as reference](https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-database#install-mongodb) if you are using Linux based system\\\\\\n\\n\\n    // app.module.ts\\n\\n    import { Module } from '@nestjs/common';\\n    import { MongooseModule } from '@nestjs/mongoose';\\n\\n    @Module({\\n      imports: [MongooseModule.forRoot('mongodb://localhost/nest')],\\n    })\\n    export class AppModule {}\\n\\n\\n\\nAfter adding `MongooseModule.forRoot()` in `AppModule` we can then proceed to defining our Todo schema, so head on over to \\\"todo\\\" directory as this feature directory has been generated by the CLI, so under this directory create a folder named \\\"schemas\\\" and it's where the Todo schema resides\\n\\nOr you can do so by using this terminal commands\\\\\\n\\n\\n    mkdir src/todo/schemas && touch src/todo/schemas/todo.schema.ts\\n\\n\\n\\nThen let us define our Todo schema\\\\\\n\\n\\n    import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\\n    import { Document } from 'mongoose';\\n\\n    export type TodoDocument = Todo & Document;\\n\\n    @Schema()\\n    export class Todo {\\n      @Prop({ required: true })\\n      title: string;\\n\\n      @Prop()\\n      description?: string;\\n\\n      @Prop()\\n      completedAt?: Date;\\n\\n      @Prop({ required: true })\\n      createdAt: Date;\\n\\n      @Prop()\\n      deletedAt?: Date;\\n    }\\n\\n    export const TodoSchema = SchemaFactory.createForClass(Todo);\\n\\n\\n\\nThen let's create a DTO (Data Object Model) for creating and updated a Todo. But first I want to create a base class DTO\\\\\\n\\n\\n    mkdir src/todo/dto\\n\\n    touch src/todo/dto/base-todo.dto.ts\\n\\n\\n\\nThen we define the class and properties\\\\\\n\\n\\n    // todo/dto/base-todo.dto.ts\\n    export class BaseTodoDto {\\n       title: string\\n       description?: string\\n    }\\n\\n\\n\\nThen let us create a DTO for Create and Update that will extend this `BaseTodoDto` so for all properties defined under `BaseTodoDto` will carry over the new classes and so we won't have to rewrite all of these properties. So in a sense we aren't writing any boilerplate code in this case.\\\\\\n\\n\\n    touch src/todo/dto/create-todo.dto.ts\\n\\n    touch src/todo/dto/update-todo.dto.ts\\n\\n\\n\\nThen we can define it\\\\\\n\\n\\n    // todo/dto/create-todo.dto.ts\\n    import { BaseTodoDto } from \\\"./base-todo.dto\\\";\\n\\n    export class CreateTodoDto extends BaseTodoDto {}\\n\\n    // todo/dto/update-todo.dto.ts\\n    import { BaseTodoDto } from './base-todo.dto';\\n\\n    export class UpdateTodoDto extends BaseTodoDto {\\n      completedAt: Date;\\n    }\\n\\n\\n\\nWe added `completedAt` field on the `UpdateTodoDto` so we'll allow this field to update with that particular field we specified.\\n\\nAfter defining out model make sure to import this under `TodoModule` so this will be recognized as a `Model` in the codebase.\\\\\\n\\n\\n    import { Module } from '@nestjs/common';\\n    import { TodoService } from './todo.service';\\n    import { TodoController } from './todo.controller';\\n    import { MongooseModule } from '@nestjs/mongoose';\\n    import { Todo, TodoSchema } from './schemas/todo.schema';\\n\\n    @Module({\\n      providers: [TodoService],\\n      controllers: [TodoController],\\n      imports: [\\n        MongooseModule.forFeature([{ name: Todo.name, schema: TodoSchema }]),\\n      ],\\n    })\\n    export class TodoModule {}\\n\\n\\n\\n## [](#injecting-the-model-in-todoservice)Injecting the Model in TodoService\\n\\nUnder class `TodoService`, is here we want to define the logic for handling data. So in the constructor we will then inject the Model as our dependency for this class. The model I am referring to is what we just added into the `imports` array of the `TodoModule`\\\\\\n\\n\\n    import { Injectable } from '@nestjs/common';\\n    import { InjectModel } from '@nestjs/mongoose';\\n    import { Model } from 'mongoose';\\n    import { Todo, TodoDocument } from './schemas/todo.schema';\\n\\n    @Injectable()\\n    export class TodoService {\\n      constructor(@InjectModel(Todo.name) private readonly model: Model<TodoDocument>) {}\\n    }\\n\\n\\n\\nIn the constructor we use `@InjectModel(Todo.name)` annotation and we pass in the name of the model and we set it as a private property and gave it a type of `Model` where we also pass a generic type of `TodoDocument` that we defined from the Todo model from `todo.schema.ts`. This will give us all the methods from Mongoose for querying, altering ang creating data for MongoDB which is very convenient as it gives us the auto-completion.\\n\\nYou may also notice that it has the `@Injectable()` annotation which is very similar to Angular's service classes. This annotation creates the meta data and this makes the class recognized in the service locator other classes will be available to use this class as their dependency.\\n\\n## [](#defining-crud-functionalities)Defining CRUD functionalities\\n\\nNow let us proceed with defining the usual CRUD methods. We will have the following methods to write up the implementation details, `findAll()`, `findOne(id: string)`, `create(createTodoDto: CreateTodoDto)`, `update(id: string, updateTodoDto: UpdateTodoDto)`, and `delete(id: string)`.\\\\\\n\\n\\n    import { Injectable } from '@nestjs/common';\\n    import { InjectModel } from '@nestjs/mongoose';\\n    import { Model } from 'mongoose';\\n    import { CreateTodoDto } from './dto/create-todo.dto';\\n    import { UpdateTodoDto } from './dto/update-todo.dto';\\n    import { Todo, TodoDocument } from './schemas/todo.schema';\\n\\n    @Injectable()\\n    export class TodoService {\\n      constructor(\\n        @InjectModel(Todo.name) private readonly model: Model<TodoDocument>,\\n      ) {}\\n\\n      async findAll(): Promise<Todo[]> {\\n        return await this.model.find().exec();\\n      }\\n\\n      async findOne(id: string): Promise<Todo> {\\n        return await this.model.findById(id).exec();\\n      }\\n\\n      async create(createTodoDto: CreateTodoDto): Promise<Todo> {\\n        return await new this.model({\\n          ...createTodoDto,\\n          createdAt: new Date(),\\n        }).save();\\n      }\\n\\n      async update(id: string, updateTodoDto: UpdateTodoDto): Promise<Todo> {\\n        return await this.model.findByIdAndUpdate(id, updateTodoDto).exec();\\n      }\\n\\n      async delete(id: string): Promise<Todo> {\\n        return await this.model.findByIdAndDelete(id).exec();\\n      }\\n    }\\n\\n\\n\\n## [](#defining-methods-and-route-endpoints-in-todocontroller)Defining methods and route endpoints in TodoController\\n\\nIt is very easy to define routes in our Controller class and all thanks to TypeScript for these annotations just made everything a breeze! We have to inject the `TodoService` as our dependency for this `Controller` class and then define all methods with its corresponding annotation as this will handle which HTTP method it will be used to access the functionality.\\n\\nWe will use the following names in the `Controller` where `index()` is for querying all Todo, `find()` to query a single Todo, `create()` is to add a Todo in DB, `update()` to update an existing Todo based on given ID, and lastly `delete()` to delete a Todo.\\\\\\n\\n\\n    import {\\n      Body,\\n      Controller,\\n      Delete,\\n      Get,\\n      Param,\\n      Post,\\n      Put,\\n    } from '@nestjs/common';\\n    import { CreateTodoDto } from './dto/create-todo.dto';\\n    import { UpdateTodoDto } from './dto/update-todo.dto';\\n    import { TodoService } from './todo.service';\\n\\n    @Controller('todos')\\n    export class TodoController {\\n      constructor(private readonly service: TodoService) {}\\n\\n      @Get()\\n      async index() {\\n        return await this.service.findAll();\\n      }\\n\\n      @Get(':id')\\n      async find(@Param('id') id: string) {\\n        return await this.service.findOne(id);\\n      }\\n\\n      @Post()\\n      async create(@Body() createTodoDto: CreateTodoDto) {\\n        return await this.service.create(createTodoDto);\\n      }\\n\\n      @Put(':id')\\n      async update(@Param('id') id: string, @Body() updateTodoDto: UpdateTodoDto) {\\n        return await this.service.update(id, updateTodoDto);\\n      }\\n\\n      @Delete(':id')\\n      async delete(@Param('id') id: string) {\\n        return await this.service.delete(id);\\n      }\\n    }\\n\\n\\n\\n## [](#testing-it-with-a-rest-client)Testing it with a REST client\\n\\nYou can use any REST client of your choice, but for me I prefer Insomnia. Once you have your REST client opened by now we can proceed to testing the REST API we created so we can expect to add a todo, update a todo, delete a todo, read a todo.\\n\\nFirst let's make a GET request to `todos` endpoint.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--PBZb\\\\_7w7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pv8sgmc11c1e92e4zz26.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--PBZb\\\\_7w7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pv8sgmc11c1e92e4zz26.png)\\n\\nIt just returned an empty array, and it only makes sense since we did not create any todo. So let's create one!\\n\\nMake this as the request payload then make a POST request to the same endpoint and that it should return as the new document from MongoDB with an `_id` field since that is auto generated for us.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--4j1\\\\_WmaM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dbjnjxicndxzjcovpyhh.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--4j1\\\\_WmaM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dbjnjxicndxzjcovpyhh.png)\\n\\nYou can create more todos, but for now we can check again with the same endpoint but using `GET` method.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--U0agwhrg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6cdgiuqam5jsrew2kiu4.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--U0agwhrg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6cdgiuqam5jsrew2kiu4.png)\\n\\nNow it returns as a array with our recently created todo.\\n\\nNow let's update this todo, to change its title. First copy `_id` field from the response. Now using this ID, let's create a PUT request with the same payload but now we add the `completedAt` field\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--sag-uzxs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3lnvta6qy12w5a2sqzoz.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--sag-uzxs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3lnvta6qy12w5a2sqzoz.png)\\n\\nAs you can see we have filled up the `completedAt` field. On the first request that you make which returns 200 response but the response data is still the same, don't worry because behind the scenes the document was really updated. You can proceed to check again by GET request method to see the changes, alternative way is to update the document again. So double the PUT request we are making right now and you should see the changes.\\n\\nNow we want to delete this todo, then let's use the DELETE method in this case using the same endpoint but different HTTP method. It will return us the document deleted.\\n\\n[![image](https://res.cloudinary.com/practicaldev/image/fetch/s--DQ5G2mYp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6zvxzpx45i1wz9u3wg8w.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--DQ5G2mYp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw\\\\_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6zvxzpx45i1wz9u3wg8w.png)\\n\\nAnd that is all we have for now.\\n\\n## [](#conclusion)Conclusion\\n\\nWhen you want to create a quick REST API with NodeJS and you also love TypeScript, then NestJS is the way to go! Not only this is good for \\\"quick\\\" implementation for REST APIs but NestJS is also great for huge projects since the framework itself encourages the developer to use Domain Driven Design.\\n\\nHope you enjoyed this tutorial, be sure to hit thumbs up or upvote if you liked it. Cheers!\\n\\nFull source code can be found from the [repository](https://github.com/carlomigueldy/nest-js-todo-rest-api)\\n\",\"timestamp\":1636676752,\"title\":\"Building a RESTful API with NestJS and MongoDB (Mongoose)\"},\"digest\":\"IPvzu7_SkFuAMYLkVTJPy2wCfjBFl_cRbW7_5DnSAeo\",\"authorship\":{\"contributor\":\"0x3E8c686F499C877D8f4aFB1215b6f0935796b986\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"signature\":\"QtuV6H8tg8CNHdL91buzVmg4sT-kLlFGuiU4HUj8UcBkg8tpRZQRcW_b40mXbBfwX9R-pTcQHYq1-JjefHk3OQ\",\"signingKeySignature\":\"0xc823d2ab2ee5864fc5495382efb960b4461c3fb598b3be4e5e068c6312ab60ce014c7378c1f02beed8fce37236dc1e3eb8dd28a6f911b33ec4172a1fa8b17f101b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"XNAfCibxrmGjSr-VHADLIVoKcpjQ6AvgUiRVqATl37k\\\",\\\"y\\\":\\\"3RuY7Uw61mZNEnJyyzr7ObM928gt-QoWvGAdLDb2gy4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"IPvzu7_SkFuAMYLkVTJPy2wCfjBFl_cRbW7_5DnSAeo\"}"