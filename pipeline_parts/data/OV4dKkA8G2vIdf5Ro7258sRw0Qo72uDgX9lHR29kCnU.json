"{\"content\":{\"body\":\"搞 iOS 以来，一直在想找一个云主机进行 iOS 项目的 CI 探索，方向想偏了，没找到几家提供 macOS 系统的云主机，遂作罢。\\n\\n最近在读 《[iOS App Distribution & Best Practices](https://www.raywenderlich.com/books/ios-app-distribution-best-practices/)》，里面提到现在有大致三类 CI 服务商：\\n\\n1. Full-service CI，即全方位服务的 CI 提供商，可以理解为通过交互页面就可以进行部署。虽然简单，但可能不太容易拓展。典型如：\\n   1. Bitrise: <https://www.bitrise.io/>\\n   2. Microsoft’s App Center: <https://appcenter.ms/>\\n2. Managed CI，即在云上替你托管硬件相关的工作，你只需要提供构建脚本，在 iOS 项目中，常见的就是构建方式就是 `fastlane` 和 `xcodebuild`。比较流行的如：\\n   1. CircleCI: <https://circleci.com/>\\n   2. GitHub Actions: [https://Github.com/features/actions](https://github.com/features/actions)\\n3. Manual CI，即手动管理，感觉跟自己在云主机上处理一个概念。便宜，但得自己管理服务器。最著名的就是 Travis CI: <https://travis-ci.org/> 了。\\n\\n怀着激动的心，每个官方都去逛了一遍，确实都提供了 macOS 的构建环境，nice，der\\\\~。而且都有都有免费的配额（收费方式都是卖点卡）。\\n\\n最后还是选择 GitHub Actions 作为远程 CI 的第一个实验品。截图如下\\n\\n![job](https://images.mirror-media.xyz/publication-images/wVBBglrEtPcMcv_0u8lE7.png?height=432&width=1900)\\n\\n# GitHub Actions 使用\\n\\n中文的概念介绍和使用方式可以去看阮一峰的 [GitHub Actions 入门教程](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html) 。\\n\\n或者直接去看官方文档 [GitHub Actions](https://docs.github.com/en/actions) 。\\n\\n简单来说，就是在仓库目录 `.github/workflows/` 放置脚本，当有 push 或 PR 的时候，就会触发脚本运行。\\n\\n**免费额度查看方式**，「右上角LOGO」-「Settings」-「Billings & plans」\\n\\n# 触发条件\\n\\n```yaml\\nname: iOS starter workflow\\n\\n# 触发条件，在 main 分支上有 push 和 PR 行为时触发脚本\\non:\\n  push:\\n    branches: [ main ]\\n  pull_request:\\n    branches: [ main ]\\n```\\n\\n# Step 整理\\n\\n## 构建环境\\n\\n```yaml\\njobs:\\n  build:\\n    name: Build and Test default scheme using any available iPhone simulator\\n    # 环境\\n    runs-on: macos-latest\\n  \\t\\n  \\tsteps:\\n  \\t\\t# Checkout 当前分支进行处理\\n  \\t\\t- name: Checkout\\n        uses: actions/checkout@v2\\n  \\t\\t- name: stepxxx\\n  \\t\\t\\t# operation\\n \\n```\\n\\n## Pod install\\n\\niOS 项目免不了用 cocoaPods 安装依赖。\\n\\n```yaml\\n      - name: Install Dependencies\\n        run: |\\n          pod install --repo-update\\n```\\n\\n### 踩坑记录\\n\\n在 `Podfile` 头部标记 `source 'https://github.com/CocoaPods/Specs.git'` 不是很明智。\\n\\ncocoaPods 官方在 [CocoaPods 1.7.2 — Master Repo CDN is Finalized!](https://blog.cocoapods.org/CocoaPods-1.7.2/) 表示，随着 pod 数目的增多，利用 github 作为数据库备份越来越慢了，已经更换成 CDN 的形式了。\\n\\n```yaml\\n# source 'https://github.com/CocoaPods/Specs.git'\\n# 替换成 CDN，或者干脆删除。因为默认 CDN 源了。\\nsource 'https://cdn.cocoapods.org/'\\n```\\n\\n## 默认 Scheme\\n\\n```yaml\\n      - name: Set Default Scheme\\n        run: |\\n          scheme_list=$(xcodebuild -list -json | tr -d \\\"\\\\n\\\")\\n          default=$(echo $scheme_list | ruby -e \\\"require 'json'; puts JSON.parse(STDIN.gets)['project']['targets'][0]\\\")\\n          echo $default | cat >default\\n          echo Using default scheme: $default\\n```\\n\\n## Build\\n\\n用模拟器进行编译。优先跑 .xcworkspace，无则跑 .xcodeproj。\\n\\n我测试的时候，在 GitHub Actions 上 `xcrun` 得到的模拟器名称不正确，所以直接固定了使用 iPhone 11 作为模拟器。\\n\\n```yaml\\n      - name: Build\\n        env:\\n          scheme: ${{ 'default' }}\\n          platform: ${{ 'iOS Simulator' }}\\n        run: |\\n          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)\\n          # device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\\\\(]+' | head -1 | awk '{$1=$1;print}'`\\n          device='iPhone 11'\\n          if [ $scheme = default ]; then scheme=$(cat default); fi\\n          if [ \\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\" ]; then filetype_parameter=\\\"workspace\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\"; else filetype_parameter=\\\"project\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcodeproj\\\\$`\\\"; fi\\n          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`\\n          xcodebuild build-for-testing -scheme \\\"$scheme\\\" -\\\"$filetype_parameter\\\" \\\"$file_to_build\\\" -destination \\\"platform=$platform,name=$device\\\"\\n```\\n\\n## Test\\n\\n```yaml\\n      - name: Test\\n        env:\\n          scheme: ${{ 'default' }}\\n          platform: ${{ 'iOS Simulator' }}\\n        run: |\\n          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)\\n          # device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\\\\(]+' | head -1 | awk '{$1=$1;print}'`\\n          device='iPhone 11'\\n          if [ $scheme = default ]; then scheme=$(cat default); fi\\n          if [ \\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\" ]; then filetype_parameter=\\\"workspace\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\"; else filetype_parameter=\\\"project\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcodeproj\\\\$`\\\"; fi\\n          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`\\n          xcodebuild test-without-building -scheme \\\"$scheme\\\" -\\\"$filetype_parameter\\\" \\\"$file_to_build\\\" -destination \\\"platform=$platform,name=$device\\\"\\n```\\n\\n# 通知以及跨Job传递状态\\n\\n1. 使用 ravsamhq/notify-slack-action@v1 将 Job 状态通知到 Slack。\\n2. 因为该 action 运行在 Linux 系统，所以需要另起一个 Job。\\n3. 如何将上一个 Job 的状态通知到下一个 Job？一种思路是将 Job_A的状态通过文本保存到本地，再在Job_B中读取该状态。\\n\\n   可参考：[How get the status of previous jobs](https://github.community/t/how-get-the-status-of-previous-jobs/17555)\\n\\n## 保存状态\\n\\n```yaml\\n      - name: Create file status_build_test.txt and write the job status into it\\n        if: always()\\n        run: |\\n          echo ${{ job.status }} > status_build_test.txt\\n      - name: Upload file status_build_test.txt as an artifact\\n        if: always()\\n        uses: actions/upload-artifact@v1\\n        with:\\n          name: pass_status_build_test\\n          path: status_build_test.txt\\n```\\n\\n## 读取状态\\n\\n```yaml\\n      - name: Download artifact pass_status_build_test\\n        uses: actions/download-artifact@v1\\n        with:\\n          name: pass_status_build_test\\n      - name: Set the statuses of Job build output parameters\\n        id: set_outputs\\n        run: |\\n          echo \\\"::set-output name=status_build_test::$(<pass_status_build_test/status_build_test.txt)\\\"\\n```\\n\\n# 附录-完整版\\n\\n附上我当前使用的完整脚本，持续完善中。\\n\\n```yaml\\nname: iOS starter workflow\\n\\non:\\n  push:\\n    branches: [ main ]\\n  pull_request:\\n    branches: [ main ]\\n\\njobs:\\n  build:\\n    name: Build and Test default scheme using any available iPhone simulator\\n    runs-on: macos-latest\\n\\n    steps:\\n      - name: Checkout\\n        uses: actions/checkout@v2\\n      - name: Install Dependencies\\n        run: |\\n          pod install --repo-update\\n      - name: Set Default Scheme\\n        run: |\\n          scheme_list=$(xcodebuild -list -json | tr -d \\\"\\\\n\\\")\\n          default=$(echo $scheme_list | ruby -e \\\"require 'json'; puts JSON.parse(STDIN.gets)['project']['targets'][0]\\\")\\n          echo $default | cat >default\\n          echo Using default scheme: $default\\n      - name: Build\\n        env:\\n          scheme: ${{ 'default' }}\\n          platform: ${{ 'iOS Simulator' }}\\n        run: |\\n          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)\\n          # device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\\\\(]+' | head -1 | awk '{$1=$1;print}'`\\n          # 直接指定 iPhone 11\\n          device='iPhone 11'\\n          if [ $scheme = default ]; then scheme=$(cat default); fi\\n          if [ \\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\" ]; then filetype_parameter=\\\"workspace\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\"; else filetype_parameter=\\\"project\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcodeproj\\\\$`\\\"; fi\\n          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`\\n          xcodebuild build-for-testing -scheme \\\"$scheme\\\" -\\\"$filetype_parameter\\\" \\\"$file_to_build\\\" -destination \\\"platform=$platform,name=$device\\\"\\n      - name: Test\\n        env:\\n          scheme: ${{ 'default' }}\\n          platform: ${{ 'iOS Simulator' }}\\n        run: |\\n          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)\\n          # device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\\\\(]+' | head -1 | awk '{$1=$1;print}'`\\n          # 直接指定 iPhone 11\\n          device='iPhone 11'\\n          if [ $scheme = default ]; then scheme=$(cat default); fi\\n          if [ \\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\" ]; then filetype_parameter=\\\"workspace\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcworkspace\\\\$`\\\"; else filetype_parameter=\\\"project\\\" && file_to_build=\\\"`ls -A | grep -i \\\\\\\\.xcodeproj\\\\$`\\\"; fi\\n          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`\\n          xcodebuild test-without-building -scheme \\\"$scheme\\\" -\\\"$filetype_parameter\\\" \\\"$file_to_build\\\" -destination \\\"platform=$platform,name=$device\\\"\\n      - name: Create file status_build_test.txt and write the job status into it\\n        if: always()\\n        run: |\\n          echo ${{ job.status }} > status_build_test.txt\\n      - name: Upload file status_build_test.txt as an artifact\\n        if: always()\\n        uses: actions/upload-artifact@v1\\n        with:\\n          name: pass_status_build_test\\n          path: status_build_test.txt\\n  # 因为 notify-slack-action 跑在 Linux 系统所以另起一个 Job\\n  notify:\\n    needs: [ build ]\\n    if: always()\\n    name: Notify Slack\\n    runs-on: ubuntu-latest\\n    steps:\\n      - name: Download artifact pass_status_build_test\\n        uses: actions/download-artifact@v1\\n        with:\\n          name: pass_status_build_test\\n      - name: Set the statuses of Job build output parameters\\n        id: set_outputs\\n        run: |\\n          echo \\\"::set-output name=status_build_test::$(<pass_status_build_test/status_build_test.txt)\\\"\\n      - name: Notify Slack\\n        uses: ravsamhq/notify-slack-action@v1\\n        if: always()\\n        with:\\n          status: ${{ steps.set_outputs.outputs.status_build_test }}\\n        env:\\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\\n```\",\"timestamp\":1639030176,\"title\":\"利用 GitHub Actions 进行 iOS 项目的 CI/CD\"},\"digest\":\"VGG8uWT0qwMUBbYjKZN28wqQmAKkIdOp6kXZZGBqUEI\",\"authorship\":{\"contributor\":\"0x74CDEBD6028e5D8407c2ad6F13BEDD9892e3FB2A\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"8kCjAlvYp03an6xhM0Fa6Z7fNbG5ygNhHAW30VNJZW8\\\",\\\"y\\\":\\\"GHlrEBEHPoWXfdyOxTIDUcGN2x_JjiE_Ufi2v-urrF4\\\"}\",\"signature\":\"hIA3_v79uJubfL3445HK3yC9NiDSvOaIftZ0CbBFfLEXps2U9km5vqU9HoQqAEipqqjJot7C5PtxbUHemdGcDQ\",\"signingKeySignature\":\"0x1f24ae2d104d0acbfbe400b4f4a08ab304ad288bd9cb736f3b9859efbcc84c84170d9988f65a6e48cd6e1a337ca509c98018fa1e0abb0fc5ff3f9b13f040622c1c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"8kCjAlvYp03an6xhM0Fa6Z7fNbG5ygNhHAW30VNJZW8\\\",\\\"y\\\":\\\"GHlrEBEHPoWXfdyOxTIDUcGN2x_JjiE_Ufi2v-urrF4\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"VGG8uWT0qwMUBbYjKZN28wqQmAKkIdOp6kXZZGBqUEI\"}"