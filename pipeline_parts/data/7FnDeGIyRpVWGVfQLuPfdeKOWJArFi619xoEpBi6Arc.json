"{\"content\":{\"body\":\"开始前，先说一个概率上的例子：\\n\\n小明有一个袋子，里面是有一定数量的白球和红球，白球表面有黑色的小狗图案，红球表面有绿色的叶子图案。现在小明和小红通过玩【你画我猜】，证明小明知道这个袋子球及其图案，白球是用1代替，红球用0代替。小红给出一系列描述和问题，小明说出是1还是0，从证明小明是知道什么球。\\n\\n假设有两个数组L = \\\\[4, 11, 8, 1\\\\]，M = \\\\[1, -1, 1, -1\\\\]，L是由验证者生成，M是证明者生成。问题：证明者在不暴露M的内容下，要向验证者 证明 它的M是能够满足下面的任务：\\n\\n* len(M) = len(P)\\n* M中所有元素是1或-1\\n* L和M的点积是0\\n\\n通过两个数组L和M，生成“见证witness”P，每一次只对验证者暴露P的一部分内容，从而避免暴露M。所以P满足一下条件：\\n\\n* 第一个元素和最后一个元素是0\\n* 0 ≤ i ≤ n，有| L\\\\[i\\\\] | = | P\\\\[i + 1\\\\] - P\\\\[i\\\\] |\\n\\nZK具体步骤：\\n\\n（1）通过L和M的点积得到P，即witness，并将P的每一元素和一个随机数相加。再在P的不同位置随机插入一个随机数：\\n\\np\\\\[0\\\\] = 0  \\n p\\\\[1\\\\] = l\\\\[0\\\\] \\\\* *m\\\\[0\\\\] = p\\\\[0\\\\] + l\\\\[0\\\\]*  \\\\* *m\\\\[0\\\\] = 4  \\n p\\\\[2\\\\] =* p\\\\[1\\\\] + l\\\\[1\\\\] \\\\* *m\\\\[1\\\\] = 4 + 11-1 = -7  \\n p\\\\[3\\\\] = p\\\\[2\\\\] + l\\\\[2\\\\] \\\\* m\\\\[2\\\\] = -7 + 8 = 1  \\n p\\\\[4\\\\] = p\\\\[3\\\\] + l\\\\[3\\\\] \\\\* m\\\\[3\\\\] = 1 + 1* \\\\* (-1) = 0\\n\\n所以 P = \\\\[0, 4, -7, 1, 0\\\\]\\n\\n添加随机数：P = \\\\[9, 13, 2, 10, 9\\\\]\\n\\n拓展 P：P = \\\\[9, 13, 2, 10, 9, 0, 0, 0\\\\]\\n\\n插入随机数：P = \\\\[9, 3492207414, 13, 3680575953, 2, 1647836091, 10, 806976218, 9, 7812868, 0,4037695147, 0, 228583277, 0, 2638268617\\\\]\\n\\n（2）生成默克尔根树\\n\\n* 在P的首位，添加和len(P)等长的“ ”空字符串，令tree = P；\\n* 令tree\\\\[i\\\\] = hash(tree\\\\[i\\\\* 2\\\\] + tree\\\\[i \\\\* 2 + 1\\\\])，1 ≤ i ≤ len(tere) / 2 - 1；\\n\\n  tree\\\\[15\\\\] = hash(tree\\\\[30\\\\] + tree\\\\[31\\\\])\\n\\n  tree\\\\[14\\\\] = hash(tree\\\\[28\\\\] + tree\\\\[29\\\\])\\n\\n  tree\\\\[13\\\\] = hash(tree\\\\[26\\\\] + tree\\\\[27\\\\])\\n\\n  ...\\n\\n  tree\\\\[1\\\\] = hash(tree\\\\[2\\\\] + tree\\\\[3\\\\])\\n\\n![](https://images.mirror-media.xyz/publication-images/PeACgQirGdC9isMvRYX6I.png?height=404&width=838)\\n\\n（3）生成验证路径\\n\\n定义一个auth_puth的空list，确定要验证的叶子节点p\\\\[i\\\\]，如P\\\\[4\\\\]，通过iˆ1 和 i // 2，得到默克尔根树的验证路径，即 auth_puth = \\\\[tree\\\\[25\\\\], tree\\\\[13\\\\], tree\\\\[7\\\\], tree\\\\[2\\\\], tree\\\\[1\\\\]\\\\]；P\\\\[4\\\\] = tree\\\\[24\\\\]；\\n\\n（4）生成proof = \\\\[ 根结点, len(L), P\\\\[0\\\\], 验证的叶子节点, 验证的路径\\\\]；\\n\\n（5）验证proof\\n\\n* 先判断该叶子节点是否是P的首尾。如果是，则P\\\\[-1\\\\] = P\\\\[0\\\\]；否，则P\\\\[i+1\\\\]-P\\\\[i\\\\] = L\\\\[i\\\\]\\n* 验证路径：将路径上的各个tree值相加，hash\\\\[P\\\\[4\\\\] + tree\\\\[25\\\\]\\\\] ?= tree\\\\[12\\\\]，hash\\\\[tree\\\\[12\\\\] + tree\\\\[13\\\\]\\\\] ?= tree\\\\[6\\\\]，hash\\\\[tree\\\\[6\\\\] + tree\\\\[7\\\\]\\\\] ?= tree\\\\[3\\\\]，hash\\\\[tree\\\\[3\\\\] + tree\\\\[2\\\\]\\\\] ?= tree\\\\[1\\\\]，tree\\\\[1\\\\] ?= 根结点\",\"timestamp\":1634202148,\"title\":\"我理解的零知识证明\"},\"digest\":\"pwK_Zr8h25ttdCeWHWPJokswKTMsmNt6fme9OR6WFxQ\",\"authorship\":{\"contributor\":\"0xA21D5B40678258f2aBA9b8411f193dD9053eE27f\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"YoLKHS_Gk1S3emqFj5zdRdBrjBSPBNQ3jWAJiE5AtgE\\\",\\\"y\\\":\\\"CIEEk_QxUuh9qfx9QBwfUsMwpwT3CzlddlKGWs1iibI\\\"}\",\"signature\":\"wChDyk3VV75hIQg3LMzv7XEY5lN1IV_XQf9Nlwk2Ug8V09dbgIAxREQyRgewzTNUv-tHUpIroxiVOQM4ue096Q\",\"signingKeySignature\":\"0xced6aefd44f51becefe8c42132f3057d2bd934206ad9c73c986076ee68f1c53f6d9e02ec2b3f8aa2f58d609e5da20d88c9b8cdcd5bce210910d8804c185f16121b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"YoLKHS_Gk1S3emqFj5zdRdBrjBSPBNQ3jWAJiE5AtgE\\\",\\\"y\\\":\\\"CIEEk_QxUuh9qfx9QBwfUsMwpwT3CzlddlKGWs1iibI\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"ijuklTFBatHSm5dZMgCjKVABONjQVzC5oCJ-oVaU9zQ\"}"