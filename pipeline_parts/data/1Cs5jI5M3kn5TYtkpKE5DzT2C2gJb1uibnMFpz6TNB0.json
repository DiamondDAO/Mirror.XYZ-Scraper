"{\"content\":{\"body\":\"![](https://miro.medium.com/max/1400/1\\\\*x_onkS0e1sTKEecG69fUVA.png)\\n\\nAt [Logistimo](http://www.logistimo.com/), all of our applications are containerized and run as docker containers inside Kubernetes. We had noticed lot of restarts on containers with Java apps and is quite random. Docker inspection revealed that the pod was killed by OOMKiller code:137. This meant that the application is consuming more memory than allocated to the container. It didn’t sound right, since we have limits on the Java application using -Xmx and we left about 20% buffer as Kubernetes resource limit (docker container) for the Meta space and GC data.\\n\\nFor e.g., 2 GB for Java process, and 2.4 GB for the Kubernetes resource.\\n\\nSubsequent sections cover this problem and how to solve it in detail.\\n\\n**JVM memory usage**\\n\\nObviously the first step was to review why the container is exceeding the said limit, clearly these are sufficiently buffered.\\n\\n“ps” command confirms that the Xmx is indeed in place, and is set to max of 4GB.\\n\\n![](https://miro.medium.com/max/856/1\\\\*xDvwU97WF3lOK2sEMqy8XQ.png)\\n\\nJava process set to Max 4G\\n\\n“top” command, however reveals that the physical memory used is 4.5 GB.\\n\\n**Why would Java take 500 MB more than allocated?**\\n\\nSince JDK 1.8.40 there is a [Native memory tracker tool](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html) introduced which provides a detailed breakup of memory used by Java application with every byte accounted for. Note that NMT tool shows committed, resident might be less.\\n\\n> Actual usage = Heap memory + Meta space + Off heap\\n\\nOff heap typically consists of class meta data, compiled code, threads and GC data. GC data is variable while rest of it should remain static for most applications. This memory is native ([yes including the meta space](https://dzone.com/articles/java-8-permgen-metaspace)), and JVM uses available memory on host to grow or garbage collect this data.\\n\\nI would encourage you to read [this excellent blog post by Mikhail](http://trustmeiamadeveloper.com/2016/03/18/where-is-my-memory-java/) to get better perspective.\\n\\nComing back to the problem at hand, JVM took 500 MB more because the underlying host had 16 GB memoy. At times this number could go higher than the buffer we had set, which would cause the container to be terminated. Shouldn’t the JVM be reading docker container’s memory limit?\\n\\n**Containers and Java**\\n\\nIt turns out Java versions 9 and below do not understand containers/dockers at all (by default). It picks up available CPUs and Memory from the underlying host. Each Java app running on a host inside container relies on the host configuration. Considering that we are Kubernetes and many pods run on single node, this could lead to problems like the ones we are facing.\\n\\nJava 10 supports containers out of the box, and it will lookup the linux cgroup information. This allows the JVM to garbage collect based on containers limits. This is turned on by default using the flag.\\n\\n> -XX:+UseContainerSupport\\n\\nThankfully, some of these features have been backported to 8u131 and 9 onwards. They can be turned on using the following flags.\\n\\n> -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap\\n\\n**Summary**\\n\\nOlder versions of Java read the underlying host, and don’t understand cgroups. This would cause mismatch between container configuration and the Java process. This mismatch is on both CPU and the memory. Java has an Off heap memory component which has a dynamic GC data component, which could grow. Best way to solve this is to use the container support features available in recent versions of Java. Do not rely on buffering (It is waste of money).\\n\\nUpgrade to Java 8u131+ or Java 9, if you have to remain on these major versions and turn on the experimental flags. Even better, if you can get all the container love available Java 10 onwards.\\n\\n**References**\\n\\n[https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html)\\n\\n[https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/](https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/)\\n\\n\",\"timestamp\":1637583207,\"title\":\"OOM Killer and Java applications in containers\"},\"digest\":\"VAi6EFZW0e_tmoRI1M_PJSLlUw_mcWeATW1hsptpKMo\",\"authorship\":{\"contributor\":\"0x5417e1458C2314d73eEA2c70e2Df4ac26a8Bc17a\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"r-JtRVBtui6zme9YCAQu98t9I3_Aepmw8a30vs2X2Uw\\\",\\\"y\\\":\\\"XVWPWBKbYV8GdxUhkG_Wof3pcuJ0dCGFzaA5SHE3Eq0\\\"}\",\"signature\":\"3GmgGpo3-krRNQeDfxbgu4OgdDr7IWJwIPbCuQ_3K13l91pOyq2OhKSVGLO3ETvPhIitHyia_spbKLzvcyFlHw\",\"signingKeySignature\":\"0xce3d0538ca00fc378c07066ee6591840bd3f18467fe47e4ac8eca48512ef21923fed18906979eb00b31b4dcede217f6204c05444e25fc99a11a2dabe480dc6821b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"r-JtRVBtui6zme9YCAQu98t9I3_Aepmw8a30vs2X2Uw\\\",\\\"y\\\":\\\"XVWPWBKbYV8GdxUhkG_Wof3pcuJ0dCGFzaA5SHE3Eq0\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"G8UTCj_hkTzYdDUJvZUTKIWIhiPOnOrnW7dRuhs8vOI\"}"