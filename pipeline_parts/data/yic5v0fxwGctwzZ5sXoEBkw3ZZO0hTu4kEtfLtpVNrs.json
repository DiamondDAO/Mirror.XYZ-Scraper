"{\"content\":{\"body\":\"## Learn about promises to make sense of what they are and how you can use them in JavaScript\\n\\n![](https://images.mirror-media.xyz/publication-images/ngxitYjSUbfCIThywubI5.jpg?height=497&width=700)\\n\\nIf you head over to the ECMAScript 6 documentation, you‚Äôll see that under Promises lies one sentence.*‚ÄúFirst class representation of a value that may be made asynchronously and be available in the future.‚Äù*Are you wondering what that means?\\n\\nYeah, me too. It‚Äôs probably this, among many other misunderstandings about how JavaScript executes code under the hood, that has contributed to the confusion surrounding the Promise feature in JavaScript.\\n\\nWell, in this blog post, we‚Äôll aim to demystify exactly how this feature works so you can implement Promises into your code like a pro. To get to the Promised land (sorry, not sorry), we first need to understand how JavaScript handles synchronous and asynchronous code. We‚Äôll then dive into what Promises are, how they‚Äôre helpful, and why you might want to start using them in your code if you haven‚Äôt already.\\n\\n# How JavaScript handles synchronous and asynchronous code\\n\\nJavaScript is a single-threaded programming language which means that it has a single call stack upon which it can push new function execution contexts. In other words, it can do one thing at a time.\\n\\nNot only that, but it does it with zero regards for whether the previous code has finished executing further up your .js file, making it synchronous. *‚ÄúOk,‚Äù* you exclaim, *‚Äúbut if that‚Äôs true, how can I both click buttons that do stuff on a browser while I‚Äôm waiting for other code to load? How can it be that I can do many actions, some of which appear to have blocking functionality simultaneously while other code runs?‚Äù*. Great questions, thanks for asking.\\n\\nWell, in short, it‚Äôs the browser or any other higher-level runtime that runs JavaScript allowing you to do these things. These higher-level abstractions give us other data structures similar to the call stack, allowing us to store code to be run later or at different times.\\n\\nUnder the hood, the browser uses these abstractions to manage what gets put onto our call stack. Two examples of these other data structures being used in conjunction with our call stack are `setTimeout()` that applies an input time constraint to when a callback is executed or a Fetch request that waits for the receipt of a response from a server before processing the following line of code.\\n\\nBoth are incompatible with JavaScript‚Äôs basic single threadedness, but the abstractions give us additional powers that allow for what appears to be non-single threaded behavior. In Chromium, these tools are known as WebAPIs and in Node C++ APIs. They juggle the code asynchronously ‚Äî ensuring it doesn‚Äôt interrupt code executed in the main thread of execution. You might be thinking at this stage, *‚Äúalright, then that means that this is executed in another thread‚Äù*.\\n\\nBut that depends on the engine executing your JavaScript. In the case of Chromium, this is simply the illusion of what appears like multithreaded concurrently executed code. We won‚Äôt go into any more detail on this since it warrants its own set of posts by itself, but this should give us enough context to have an understanding of what these higher leveled abstractions are capable of in JavaScript!\\n\\nOk, so now we‚Äôve got our understanding down for asynchronicity, let‚Äôs now move back onto the star of the show, Promises.\\n\\n# What‚Äôs even a Promise?\\n\\nA Promise is a type of JavaScript object representing a ‚ÄúPromised‚Äù future outcome. That‚Äôs it. While this isn‚Äôt a very clear description ‚Äî especially if you‚Äôre just piecing together your mental model of Promises, let‚Äôs focus on the JavaScript object part of that definition I just shared. At the most basic level, it‚Äôs a series (or chain) of objects within which there are callbacks. Chain because they are connected and if one link breaks the entire Promise does. Practically speaking, it allows you to do a few things, let‚Äôs take a look at those:\\n\\nFirst, you can set up code that relies upon executing and completing other callbacks in a stepped or blocked manner.\\n\\nThis is very powerful since it gives you the capability to closely control the flow of execution, which is terrific when you want to interact with a server, execute code upon the successful receipt of data, or create throttle functionality to avoid your server being pwned.\\n\\nExamples of this in action might include rendering your feed items on Instagram after the page loads or having Netflix play a video once sufficient data has been downloaded into your client.\\n\\nSetting up asynchronous tasks to run-one-after-the-other-is-completed is known as Promise chaining, typically put in practice using the `.then` syntax. Yes, there‚Äôs the specific syntax to learn here, but believe me, this is a small price to pay when the alternative is nesting callback and visiting callback hell.\\n\\nPromise chaining also allows you to pass the returned values down between the callbacks in a Promise chain. In the example of the Fetch request, it means sending a request to your server, waiting for a response, and then processing that response when it comes back to our client.\\n\\nSee the code block below to understand Promise syntax and how Promises operate. I‚Äôve tried to use very verbose function names to give you a sense of what‚Äôs going on:\\n\\n```\\n \\nnew Promise(function doThisFirst(resolve, reject) {\\n  console.log('Hey, I just met you')\\n  resolve()})\\n .then(function doThisSecond() {\\n  console.log('and this is crazy')\\n }).then(function doThisThird() {\\n  console.log('But here\\\\'s my number')\\n }).then(function doThisFourth() {\\n  console.log('so call me, maybe')\\n }).catch(() => {\\n  console.error('Number engaged');\\n });\\n```\\n\\nSecond and in addition to my first point, because we can run what appears to the user as blocking tasks whilst still running our main thread of execution, we get the flexibility to execute other code. This means that the user experience is preserved as they can go about other tasks in the browser without being held up by the Promise logic.\\n\\nIn Chromium, this is achieved by the browser doing a tonne of juggling using the Event Loop to run our code in a concurrent-like way. To understand this in more detail, check out [the great talk that Phillip Roberts did at JSConf in 2014](https://www.youtube.com/watch?v=8aGhZQkoFbQ), which explains how that works.\\n\\nThird, Promises give you the ability to tie in error handling logic neatly. This is because of how Promises are executed. A Promise object chains functionality together to either be pending, resolved (fulfilled), or rejected. With the addition of the `.catch` Promise syntax, you can have your Promise execute a `console.log` of your error upon the failure of one of the functions called within the Promise chain. Conceptually similar JavaScript concepts are try-catch blocks. In the code block above we‚Äôd log ‚ÄúNumber engaged‚Äù if for whatever reason the other chains in the Promise failed. Promise error handling helps with debugging since the error is contained in the block of works associated with the Promise workflow. This is particularly useful when you make network requests and troubleshoot why you weren‚Äôt served data from a given API endpoint.\\n\\n![Promise state flow](https://images.mirror-media.xyz/publication-images/4W05lpXOH0LrfXv2jeBwL.png?height=259&width=700)\\n\\nAs a heads up, there is one main limitation you might come across when playing around with Promises. As I said at the start, they are JavaScript objects but special ones so you can‚Äôt simply manipulate them as you would an array or regular object literal. If you `console.log()` out your Promises you‚Äôll probably see what I mean. What is returned is illegible and unusable. Something like this:\\n\\n```\\nPromise { <pending> }\\n```\\n\\nInstead when working with Promises be sure to have the callback leverage closure to take whatever data is manipulated inside your Promise and update a relevant data type in the lexical scope of the parent execution context, thereby assuring that you can both get the most out of your Promises but not run into any usability bugs when coding.\\n\\nHopefully, by now, you will understand more about how JavaScript works under the hood than what you did at the start of the article and, in turn, how Promises can help you when you code. Of course, there‚Äôs much more to be said on the topic of Promises, but as a point of departure, we now know that they can give us the flexibility to write blocking asynchronous and graceful error handling code.\\n\\n**Hi üëã my name is Michael I‚Äôm a Software Engineer @Codesmith / Previously Data Scientist / Ex-Monzo / Ex-WeWork / Musings live here <https://giardinetto.co> or here on Mirror** \",\"timestamp\":1637273842,\"title\":\"Demystifying Promises in JavaScript: How Do They Work?\"},\"digest\":\"Ux12ylB57DVRCSzruVd8S5TVZZjs0lA88jTnb0lVN2s\",\"authorship\":{\"contributor\":\"0x94829d0b7A2341fCE1CF09FF67169f994eE7bdA2\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"HPLk1EbbTvAbtQ3m4B-vk4w20qt4f8rZRv2q7EsLbWs\\\",\\\"y\\\":\\\"4n4u0BdFIBVeOb4Y5dpabrzbmxs6Svr18dxH64uhYx8\\\"}\",\"signature\":\"3qGEeMfo5Kny3CqqUFy5oImjzfDigVZTdfCUzcVL3ryeRypNFPrUmfn2obu_ZLO-Uoxr6_EQy-bzaXyX07O5bA\",\"signingKeySignature\":\"0xa7b6b925d4e2a569d0031cb97c52bd26b13ef46e2760e4f41a38851a8233320a1075389c4734042c6fcc32e910fde2e9cd1c8e5c48fea25c7dc44fc9821819ce1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"HPLk1EbbTvAbtQ3m4B-vk4w20qt4f8rZRv2q7EsLbWs\\\",\\\"y\\\":\\\"4n4u0BdFIBVeOb4Y5dpabrzbmxs6Svr18dxH64uhYx8\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"Ux12ylB57DVRCSzruVd8S5TVZZjs0lA88jTnb0lVN2s\"}"