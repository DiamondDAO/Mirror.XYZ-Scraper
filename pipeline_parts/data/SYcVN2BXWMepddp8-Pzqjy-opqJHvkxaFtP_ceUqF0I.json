"{\"content\":{\"body\":\"![](https://images.mirror-media.xyz/publication-images/50f170fa-7368-4f99-86e0-3d8adf85cd08.jpg?height=640&width=1280)\\n\\nOne of the big appeals of dApps is that the user owns their data. However, for this to be true, we need to authenticate the user with their web3 identity (their wallet). This is easy to do client-side (since they can submit all their tx's themselves using Metamask) but gets harder when we need to verify their identity from a server.\\n\\nIn this article, I’ll be outlining the technical implementation of a “Login with wallet” button, similar to the ones provided by [Showtime](https://tryshowtime.com) or [Foundation](https://foundation.app).\\n\\n## From wallet to server\\n\\nThe first implementation for this is pretty simple. We have the user connect their wallet to our frontend, and make an API request to our server with the retrieved wallet address.\\n\\nThe issue here is that anyone can send an API request with anyone else’s address to our API, and we have no way of verifying if that address matches the one connected to the frontend.\\n\\n## Crypto stands for Cryptography\\n\\nIt’s easy to forget that, in essence, crypto wallets are just a cryptographic key pair (a combination of a private and public key). When you create a transaction, you’re just signing the parameters of your transactions (to mathematically prove you’re the creator) and broadcasting it to the ETH network.\\n\\nLuckily, transactions aren’t the only thing wallets can sign. We can create an arbitrary message (like `Please sign this message to connect to Foundation.`), and verify the signature to make sure the wallet trying to authenticate was the one that signed our message.\\n\\nEthereum signatures are Keccak (SHA-3) hashes that start with `Ethereum Signed Message:`. This allows us to perform our verification with a Keccak and an ECC (Elliptic Curve Cryptography) library on any programming language.\\n\\nTo make this work we’ll need three things: the address that we’re trying to authenticate, the message that we signed, and the signature, which we can get using any web3 library (`ethers.js` in this example):\\n\\n```js\\nimport axios from 'axios'\\nimport { ethers } from 'ethers'\\n\\n// Note: on production, you should use something like web3Modal to support additional wallet providers, like WalletConnect\\nconst web3 = new ethers.providers.Web3Provider(window.ethereum)\\n\\nconst message = \\\"Sign this message to log in to our app\\\" \\n\\nawait axios.post('/api/auth/login', {\\n\\taddress: await web3.getSigner().getAddress(),\\n\\tsignature: await web3.getSigner().signMessage(message),\\n})\\n```\\n\\nOn the server, we can then use `eth-sig-util` to verify the message was signed by the submitted wallet, and authenticate it via a cookie or API token.\\n\\n```js\\nimport { recoverPersonalSignature } from 'eth-sig-util'\\n\\nconst message = \\\"Sign this message to log in to our app\\\" \\n\\nif (! address.toLowerCase() === recoverPersonalSignature({ data: data, sig: signature }).toLowerCase()) {\\n\\tthrow new Error('Authentication failed')\\n}\\n\\n// wallet address has been verified\\n```\\n\\nIf you want to get a better grasp at how this verification works behind the scenes, you can check [my PHP implementation of the signature verification code](https://github.com/m1guelpf/laravel-web3-login/blob/f1d370f790fa7e81d88bb0c5e794eb313ed50849/src/Signature.php#L16-L34).\\n\\n## Protecting against replication attacks\\n\\nWe have a system that allows anyone to log in with their wallet, and a way to make sure you can’t authenticate as other people. But there’s an issue. Since we’re always signing the same message, any of those signatures serve as a perpetual key to our account, which never expires.\\n\\nThis means that, if someone were to intercept it via a MITM attack or by tricking us into signing that same message on a different site, they’d get non-revokable access to our account.\\n\\nTo prevent this, we need to make sure the message is different each time. The easiest way to do this is by generating a random string (nonce) and including it on the message.\\n\\nWe’ll first need to generate our nonce server-side and store it on the session (since we’ll need it to verify the signature later):\\n\\n```js\\nimport crypto from 'crypto'\\n\\nexport default async function(req, res) {\\n\\treq.session.nonce = crypto.randomInt(111111, 999999)\\n\\t\\n\\tres.end(`Hey! Sign this message to prove you have access to this wallet. This won't cost you anything.\\\\n\\\\nSecurity code (you can ignore this): ${req.session.nonce}`)\\n}\\n```\\n\\nThen, instead of hardcoding the message to sign, we retrieve it from the server via AJAX:\\n\\n```js\\nimport axios from 'axios'\\nimport { ethers } from 'ethers'\\n\\n// Note: on production, you should use something like web3Modal to support additional wallet providers, like WalletConnect\\nconst web3 = new ethers.providers.Web3Provider(window.ethereum)\\n\\nconst message = await axios.get('/api/auth/nonce').then(res => res.data)\\n\\nawait axios.post('/api/auth/login', {\\n\\taddress: await web3.getSigner().getAddress(),\\n\\tsignature: await web3.getSigner().signMessage(message),\\n})\\n```\\n\\nFinally, before checking the signature we’ll need to reconstruct the message by pulling our nonce from the session.\\n\\n## 📦\\n\\nAs with everything, there are a few packages that can take care of this process for you. I recommend using [passport-web3](https://github.com/coopermaruyama/passport-web3) on Node, and [laravel-web3-login](https://github.com/m1guelpf/laravel-web3-login) if you’re working with PHP and Laravel. If you find packages for other languages, [DM me](https://twitter.com/m1guelpf) and I’ll add it here.\",\"timestamp\":1618591095,\"title\":\"Server Authentication for web3\",\"publication\":\"miguel\"},\"digest\":\"VBlaOTPAxQNFHjl5n-C3BvhkpizvAui9A4RJDwFiQ3k\",\"authorship\":{\"contributor\":\"0xE340b00B6B622C136fFA5CFf130eC8edCdDCb39D\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"s5dxBgjTfZ5IWK7pVL7mWf2jtUG6ibGD86H-eoO2hSI\\\",\\\"y\\\":\\\"zv1QfjUOcpQ_oyarQWkqVt2xds0opIqWKagmFYb_T1Y\\\"}\",\"signature\":\"vuVwSACOy8OQ87WlMAxw9g5aB9axwKMCW-41dWeyx0hknNVYDFasmefy1FIcDpZzovwX5UmkNas6lFa6cKk4Yg\",\"signingKeySignature\":\"0xa7b09c09fce6881ef0c9452ba8562261c370e82b4e340e0ccf89de85a1197f3476687c7434572f78641cb4be894a516af7878b9544deb1398c8b0e096498ca2d1b\",\"signingKeyMessage\":\"I authorize the publication of articles on miguel.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"s5dxBgjTfZ5IWK7pVL7mWf2jtUG6ibGD86H-eoO2hSI\\\",\\\"y\\\":\\\"zv1QfjUOcpQ_oyarQWkqVt2xds0opIqWKagmFYb_T1Y\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"VBlaOTPAxQNFHjl5n-C3BvhkpizvAui9A4RJDwFiQ3k\"}"