"{\"content\":{\"body\":\"# gin框架\\n\\n1、gin框架的路由是采用洋葱模型，中间件和具体接口采用同样的方式，提前放入handler，只是中间件方法中，有Next()方法，继续执行下一个，具体接口中则没有Next()方法，当然，中间件中也可以采用Abort()方法，终止程序继续往下执行。\\n\\n详细可以参考这篇文章：\\n\\n[https://blog.csdn.net/raoxiaoya/article/details/109444890](https://blog.csdn.net/raoxiaoya/article/details/109444890)\\n\\n# 基础\\n\\n## struct之间可以相互比较吗\\n\\n1、同一个类型的struct，且没有不可比较的类型（map,slice等），则可以进行比较。\\n\\n2、一旦struct中包含不可比较的类型，或者是两个结构体，则不可进行比较，即便两个struct有相同的类型也不可以，因为地址不一样。\\n\\n## select\\n\\n1、select和channel配合使用，用于等待一个或多个channel的输出。\\n\\n## golang在导入包的时候，”_”/”.”二者有什么区别\\n\\n1、”_”表示，导入的包仅适用里面的`init`函数，并不适用里面其他的函数。\\n\\n2、”.”表示导入的包，在使用里面的函数时，可以省略包名。\\n\\n## slice和数组的比较\\n\\n1、数组在传参的时候，是值传递，会对整个数组进行拷贝，会消耗大量的内存。\\n\\n2、slice传参是传递引用，不会消耗大量内存，但同时这又是一个风险点，会改变原值。\\n\\n## slice的底层实现\\n\\n1、slice是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象，因为基于数组实现，所以它的底层的内存分配是连续的，效率非常高，还可以通过索引获取数据，可以迭代及垃圾回收优化。\\n\\n切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。\\n\\n切片对象非常小，是因为它是只有三个字段的数据结构：\\n\\n* 指向底层的数组指针\\n* 切片的长度\\n* 切片的容量\\n\\n**这三个字段就是golang操作底层数组的元数据**\\n\\n![slice和array](https://images.mirror-media.xyz/publication-images/LECuZxi25z2lddgRCvq0g.png?height=334&width=916)\\n\\n# slice的扩容机制是什么，有什么注意点\\n\\n* 首先判断，如果新申请容量大于2倍的旧容量，最终容量就是新申请的容量\\n* 否则判断，如果旧切片的长度小于1024，则最终容量就是旧容量的两倍\\n* 否则判断，如果旧切片长度大于等于1024，则最终容量从旧容量开始循环增加原来的 1/4, 直到最终容量大于等于新申请的容量\\n* 如果最终容量计算值溢出，则最终容量就是新申请容量\\n\\n伪代码如下：\\n\\n```\\n\\tif cap > 2*oldCap {\\n\\t\\tnewCap = cap\\n\\t} else if cap < 1024 {\\n\\t\\tnewCap = 2*oldCap\\n\\t} else {\\n\\t\\tnewCap = oldCap\\n\\t\\twhile (newCap < cap && !overflow) {\\n\\t\\t\\tnewcap += newcap/4\\n\\t\\t}\\n\\t\\tif overflow {\\n\\t\\t\\tnewCap = cap\\n\\t\\t}\\n\\t}\\n```\\n\\n# 扩容前后的slice是否相同？\\n\\n分两种情况。\\n\\n**情况一：**\\n\\n> ```\\n> 原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的Slice。\\n> ```\\n\\n**情况二：**\\n\\n> 原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。\\n\\n**要复制一个Slice，最好使用Copy函数。**\\n\\n# golang的参数传递、引用类型\\n\\nGo语言中**所有的传参都是值传递**（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是**引用类型**（**指针、map、slice、chan**等这些），这样就可以修改原内容数据。\\n\\nGolang的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。（**这也是new和make的区别**）\\n\\n# golang map底层实现\\n\\nGolang中map的底层实现是一个散列表，因此实现map的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫hmap(a header for a go map)，一个叫bmap(a bucket for a Go map，通常叫其bucket)。hmap如下所示：\\n\\n![](https://images.mirror-media.xyz/publication-images/pbNV30rC-_lqWZ5m51IV2.png?height=1042&width=506)\\n\\n图中有很多字段，但是便于理解map的架构，你只需要关心的只有一个，就是标红的字段：buckets数组。Golang的map中用于存储的结构是bucket数组。而bucket(即bmap)的结构是怎样的呢？\\n\\nbucket：\\n\\n![](https://images.mirror-media.xyz/publication-images/Iynl2hg8__oy7ufzKDQ5w.png?height=550&width=412)\\n\\n相比于hmap，bucket的结构显得简单一些，标红的字段依然是“核心”，我们使用的map中的key和value就存储在这里。“高位哈希值”数组记录的是当前bucket中key相关的“索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的bucket的指针，使得bucket会形成一个链表结构。\\n\\n整体的结构应该是这样的：\\n\\n![](https://images.mirror-media.xyz/publication-images/ZLCktYVbDaDKUi9H7wjFo.png?height=1184&width=2020)\\n\\nGolang把求得的哈希值按照用途一分为二：高位和低位。低位用于寻找当前key属于hmap中的哪个bucket，而高位用于寻找bucket中的哪个key。\\n\\n需要特别指出的一点是：map中的key/value值都是存到同一个数组中的。这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。\\n\\n![](https://images.mirror-media.xyz/publication-images/v8HAeHaflJ9XXm3OTqhqh.png?height=230&width=1928)\\n\\nMap的扩容： 当Go的map长度增长到大于加载因子所需的map长度时，Go语言就会将产生一个新的bucket数组，然后把旧的bucket数组移到一个属性字段oldbucket中。 注意：并不是立刻把旧的数组中的元素转义到新的bucket当中，而是，只有当访问到具体的某个bucket的时候，会把bucket中的数据转移到新的bucket中。\\n\\n# golang接口接收规则\\n\\n* 实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口。\\n* 实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口\\n\\n# context包有什么用途\\n\\n* 程序超时\\n\\n  代码如下：\\n\\n  ```\\n  package main\\n  \\n  import (\\n      \\\"context\\\"\\n      \\\"net/http\\\"\\n      \\\"fmt\\\"\\n      \\\"sync\\\"\\n      \\\"time\\\"\\n      \\\"io/ioutil\\\"\\n  )\\n  \\n  var (\\n      wg sync.WaitGroup\\n  )\\n  \\n  type ResPack struct {\\n      r *http.Response\\n      err error\\n  }\\n  \\n  func work(ctx context.Context) {\\n      tr := &http.Transport{}\\n      client := &http.Client{Transport: tr}\\n      defer wg.Done()\\n      c := make(chan ResPack, 1)\\n  \\n      req, _ := http.NewRequest(\\\"GET\\\", \\\"http://localhost:9200\\\", nil)\\n      go func() {\\n          resp, err := client.Do(req)\\n          pack := ResPack{r: resp, err: err}\\n          c <- pack\\n      }()\\n  \\n      select {\\n      case <-ctx.Done():\\n          tr.CancelRequest(req)\\n          <-c\\n          fmt.Println(\\\"Timeout!\\\")\\n      case res:= <-c:\\n          if res.err != nil {\\n              fmt.Println(res.err)\\n              return\\n          }\\n          defer res.r.Body.Close()\\n          out, _ := ioutil.ReadAll(res.r.Body)\\n          fmt.Printf(\\\"Server Response: %s\\\", out)\\n      }\\n      return\\n  }\\n  \\n  \\n  func main() {\\n      ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)\\n      defer cancel()\\n      wg.Add(1)\\n      go work(ctx)\\n      wg.Wait()\\n      fmt.Println(\\\"Finished\\\")\\n  }\\n  ```\\n* 生成Request ID中间件\\n\\n  代码如下：\\n\\n  ```\\n  package main\\n  \\n  import (\\n      \\\"net/http\\\"\\n      \\\"context\\\"\\n      \\\"fmt\\\"\\n  )\\n  \\n  const requestIDKey = \\\"rid\\\"\\n  \\n  func newContextWithRequestID(ctx context.Context, req *http.Request) context.Context {\\n      reqID := req.Header.Get(\\\"X-Request-ID\\\")\\n      if reqID == \\\"\\\" {\\n          reqID = \\\"0\\\"\\n      }\\n      return context.WithValue(ctx, requestIDKey, reqID)\\n  }\\n  \\n  func requestIDFromContext(ctx context.Context) string {\\n      return ctx.Value(requestIDKey).(string)\\n  }\\n  \\n  func middleWare(next http.Handler) http.Handler {\\n      return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\\n          ctx := newContextWithRequestID(req.Context(), req)\\n          next.ServeHTTP(w, req.WithContext(ctx))\\n      })\\n  }\\n  \\n  func h(w http.ResponseWriter, req *http.Request) {\\n      reqID := requestIDFromContext(req.Context())\\n      fmt.Fprintln(w, \\\"Request ID: \\\", reqID)\\n      return\\n  }\\n  \\n  func main() {\\n      http.Handle(\\\"/\\\", middleWare(http.HandlerFunc(h)))\\n      http.ListenAndServe(\\\":9201\\\", nil)\\n  }\\n  ```\\n\\n## golang为什么高效\\n\\n1、goroutine是golang并行设计的核心。\\n\\n2、goroutine说到底就是协程，但是它比线程更小，几十个协程可能底层对应的就是五六个线程，golang内部帮你实现了这些协程之间的内存共享。\\n\\n3、执行协程，只需要极少的栈内存，大概是4\\\\~5kb，也正因为这样，在一台机器上可以开启成千上万个协程，只要内存足够即可。\\n\\n4、golang既支持通过共享内存进行通讯，也支持通过消息传递的方式进行通讯，后者是CSP的一个变种，效率更高，也是golang推荐的方式。\\n\\n**总结为：用户空间 避免了内核态和用户态的切换导致的成本、可以由语言和框架层进行调度、更小的栈空间允许创建大量的实例。**\\n\\n关于golang的CSP模型说明，可以查看这篇文章：\\n\\n[https://www.jianshu.com/p/36e246c6153d](https://www.jianshu.com/p/36e246c6153d)\\n\\n# 特别需要注意的代码执行题目\\n\\n1、以下程序输出什么\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc calc(index string, a, b int) int {\\n\\tret := a + b\\n\\tfmt.Println(index, a, b, ret)\\n\\treturn ret\\n}\\n\\nfunc main() {\\n\\ta := 1\\n\\tb := 2\\n\\tdefer calc(\\\"1\\\", a, calc(\\\"10\\\", a, b))\\n\\ta = 0\\n\\tdefer calc(\\\"2\\\", a, calc(\\\"20\\\", a, b))\\n\\tb = 1\\n\\t//time.Sleep(1000 * time.Second)\\n}\\n\\noutput:\\n10 1 2 3\\n20 0 2 2\\n2 0 2 2\\n1 1 3 4\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\ts := make([]int, 5)\\n\\ts = append(s, 1, 2, 3)\\n\\tfmt.Println(s)\\n}\\noutput:\\n[0 0 0 0 0 1 2 3]\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\ntype People interface {\\n\\tSpeak(string) string\\n}\\n\\ntype Stduent struct{}\\n\\nfunc (stu *Stduent) Speak(think string) (talk string) {\\n\\tif think == \\\"bitch\\\" {\\n\\t\\ttalk = \\\"You are a good boy\\\"\\n\\t} else {\\n\\t\\ttalk = \\\"hi\\\"\\n\\t}\\n\\treturn\\n}\\n\\nfunc main() {\\n\\tvar peo People = Stduent{}\\n\\tthink := \\\"bitch\\\"\\n\\tfmt.Println(peo.Speak(think))\\n}\\n\\n//编译不过去，需要修改一行代码：\\nvar peo People = Stduent{} 修改为 var peo People = &Stduent{}\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\ntype People interface {\\n\\tShow()\\n}\\n\\ntype Student struct{}\\n\\nfunc (stu *Student) Show() {\\n\\n}\\n\\nfunc live() People {\\n\\tvar stu *Student\\n\\treturn stu\\n}\\n\\nfunc main() {\\n\\tif live() == nil {\\n\\t\\tfmt.Println(\\\"AAAAAAA\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"BBBBBBB\\\")\\n\\t}\\n}\\n\\noutput:\\nBBBBBBB\\n原因：指针类型的地址和nil不一致，不相等\\n```\\n\\n```\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tdefer_call()\\n}\\n\\nfunc defer_call() {\\n\\tdefer func() { fmt.Println(\\\"打印前\\\") }()\\n\\tdefer func() { fmt.Println(\\\"打印中\\\") }()\\n\\tdefer func() { fmt.Println(\\\"打印后\\\") }()\\n\\n\\tpanic(\\\"触发异常\\\")\\n}\\noutput:\\n打印后\\n打印中\\n打印前\\npanic: 触发异常\\n\\n原因：遇到panic，遍历本协程的defer链表，并按照先进后出的顺序执行\\n```\",\"timestamp\":1639997873,\"title\":\"golang面试题\"},\"digest\":\"VD8YBPkU0jZbqqC-4gA5g3iFGCcu9iFehjda-ZXF34I\",\"authorship\":{\"contributor\":\"0x3593df8f329981B1C3E9066551dF17F2174ADdc5\",\"signingKey\":\"{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"E05sup7k_rINOhhYQPPw7uwBzjIDwyhKuSpkm8bnrqc\\\",\\\"y\\\":\\\"EXilclIWOCPfx-r29vtTUOu6hv9GmIQzV1tyc8ZNgwQ\\\"}\",\"signature\":\"Brltdw2269yyB27ipafJds5iRlpP0gL5tm9DfnEXzCnARYfkarw-tsQdIOBXW2BaLTbWj_yn_LqY_GDPTevWsQ\",\"signingKeySignature\":\"0xf2de31187198cdc3677a7062d5d6ea48d401d38cb4be76fce1c743932e4f48921a49e0672b44aaa8bdf925800779b8d18af58c03e24370d2d85a17264a16f7101b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"alg\\\":\\\"ES256\\\",\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"E05sup7k_rINOhhYQPPw7uwBzjIDwyhKuSpkm8bnrqc\\\",\\\"y\\\":\\\"EXilclIWOCPfx-r29vtTUOu6hv9GmIQzV1tyc8ZNgwQ\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"LEFQeon2SUK-49_g-J0ASzbTXO9XT1GuNs_l5EIPFR4\"}"