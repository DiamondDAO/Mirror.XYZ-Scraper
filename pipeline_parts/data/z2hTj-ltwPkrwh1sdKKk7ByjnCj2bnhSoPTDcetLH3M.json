"{\"content\":{\"body\":\"本文首次发布于2021-07-19，微信公众号IOSGVC\\n\\n![](https://images.mirror-media.xyz/publication-images/vgjwyMBpjlaa7NVBrHBjS.png?height=710&width=1080)\\n\\n> 区块链数据行业是区块链行业长期的热点，而区块链数据索引和API服务又是这个行业不可忽视的赛道。dApp开发者在构建产品前端时需要大量调用链上数据，索引是对数据进行结构化和分类的一种方式，而The Graph目前在这一领域处于绝对的领先位置，它在过去一年在以太坊上得业务量有超过20倍的增长，当前的月调用次数超过了200亿次。在以太坊牢牢站稳脚跟后，The Graph也在激进地朝各个公链、Layer2扩张版图，今年已经和Arbitrum, Optimism, BSC等链达成了合作。\\n\\n \\n \\n\\nIOSG Ventures 与 Chainlink 联合主办的 Layer2黑客松 第三场workshop已于7月18日8：00pm直播。The Graph的开发者关系 Nader Dabit在此次直播中带大家深入了解如何利用GraphQL, The Graph 与 Next.js在以太坊上开发。\\n\\n## \\n\\n### 内容回顾\\n\\n各位观众们，大家好呀，大家也在聊天室打个招呼吧。我不在平常的工作室里，能看出来吗？我在海边，待会就在这儿直播啦，面朝大海。我们的工作就是这么爽，办公场地 随心所欲。今天我在海边办公，听着海浪声直播。我播到一半可能要休息一下，去喝点水或吃点东西。我们毕竟要讲近一个小时呢。\\n\\n总之呢，今天我们The Graph有个重大的发布，待会就跟大家详细讲讲。我们在建一个很酷的项目，我会讲下我们的想法，还有目前做的事情。我们对此非常兴奋。我加入团队才三个月，但他们已经为这个项目筹划四年了。今天发布的一些点子尽管都经过了深入的探究，但仍然处于理论阶段。甚至是一些在业内乍现，但还没有人实现过的想法。因为太过错综复杂，还得为用户们配备多个层面的交互页面。所以我也很期待今天的分享。\\n\\n \\n \\n\\n**介绍The Graph网络**\\n\\n我要向大家展示如何建立用于前端的 API。我会先简要介绍我们的网络，然后讲解不同的参与方式。这一过程中得写些代码，基本内容就是这些。如果大家还没看我们的新品发布，我把链接发到聊天室，大家可以点开看里面的新内容，博客里都有写。 \\n\\n有人提到在巴黎开的以太坊大会。我没票，但还是会去。如果你们人在巴黎，就算不参加大会，还是可以来找我，我很乐意聚一聚，给你们展示些Graph的干货。我也会给大家带Graph的T恤、Graph的贴纸，请你们喝一杯或者喝咖啡，请你们吃顿饭也行。我反正要在那待一个星期左右，希望能跟大家见面。\\n\\n我把新产品的链接发给大家了，这个发布了The Graph相关的两个产品，或者两个说新的功能。一个是Subgraph Studio。像我这样的开发人员可以利用开放数据集在上面构建开放API。我可以发布我的API，基本上就等于说：嘿，网络里有没有人要从我的API索引数据？一旦产生了索引的流量，我就可以开始赚钱。我也可以添加别人的API，它们的流量也可以帮我赚钱。我就当个软件工程师，只运行一个节点、一个索引器，这样就能赚到钱了。所以有各种各样的方式可以赚到钱。\\n\\n我最感兴趣的地方就在于此**。这其实是一种激励方式，真的能帮用户获利**。金钱是最好的激励，对我最大的激励也在于此。主要是因为，尽管我从小生活也不算拮据，但在我人生的前十年里，确实没赚到什么钱。但是靠做软件，我赚到了第一桶金。我也看到很多人，天南海北的，都参与了The Graph的建设，很早就投身进来，也因此实现了财富自由。所以我很喜欢这里的激励方式。\\n\\n我认为这种方式是关于如何利用我们所支持的各种网络上的开放数据集，大家能想到的最酷的点子。目前支持的主要是区块链和去中心化数据源，但未来的想法是，我们将能够让我们的索引器处理任何类型的开放数据集。今天很多人都在讨论这个问题，如何找到想要索引的数据集，并把它们嵌入现有网络。由自己编写交易代码，然后索引进Graph API也是可以的。 \\n\\n \\n \\n\\n**API设计的概念**\\n\\n好的，现在我们就开始设计app吧，或者叫API。我刚写了一个API，完成了部署，已经出现在用户页面上了。大家可以在Dashboard里找到它，任何人都可以用它建立前端了。以前的做法是把智能合约单独设为交易层，但现在用户可以直接在前端查询合约。我们现在就来建立这样功能的UI。**这样一来API人尽可用 ，产生的费用也不会进入Google或AWS这些大公司的口袋。**当然啦 尽管人们可能还是在这些云上运行基础设施，但实际的利润都归开发者了。于我而言 这是另一个极酷的设计。\\n\\n以上是一个大体介绍。一直关注The Graph的朋友肯定都了解了，但我觉得还有很多人，比如说矿工、在传统网络领域的网络开发人员等，The Graph对他们还比较新鲜。尽管我们也取得了极为鼓舞的数据成绩，每日询问量突破十亿次，简直是火箭式增长。我们选择一家科技公司时，看重的就是指数增长的能力。早期入局一项技术时亦然。现今的重点早已不是看总量，而是发展的潜力有多大。只要一整年都保持高增长，绝对无往不利。我真正看重的是这个。\\n\\n \\n \\n\\n**构建API的具体步骤**\\n\\n话不多说 我们开始编程。首先，我来分享下我的屏幕，马上就好，电脑要设置一下。开始之前我得先把这些应用关一下。分享我的屏幕，好了，搞定。这是The Graph的网站，你们可能早就见到了。**直播里我主要想介绍如何构建API，在新的UI中部署API。在这个Studio里。然后用Next.js为其建立前端**。我们今天就做这些。\\n\\n开始的第一步呢，我在终端上创建一个空白窗口。首先我得调大字号，字也太小了。把字号调大到33吧。可以了。目前是我的终端界面 ，我就在这里创建新的Subgraph。大家看一下浏览器，这也是我们今天发布的内容。这里的这些app，其中一些API已经登陆去中心化网络了，比如PoolTogether是比较热门的。当然还有像Uniswap这种交易量过十亿的应用，好多主流应用都在这里了。他们相当于我们的发布合作伙伴，今天一起发布。点开一个API看，你们或许很熟悉它们运行的应用，好多都是金融类应用。对我来说，演示起来更有趣的是艺术作品类视觉上的东西。我今天就选择一个NFT交易所作为示例，形成可视化。我觉得金融数据相对比较难可视化，用作用户接口展示也没什么意思。\\n\\n \\n \\n\\n**建立Subgraph**\\n\\n简而言之 我要建一个Subgraph。先点开Subgraph Legacy Explorer，搜索Zora，会出来很多Zora智能合约，它们都用Subgraph部署过了。复制这段数据，直接搜网页，也可以调用更多别的数据。选择用ID排序，然后从这里抽取一串代码。出现这个圈圈一直转的时候，说明视频等内容在缓冲，缓冲完可以看。貌似没在加载，看看这边行不行 ，说不定能找到一张能用的图。找到了，这样的图就行。我们待会就用它。\\n\\n我看下有没有提问是我漏掉的，可能有很多没看到，我待会等得空再回来看提问吧。本次直播会录屏，结束后会发到我的Twitch和YouTube上。我今天要为Zora开发一个API，先输入zora.co进入他们的网站，上面各种各样的NFT可以购买或售卖，我们就为这个网页编写UI吧。还有一个有意思的网站是Foundation。输入foundation.app 进入网站。他们的网站也很不错，你可以看到当前的出价。这个差不多4000美元 等价两个Eth，这一个要5000美元左右。Foundation和Zora这两个网站可以帮我们完成很多行动。\\n\\n我今天用Zora，前面说过，它是一个NFT交易所。我们先创建一个Subgraph，然后为其创建UI。我们首先进入Subgraph Studio，创建新的Subgraph。名称输入Zoralivestream，然后就可以看到我们在Studio里新建的Subgraph页面。我们可以在本地创建和编写代码，写完之后部署，把它添加到Studio Dashboard。这里有一些操作指导，但是更好的操作指导在我们的新网站上。上面有我们全新编写的文件。你也可以下拉翻看博客《Subgraph Studio操作指南》，这基本就是我们今天要讲的内容。这篇博客其实是我自己写的。这就是我们今天要构建的API，每个步骤都里面都写了。\\n\\n 我们已经创建了这个，生成了slug（标题），状态为UNDEPLOYED，说明目前还未部署。这里是部署秘钥，下面有一些安装指导，Graph CLI之类的，我们都会用到。现在可以开始写代码了。页面基本是这样，现在回到CLI。直接开始安装CLI。我这边应该已经安装过了，我再安装一次给大家看。安装好后，我们得到这个二进制程序，然后可以使用The Graph的CLI了。\\n\\n在它安装的过程中，我先带大家过一遍这个教程，这也是我今天主要想讲的内容。这里讲的是如何设置，我们讲过了，我也创建好新Subgraph了。现在我们在这一步，完成安装。CLI装好后，大家就可以运行graph。这里的二进制程序已经给出指令了，graph —help可以帮助输入常用命令。我们需要的是init（初始命令），选择初始Subgraph。这个指令可以帮助创建，我们所需的各种API样板代码。这里是我们运行graph init的命令代码，我们在这边标记一些变量，输入contract name（合约名称）。这个就表示我们调取的数据源是Token（代币）。因为这些是数字资产，用的是基于OpenZeppelin ERC721标准，即非同质代币，所以这里用Token比较合适。\\n\\nindex-events的作用是进入API内部。或者应用二进制接口，其实就是访问以太坊上的智能合约。API本质上是能用来与合约交互的，输入指令可以进入ABI，调出允许创建的实际事件，为我们在本地创建样板代码。所以这个指令是帮助我们基于events写基础代码的。\\n\\n我也说过我们会用到Subgraph Studio。因为现在我们既有托管服务，也有Studio，未来大部分的app都会使用Studio，但我们仍然想支持旧的服务。这里先明确studio ，然后我们也可以明确我们正在使用的智能合约。所以，我们用这个Zora。这一串字符是Zora的智能合约，怎么找到呢？在浏览器输入Zora developer documentation，就可以找到。这里有他们智能合约的链接，当然你也可以去Etherscan。Etherscan上基本有所有人的智能合约地址。你也可以通过其他办法找到，很多合同都有公开地址。在这种情况下，Zora甚至建了一个开发人员文档库；Foundation也有文档库，也很方便。fnd.dev上可以找到跟他们有关的全部Subgraph，他们还建了一个自己支持的Subgraph。Zora也一样，他们也有自己的Subgraph。大家可以选择直接用他们的Subgraph代码，但我今天会从头演示一遍怎么写。\\n\\n合约地址可以通过以上途径找到，地址都在这里。输入地址后，摁回车键就可以。操作到现在，我们只需要输入Subgraph名称，直接从slug这里复制，其他这些我们都可以取默认值，这样就在本地创建了所有需要的样板代码。 \\n\\n我现在应该可以进入这个新的目录，打开文本编辑器。好了。这一侧是样板代码，是你发布 Subgraph所需的全部内容，包含另外三个主要部分组成。如果你搞懂了这三个主要部分，你基本可以在我们支持的所有网络上建立API。这里是schema.graphql，是graph的合集，我们先删除。这个是subgrph.yaml，是各种配置，默认有35行代码，会直接生成，也可能少一些。但subgrph.yaml基本上是代码的基础结构，通过这个基础结构告诉索引器，我们部署API的目的，如何使用各项数据来源。我们待会再详细说这个。\\n\\n最后一项是src 也就是mapping。这些是mapping模板。如果你曾经用过AppSync，或者The GraphQL，那你肯定接触过mapping模板。这些的作用本质上是handler函数。**比如你有事件的数据 要进行handler运算，我们的情况可能是，有一个token交易的事件，而我们想要处理该事件的数据，希望把它存储在我们自己本地的API上，储存之后开放给别人使用。这是关于mapping的内容**。这些想法直接促使我从在Web2.0领域用GraphQL做传统应用的日子里，做出转变。以上就是主要框架，关于schema.graphql subgraph.yaml和mappings的介绍。\\n\\n \\n \\n\\n**使用GraphQL**\\n\\n首先，我们先来用GraphQL写schema。我直接复制黏贴一些我们需要的这两个Type的代码，两个Type分别是Token和User。我们看回到Zora，上面这么多NFT，每一个都关联了用户地址。而我们要做的是存储这些信息，以及关于这些NFT token自身的元数据。因此我们输入这两个Type实体。针对token，我们拿到了所有需要储存元数据。我们可以从将要处理的事件中获取元数据，或者我们也可以从某一个单独的智能合约或数据源获取type的数据，再或者直接从The Graph节点获取数据。\\n\\n在mapping部分，本质上可以使用不同的数据源来填充我们在这里定义的types。凡是用过GraphQL的人，应该都知道感叹号代表必填项。如没有感叹号 则为可选字段或可留白字段，所以我们要输入tokenID contentURI metadataURI、createdAtTimestamp creator 还有owner，然后是user type。user基本上会有一对多的关系。一个user可以创建很多token也可以购买很多token所以user既可以是创建者 也可以是消费者我们创建这些关系和使用这些directives的方式是，如果你曾经用过类似Amplify，或者许多其他GraphQL指令，你可能见过类似的东西比如说directive。\\n\\n我们现在的情况是想让这个created字段由上面的creator生成得出一个地址通常应该是个钱包地址然后基本上我们就能够在user和token之间建立相互关系或者说在user和一系列token之间。好的 这个说完了 我们保存一下。现在说到subgraph.yaml，这里我们要做一些改动。我们已经有地址了，我们创建这个的时候就设置好了。\\n\\n \\n \\n\\n**设置StartBlock**\\n\\n下一件事是设置startBlock。startBlock的作用是告诉索引器，从哪里索取这些数据，因为如果你按原样部署，它就会从区块链的创世区块开始意味着它会找到以太坊上的第一笔交易，然后从那里开始索引实在有点耗时。但是呢，我们其实可以设置startBlock。startBlock如何具体操作呢，我们先点开智能合约本身。在这里，这就是合约本身，要如何找到Block编码呢？点击Transactions，查看最后一笔交易找到它的Block编码所以这个就是我们区块开始的地方也就是我们这里用到的区块。现在这些entities，我们下一步来码它们。它们和GraphQL的entities相匹配所以我们有token和user。我们最后要处理的是eventHandlers，我们要处理的三个event是Transfer（转移） 。每次���建或转移token时都会触发此事件。如果我创建一个token，这个event会被触发，如果我转给别人 也会触发event。这是跟踪所有现有token的好方法，然后另外两个handler会记录更新，所以如果我修改了metadataURI或者改了tokenURI，都可以在这里追踪到这些字段可以调用mapping中的函数，名称是handleTokenMetadataURIUpdated、handleTokenURIUpdated和handleTransfer。这个部分说完了，我们现在可以回到CLI，接下来要做的是写mapping。\\n\\n \\n \\n\\n**写Mapping**\\n\\nmapping怎么写呢？我们有一个GraphTS库，里面储存了Graph typescript 可以和CLI一起配合使用。有了这个库，你可以直接和区块链对话，可以和以太坊以及The Graph节点对话。**如果你已经在那里存储了一些数据，现在你想检索这些数据，你可以通过跟它对话获取。我们实际上使用The Graph CLI来为你生成很多这样的代码，用起来非常简单，我们只需要运行graph codegen 就可以生成代码**。这个操作可以完成很多事情，它可以查看GraphQL schema 智能合约ABI，然后生成了一堆函数和type，都是我们用得到的type。生成好type之后，我们可以在generated文件夹里找到一些已经生成的东西。我们应该有token和user的两个类，这里都有我们不需要更新这个，只是展示给你们看看如何操作。\\n\\n接下来我们要做的是打开mapping.ts，我先删除所有这些东西，然后导入我们想要使用的东西。我现在看这个博客，这段代码不是太规范，我一会就把它规范化。首先我们要从generated文件夹下的token文件夹里，导入内容TokenURIUpdatedEvent和TransferEvent保证了type的安全。代币合约的字段是Token as TokenContract，我们通过这个类与实际的智能合约交互这样我们就可以调用智能合约了。\\n\\n然后token和user两类，我觉得它们能帮你与The Graph节点对话，也就是说 如果我存储了一些东西，作为索引器 我想检索这些数据。我可以使用这里的类。我们还有三个函数要处理，分别是handleTokenMetadataURIUpdated、handleTokenURIUpdated以及handleTransfer。所以在我们mapping里需要三个handler函数，最大的一个是handleTransfer，这个函数用于处理发币和转币。\\n\\n理解了这些之后，我们能够处理一些不同的情况比如 某币之前从未被创建出来的情况以及已经被创建出来的情况。因为如果某个token正在被创建，这意味着它还没问世如果它被转移给了别人，这意味着这个token已经存在了所以我们能做的第一件事就是使用我们生成的代码里的Token。来先看看现有的节点，基本就是调用这个数据库，如果这个token存在 就把它调出来。如果不存在，我们要创建一个然后在这里 我们设置一堆元数据比如creator tokenID以及createdAtTimestamp然后我们调用智能合约本身因为在这个事件中我们只获得了特定的数据，但我们可以回调智能合约以获得其他数据所以我们需要从智能合约里获取的内容是contentURI以及metadataUR。这里就是在调用智能合约然后在这给它添加额外字段包括token还有creator tokenID以及createdAtTimestamp紧接着是其他内容信息。\\n\\n现在我们来更改owner或者设置owner因为它可能是个新token 还没有owner然后将其保存到The Graph节点中。user也是同样的操作，如果user存在 就加载user，如果不存在 就创建user。最后两个我们需要的函数，（一个）是用来处理handleTokenURIUpdated和TokenContentURIUpdated的函数。TokenURIUpdated的作用是获取token更新contentURI 然后保存另一个是TokenMetadataURIUpdated这个暂时还没写进来所以我现在来写一下。\\n\\n我先复制这个就得到了event（TokenMetadaraURIUpdatedEvent），Github Copilot帮我写了出来。这个tokenMetadataURIUpdated event加进来了，我们现在要设置metadataURI然后就好了现在我们已经写好了mapping写好了所需的三个函数，分别是handleTransfer handleTokenURIUpdated、和tokenMetadataURIUpdated 。我们的Subgraph在这，这些是events的定义，差不多可以开始部属了，所以我要回到CLI开始跑graph deploy。这里我们可以定义studio，所以我们写上 –studio，然后粘贴Subgraph的名称，就在这里，我将它命名为版本0.1。哦，我刚忘了一点，需要先输入graph auth—studio。这里我将得到部署密钥好，应该是部署好了，看起来都部署好了。现在我们可以回到控制面板，大家可以看到已经和GraphQL操作界面一同进行了更新。\\n\\n现在我们可以继续运行一些查询，然后我们可以把这些转移到下一个JS应用程序中。我们可能会传入一些参数例如排列方式降序或者再按照createdAtTimestamp排序我们已经开始看到一些数据在传回。如果我们看一下contentURI，可以看到，有实际的contentURI在回传传回了内容。好，我们的次级subgraph已经部署完毕，如果大家想知道如何从前端查询，可以从这里看到详细信息，这里有查询URL，复制，我会去应该是graphql bin这样的地址。\\n\\n大家可以看到我们也可以用这个GraphQL bin或任何其他不同的GraphQL UI。好，我们的API运转正常。这就是我们要用的URL。现在我们继续跳转到前端应用。现在我想做的是创建下一个新的JS应用程序，将它命名为zora UI，应该会显示在这里。我们想要在这个API上构建一个UI，我会使用tailwind，因为tailwind很好用。下面安装tailwind所需的各项内容，然后初始化tailwind项目，进入globals.css，继续操作，一切就绪。\\n\\n在UI中我可能会去index.js，这就是我们下一步的工作，先删除所有代码。下面我需要输入useState和useEffect from react。我可能需要一些可以参考的代码，我不想直接引用，但是我确实想用一下来启动程序。现在我们有getServerSideProps，有了这个我们就可以调用fetchData函数fetchData。会调用GraphQL API，这里会显示为props，然后我们使用console.log功能，我们可能用不到useState，因为明年才用，所以现在就跳过这些props。这就是我们的第一步，现在我需要做的是如何真正地去调用GraphQL API。\\n\\n好，现在我们已经将内容输入到了文件里，我们还有一些资料是关于各类GraphQL client的。这里你可以使用Apollo或者URQL，这次我先用URQL，单纯因为代码少一些。那么我继续安装URQL和GraphQL。现在URQL和GraphQL都安装好了。我要做的是先把所有代码复制下来，在应用程序中分开现在已经写好了createClient from urql。我们现在有API URL，我们之后会用的API URL就是这个API。现在进入这个URL进行查询。我们先使用一个我们确信会正常运行的查询，回到API，写下一个查询，然后复制粘贴。我们也可以先设置，获取前10个结果。这就是我们的查询了。这将是我们的client。创建client，设置URL，然后调用它获取数据。下一步，继续针对log数据使用console功能，返回得到一个空白数组。好。好，现在我们的基本功能已就绪。\\n\\n \\n \\n\\n **运行程序**\\n\\n下一步，运行程序。我得把现在运行的另一台服务器先关闭。是这一台 localhost 3000。运行开始后，我们这里会退出的。现在可以了，显示出来了。这是我们的数据。这里显示的是data.data.tokens。那么我们可以返回data.data.tokens。在UI中我们可以看到代币应该会显示出来好的。可以了，我们有10个代币。我们也拿到了contentURI。这是我们的metadataURImetadataURI，包含此类内容，比如，mimeType名称、版本号、描述之类的可以用在用户界面的内容。\\n\\n很好，现在基本功能就绪。现在我们只需要在上面建立一些设计。设计的内容实际上。另一件需要考虑的事情就是对数据进行mapping。因为现在返回的方式我们可能会想要稍微改变一下，比如从数据里面我们无法直接知道mineType等内容。要想知道mineType，有了mineType才能展示。我们就必须要调用fetch或者axios 或者类似的HTTP请求来得到JSON数据。这样一来，我们就能知道是图片是视频还是gif，以及我们要如何显示这个文件。所以我们需要这个数据，这个元数据。我们要做的有点儿像用一个函数去对映这个数据。现在我们要做的是键入data.data.tokens.map，然后我们就可以为任何文件实现mapping，然后调用fetch得到元数据。\\n\\n现在，幸运的是我已经创建了能实现这一点的函数。这样一来，我们就不用再从头做。跳转到我的GitHub，已经有了调用数据的函数，用这个把它替换掉就可以了。也许可以删除一些console.log，好的基本上这个函数可以map所有tokens。我们需要调用元数据，然后我们会基于原数据更新媒体类型。所以，如果是mp4格式，我们就显示视频。如果是音频，就显示音频。如果是图片，就显示图片。一旦我们有了这些更新的元数据，或者刷新一下，不出意外的话，我们应该能看到元数据。我现在要更新查询。先输入1，让系统返还1个结果，现在我要重启服务器。好的，这就是我们的token。我们现在已经有了元数据，描述mimeType、名称、版本号。\\n\\n \\n \\n\\n **构建实际式样**\\n\\n最后一项任务就是使用tailwind来构建实际式样。这里有一个UI的实例，我们会用到这个例子，那么让我先来复制在推特上发布出去，让这些内容可用。可能也会把它放在评论中。但是这个代码没什么复杂的。就是使用tailwind的一些基本css，我们要做的是现在有了props，有了tokens，刷新一下UI，就显示在这里了。现在要做的，把之前1这个数字改为比如10这个数字。哦好吧，貌似看上去有点丑。好，我想我知道我漏掉了什么了。漏掉了这个。现在好了，现在UI显示出来了。大家看有各种不同的NFT，一定有一些mimetype我没有考虑到。让我们看看是什么mimetype。或者不知道什么原因没有加载出来。看起来好像，好的，现在在上传了。似乎是个音频，我不确定为什么音频运行不起来。我可以查看一下原因，但步骤就是这样了。\\n\\n我刚才展示的就是如何构建这个程序。有趣的是，如果你是开发者，想从API中赚钱，这就是像我之前说的一个自治应用程序能发挥的功能。这个程序开发给用户使用让他们开发各种产品，相互竞争进步，带来越多高质量的API。你还可以把它发布在网络上，开始赚取查询费。如果你把这个发布出来，谁想用都可以用，大家使用这个应用程序你就可以赚钱。你什么都不需要做，就是把它放在那里，如果有人用的话，你就会从中赚到一部分的钱。将你的信息应用程序的交易写到区块链上即可。\\n\\n这个过程，特别有意思你就只需要发布即可。一旦发布了，它就会一直在那里，而且，我想说对我来说这个过程很有价值。如果你也想这样做，首先你要有一些代币，那么现在我手中有一些代币。我可以把它发布在Rinkeby上或者主网上。现在跳转到Rinkeby，这里要进行一些测试。下一步，然后发布选择Rinkeby网络。可能这里需要操作一番。我先把这些地址取消关联，重新连接，再试一次，发布似乎遇到了一些问题，我先查看一下。好像是这里显示我没有eth，但是我账户有哦。我知道应该怎么弄了。让我先断开，再重连。我觉得是因为验证的时候我用的钱包不对。发布之后它应该会显示在网络上。我可以测试一下，因为这是Rinkeby测试网。但是如果你发布这个到主网，那么就会有用户开始付钱使用它。现在我关掉屏幕共享，看一下大家有什么问题或者疑惑。\\n\\n### 写在最后\\n\\n此次专访收获颇丰，感谢来自The Graph的Nader Dabit的精彩演讲。The Graph项目通过索引区块链数据的托管服务解决了这个问题。然后可以使用标准GraphQL API查询这些索引（“subgraphs”）。简单来说，**subgraph就像是开发者编写的数据索引具体的业务逻辑，一旦业务逻辑部署完成，那么它会根据部署不停更新相应的数据库，以方便开发者随时提取调用。**接下来我们将继续邀请更多嘉宾参与，无论是专访，还是Workshop形式或者其他任何方式，我们都希望能为有志于在layer2方向深入探索的伙伴带来更多灵感，为此尽绵薄之力！\\n\\n**关于 Nader Dabit：**\\n\\nNader Dabit目前在Edge和Node工作，帮助建立去中心化的未来。曾在亚马逊网络服务部领导前端网络和移动的开发人员宣传工作。专注于GraphQL、跨平台和云支持的网络和移动应用开发。在AWS上使用GraphQL和无服务器技术的组合开发应用程序和参考架构。\\n\\n### 活动预告\\n\\n接下来，我们将分别进行Polygon，Aztec等等针对本次黑客松的线上workshop分享，敬请关注！\\n\\n**Polygon**\\n\\n主题：《如何使用Polygon进行应用扩展》\\n\\n 时间：2021.7.20 \\n\\n👀  直播链接：*http://live.bilibili.com/23288126*\\n\\n**Aztec**\\n\\n主题：待定\\n\\n时间：2021.7.24 （拟）\\n\\n👀  直播链接：*http://live.bilibili.com/23288126*\\n\\n其他workshop时间及主题正在确认中，敬请关注！\\n\\n \\n \\n\\n![](https://images.mirror-media.xyz/publication-images/y84_ZM8MzXb5m7xkp1DD-.jpg?height=888&width=1890)\\n\\n\",\"timestamp\":1642409242,\"title\":\"L2 The Graph专题 | 通用API层：用GraphQL, The Graph 与 Next.js在以太坊上开发\"},\"digest\":\"YG34oLxkZn8BJViVA8C9OF7NuJ6DAQWTpiiwwaQi9Mg\",\"authorship\":{\"contributor\":\"0x5Eba828AB4999825D8416D7EAd9563b64FD90276\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"vfbDo9LoM4JsLXJReImBKPScsREbsknZ3DBvIkTPuY8\\\",\\\"y\\\":\\\"VsJvWOFcjNa6PFy-H4RKKRIzzBkzrn2OqxDRrhfID0g\\\"}\",\"signature\":\"34Cp6Oo6FGiPeb6ebjfFTZrYJ7c3LJofv9JEZllfU-ng1xgNLHP3IeDw6gbqK_b51MM7qYH3L3QUjQIaDQhy9g\",\"signingKeySignature\":\"0x388807b7638e5119d43755be8f4323b255625a124080848b9edfcc905bc1d41e5e2d28df1d6eafbcbf89aa06acd81e7044dc7689851d7bc4f647207014893f8a1b\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"vfbDo9LoM4JsLXJReImBKPScsREbsknZ3DBvIkTPuY8\\\",\\\"y\\\":\\\"VsJvWOFcjNa6PFy-H4RKKRIzzBkzrn2OqxDRrhfID0g\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"YG34oLxkZn8BJViVA8C9OF7NuJ6DAQWTpiiwwaQi9Mg\"}"